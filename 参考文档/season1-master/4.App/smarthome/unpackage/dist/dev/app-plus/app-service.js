(this["webpackJsonp"] = this["webpackJsonp"] || []).push([["app-service"],[
/* 0 */
/*!***********************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/main.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("__webpack_require__(/*! uni-pages */ 1);var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 11));\nvar _App = _interopRequireDefault(__webpack_require__(/*! ./App */ 18));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(Object(source), true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(Object(source)).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}\n\n_vue.default.config.productionTip = false;\n\n_App.default.mpType = 'app';\n\nvar app = new _vue.default(_objectSpread({},\n_App.default));\n\napp.$mount();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vbWFpbi5qcyJdLCJuYW1lcyI6WyJWdWUiLCJjb25maWciLCJwcm9kdWN0aW9uVGlwIiwiQXBwIiwibXBUeXBlIiwiYXBwIiwiJG1vdW50Il0sIm1hcHBpbmdzIjoiQUFBQSx3Q0FBbUI7QUFDbkIsd0U7O0FBRUFBLGFBQUlDLE1BQUosQ0FBV0MsYUFBWCxHQUEyQixLQUEzQjs7QUFFQUMsYUFBSUMsTUFBSixHQUFhLEtBQWI7O0FBRUEsSUFBTUMsR0FBRyxHQUFHLElBQUlMLFlBQUo7QUFDTEcsWUFESyxFQUFaOztBQUdBRSxHQUFHLENBQUNDLE1BQUoiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAndW5pLXBhZ2VzJztpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCdcclxuXHJcblZ1ZS5jb25maWcucHJvZHVjdGlvblRpcCA9IGZhbHNlXHJcblxyXG5BcHAubXBUeXBlID0gJ2FwcCdcclxuXHJcbmNvbnN0IGFwcCA9IG5ldyBWdWUoe1xyXG4gICAgLi4uQXBwXHJcbn0pXHJcbmFwcC4kbW91bnQoKSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!**************************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/pages.json ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


if (typeof Promise !== 'undefined' && !Promise.prototype.finally) {
  Promise.prototype.finally = function (callback) {
    var promise = this.constructor;
    return this.then(
    function (value) {return promise.resolve(callback()).then(function () {return value;});},
    function (reason) {return promise.resolve(callback()).then(function () {
        throw reason;
      });});

  };
}

if (uni.restoreGlobal) {
  uni.restoreGlobal(weex, plus, setTimeout, clearTimeout, setInterval, clearInterval);
}
__definePage('pages/index/index', function () {return Vue.extend(__webpack_require__(/*! pages/index/index.vue?mpType=page */ 2).default);});
__definePage('pages/my/my', function () {return Vue.extend(__webpack_require__(/*! pages/my/my.vue?mpType=page */ 13).default);});

/***/ }),
/* 2 */
/*!*************************************************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/index/index.vue?mpType=page ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.vue?vue&type=template&id=2be84a3c&mpType=page */ 3);\n/* harmony import */ var _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.vue?vue&type=script&lang=js&mpType=page */ 5);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js */ 12);\n\nvar renderjs\n\n\n\n\n/* normalize component */\n\nvar component = Object(_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null,\n  false,\n  _index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"components\"],\n  renderjs\n)\n\ncomponent.options.__file = \"pages/index/index.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNkg7QUFDN0g7QUFDb0U7QUFDTDs7O0FBRy9EO0FBQzZMO0FBQzdMLGdCQUFnQiwyTEFBVTtBQUMxQixFQUFFLHNGQUFNO0FBQ1IsRUFBRSwyRkFBTTtBQUNSLEVBQUUsb0dBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsK0ZBQVU7QUFDWjtBQUNBOztBQUVBO0FBQ2UsZ0YiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zLCByZWN5Y2xhYmxlUmVuZGVyLCBjb21wb25lbnRzIH0gZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTJiZTg0YTNjJm1wVHlwZT1wYWdlXCJcbnZhciByZW5kZXJqc1xuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmbXBUeXBlPXBhZ2VcIlxuZXhwb3J0ICogZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJm1wVHlwZT1wYWdlXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsLFxuICBmYWxzZSxcbiAgY29tcG9uZW50cyxcbiAgcmVuZGVyanNcbilcblxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWdlcy9pbmRleC9pbmRleC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/*!*******************************************************************************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/index/index.vue?vue&type=template&id=2be84a3c&mpType=page ***!
  \*******************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--10-0!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./index.vue?vue&type=template&id=2be84a3c&mpType=page */ 4);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__["recyclableRender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "components", function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_mpType_page__WEBPACK_IMPORTED_MODULE_0__["components"]; });



/***/ }),
/* 4 */
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--10-0!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/index/index.vue?vue&type=template&id=2be84a3c&mpType=page ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return recyclableRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "components", function() { return components; });
var components
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: _vm._$s(0, "sc", "wrapper"), attrs: { _i: 0 } },
    [
      _c(
        "div",
        { staticClass: _vm._$s(1, "sc", "header-wrapper"), attrs: { _i: 1 } },
        [
          _c(
            "div",
            { staticClass: _vm._$s(2, "sc", "header-title"), attrs: { _i: 2 } },
            [
              _c("span", [_vm._v(_vm._$s(3, "t0-0", _vm._s(_vm.airText)))]),
              _c("span", [
                _vm._v(
                  _vm._$s(4, "t0-0", _vm._s(_vm.area)) +
                    _vm._$s(4, "t0-1", _vm._s(_vm.city))
                )
              ])
            ]
          ),
          _c(
            "div",
            { staticClass: _vm._$s(5, "sc", "header-text"), attrs: { _i: 5 } },
            [
              _c("span", [_vm._v(_vm._$s(6, "t0-0", _vm._s(_vm.airValue)))]),
              _c("span", [_vm._v(_vm._$s(7, "t0-0", _vm._s(_vm.weather)))])
            ]
          ),
          _c(
            "div",
            {
              staticClass: _vm._$s(8, "sc", "weather-advice"),
              attrs: { _i: 8 }
            },
            [_vm._v(_vm._$s(8, "t0-0", _vm._s(_vm.weatherAdvice)))]
          )
        ]
      ),
      _c(
        "div",
        { staticClass: _vm._$s(9, "sc", "body-wrapper"), attrs: { _i: 9 } },
        [
          _c(
            "div",
            { staticClass: _vm._$s(10, "sc", "body"), attrs: { _i: 10 } },
            [
              _c(
                "div",
                {
                  staticClass: _vm._$s(11, "sc", "data-wrapper"),
                  attrs: { _i: 11 }
                },
                [
                  _c(
                    "div",
                    {
                      staticClass: _vm._$s(12, "sc", "data"),
                      attrs: { _i: 12 }
                    },
                    [
                      _c("image", {
                        staticClass: _vm._$s(13, "sc", "data-logo"),
                        attrs: { _i: 13 }
                      }),
                      _c(
                        "div",
                        {
                          staticClass: _vm._$s(14, "sc", "data-text"),
                          attrs: { _i: 14 }
                        },
                        [
                          _c("div", {
                            staticClass: _vm._$s(15, "sc", "data-title"),
                            attrs: { _i: 15 }
                          }),
                          _c(
                            "div",
                            {
                              staticClass: _vm._$s(16, "sc", "data-value"),
                              attrs: { _i: 16 }
                            },
                            [_vm._v(_vm._$s(16, "t0-0", _vm._s(_vm.Temp)))]
                          )
                        ]
                      )
                    ]
                  ),
                  _c(
                    "div",
                    {
                      staticClass: _vm._$s(17, "sc", "data"),
                      attrs: { _i: 17 }
                    },
                    [
                      _c("image", {
                        staticClass: _vm._$s(18, "sc", "data-logo"),
                        attrs: { _i: 18 }
                      }),
                      _c(
                        "div",
                        {
                          staticClass: _vm._$s(19, "sc", "data-text"),
                          attrs: { _i: 19 }
                        },
                        [
                          _c("div", {
                            staticClass: _vm._$s(20, "sc", "data-title"),
                            attrs: { _i: 20 }
                          }),
                          _c(
                            "div",
                            {
                              staticClass: _vm._$s(21, "sc", "data-value"),
                              attrs: { _i: 21 }
                            },
                            [_vm._v(_vm._$s(21, "t0-0", _vm._s(_vm.Hum)))]
                          )
                        ]
                      )
                    ]
                  )
                ]
              ),
              _c(
                "div",
                {
                  staticClass: _vm._$s(22, "sc", "data-wrapper"),
                  attrs: { _i: 22 }
                },
                [
                  _c(
                    "div",
                    {
                      staticClass: _vm._$s(23, "sc", "data"),
                      attrs: { _i: 23 }
                    },
                    [
                      _c("image", {
                        staticClass: _vm._$s(24, "sc", "data-logo"),
                        attrs: { _i: 24 }
                      }),
                      _c(
                        "div",
                        {
                          staticClass: _vm._$s(25, "sc", "data-text"),
                          attrs: { _i: 25 }
                        },
                        [
                          _c("div", {
                            staticClass: _vm._$s(26, "sc", "data-title"),
                            attrs: { _i: 26 }
                          }),
                          _c(
                            "div",
                            {
                              staticClass: _vm._$s(27, "sc", "data-value"),
                              attrs: { _i: 27 }
                            },
                            [_vm._v(_vm._$s(27, "t0-0", _vm._s(_vm.Light)))]
                          )
                        ]
                      )
                    ]
                  ),
                  _c(
                    "div",
                    {
                      staticClass: _vm._$s(28, "sc", "data"),
                      attrs: { _i: 28 }
                    },
                    [
                      _c("image", {
                        staticClass: _vm._$s(29, "sc", "data-logo"),
                        attrs: { _i: 29 }
                      }),
                      _c(
                        "div",
                        {
                          staticClass: _vm._$s(30, "sc", "data-text"),
                          attrs: { _i: 30 }
                        },
                        [
                          _c("div", {
                            staticClass: _vm._$s(31, "sc", "data-title"),
                            attrs: { _i: 31 }
                          }),
                          _c(
                            "div",
                            {
                              staticClass: _vm._$s(32, "sc", "data-value"),
                              attrs: { _i: 32 }
                            },
                            [
                              _c("switch", {
                                attrs: {
                                  checked: _vm._$s(33, "a-checked", _vm.Led),
                                  _i: 33
                                },
                                on: { change: _vm.onLedChange }
                              })
                            ]
                          )
                        ]
                      )
                    ]
                  )
                ]
              ),
              _c(
                "div",
                {
                  staticClass: _vm._$s(34, "sc", "data-wrapper"),
                  attrs: { _i: 34 }
                },
                [
                  _c(
                    "div",
                    {
                      staticClass: _vm._$s(35, "sc", "data"),
                      attrs: { _i: 35 }
                    },
                    [
                      _c("image", {
                        staticClass: _vm._$s(36, "sc", "data-logo"),
                        attrs: { _i: 36 }
                      }),
                      _c(
                        "div",
                        {
                          staticClass: _vm._$s(37, "sc", "data-text"),
                          attrs: { _i: 37 }
                        },
                        [
                          _c("div", {
                            staticClass: _vm._$s(38, "sc", "data-title"),
                            attrs: { _i: 38 }
                          }),
                          _c(
                            "div",
                            {
                              staticClass: _vm._$s(39, "sc", "data-value"),
                              attrs: { _i: 39 }
                            },
                            [
                              _c("switch", {
                                attrs: {
                                  checked: _vm._$s(40, "a-checked", _vm.Beep),
                                  _i: 40
                                },
                                on: { change: _vm.onBeepChange }
                              })
                            ]
                          )
                        ]
                      )
                    ]
                  )
                ]
              )
            ]
          )
        ]
      )
    ]
  )
}
var recyclableRender = false
var staticRenderFns = []
render._withStripped = true



/***/ }),
/* 5 */
/*!*************************************************************************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/index/index.vue?vue&type=script&lang=js&mpType=page ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/babel-loader/lib!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./index.vue?vue&type=script&lang=js&mpType=page */ 6);\n/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW9wQixDQUFnQiw4bkJBQUcsRUFBQyIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9Qcm9ncmFtIEZpbGVzL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3dlYnBhY2stcHJlcHJvY2Vzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXVuaS1hcHAtbG9hZGVyL3VzaW5nLWNvbXBvbmVudHMuanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmbXBUeXBlPXBhZ2VcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9Qcm9ncmFtIEZpbGVzL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3dlYnBhY2stcHJlcHJvY2Vzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXVuaS1hcHAtbG9hZGVyL3VzaW5nLWNvbXBvbmVudHMuanMhLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmbXBUeXBlPXBhZ2VcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/index/index.vue?vue&type=script&lang=js&mpType=page ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__f__) {Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = void 0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar _mqtt = __webpack_require__(/*! ../../utils/mqttjs3/mqtt */ 8); //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n/******************* 必须要改！！不然得不到天气！！ ******************/var hefengKey = '8d90114ce9334ccbbcf6dec72f534bd6'; //  和风天气Web api的key\n/******************* 可能需要你修改的部分 ******************/var mqttHost = 'broker.emqx.io'; //mqtt 服务器域名/IP\nvar mqttPort = 8084; //mqtt 服务器域名/IP\nvar hefengVIP = false; //  和风天气是免费的api（false）还是付费api（true）\nvar deviceSubTopic = '/mysmarthome/sub'; //  设备订阅topic（小程序发布命令topic）\nvar devicePubTopic = '/mysmarthome/pub'; //  设备发布topic（小程序订阅数据topic）\n/********************* 一般不用动这些 ********************/var mpSubTopic = devicePubTopic;var mpPubTopic = deviceSubTopic;var mqttUrl = \"wxs://\".concat(mqttHost, \":\").concat(mqttPort, \"/mqtt\"); //  mqtt连接路径\nvar hefengApi = 'https://api.qweather.com/v7'; //  和风天气付费API前缀\nvar hefengFreeApi = 'https://devapi.qweather.com/v7'; //  和风天气免费API前缀\nvar hefengWeather = \"\".concat(hefengVIP ? hefengApi : hefengFreeApi, \"/weather/now?\"); //  和风天气实时天气api\nvar hefengAir = \"\".concat(hefengVIP ? hefengApi : hefengFreeApi, \"/air/now?\"); //  和风天气空气质量api\nvar geoApi = 'https://geoapi.qweather.com/v2/city/lookup?'; //  地理位置api（用来获取经纬度对应的城市/城区名字）\nvar _default = { data: function data() {return { client: {}, Temp: 0, Hum: 0, Light: 0, Led: false, Beep: false, area: '请求中', //城区\n      city: '请求中', //城市\n      airText: '请求中', //空气优良\n      airValue: 0, //空气指数\n      weather: '请求中', //天气\n      weatherAdvice: '今天天气不错' //天气建议\n    };}, onShow: function onShow() {var that = this;uni.showToast({ title: '连接服务器....', icon: 'loading', duration: 10000, mask: true });var second = 10;var toastTimer = setInterval(function () {second--;if (!second) {clearInterval(toastTimer);uni.showToast({ title: '连接失败', icon: 'none', mask: true });}}, 1000);that.client = (0, _mqtt.connect)(mqttUrl);that.client.on('connect', function () {__f__(\"log\", '成功连接mqtt服务器！', \" at pages/index/index.vue:130\");clearInterval(toastTimer);uni.showToast({ title: '连接成功', icon: 'success', mask: true }); // 一秒后订阅主题\n      setTimeout(function () {that.client.subscribe(mpSubTopic, function (err) {if (!err) {__f__(\"log\", '成功订阅设备上行数据Topic!', \" at pages/index/index.vue:141\");uni.showToast({ title: '订阅成功',\n              icon: 'success',\n              mask: true });\n\n          }\n        });\n      }, 1000);\n    });\n    that.client.on('message', function (topic, message) {\n      __f__(\"log\", topic, \" at pages/index/index.vue:152\");\n      // message是16进制的Buffer字节流\n      var dataFromDev = {};\n      // 尝试进行JSON解析\n      try {\n        dataFromDev = JSON.parse(message);\n        __f__(\"log\", dataFromDev, \" at pages/index/index.vue:158\");\n        that.Temp = dataFromDev.Temp;\n        that.Hum = dataFromDev.Hum;\n        that.Light = dataFromDev.Light;\n        that.Led = dataFromDev.Led;\n        that.Beep = dataFromDev.Beep;\n      } catch (error) {\n        // 解析失败错误捕获并打印（错误捕获之后不会影响程序继续运行）\n        __f__(\"log\", error, \" at pages/index/index.vue:166\");\n      }\n    });\n\n    uni.getLocation({\n      type: 'wgs84',\n      success: function success(res) {\n        var latitude = res.latitude;\n        var longitude = res.longitude;\n        var key = hefengKey;\n\n        uni.request({\n          url: \"\".concat(geoApi, \"location=\").concat(longitude, \",\").concat(latitude, \"&key=\").concat(key), //获取地理位置\n          success: function success(res) {\n            __f__(\"log\", res.data, \" at pages/index/index.vue:180\");\n            if (res.data.code == '401') {\n              __f__(\"error\", 'HUAQING --- 地理位置获取失败，请检查你的和风天气API或Key是否正确！', \" at pages/index/index.vue:182\");\n              return;\n            } else if (res.data.code == '403') {\n              __f__(\"error\", 'HUAQING --- 地理位置获取失败，和风天气服务器故障！', \" at pages/index/index.vue:185\");\n              return;\n            }\n            try {var\n              location = res.data.location;\n\n              that.area = location[0].name; //城区\n              that.city = location[0].adm2; //城市\n            } catch (error) {\n              __f__(\"error\", error, \" at pages/index/index.vue:194\");\n            }\n          } });\n\n        uni.request({\n          url: \"\".concat(hefengWeather, \"location=\").concat(longitude, \",\").concat(latitude, \"&key=\").concat(key), //获取实时天气数据\n          success: function success(res) {\n            __f__(\"log\", res.data, \" at pages/index/index.vue:201\");\n            if (res.data.code == '401') {\n              __f__(\"error\", 'HUAQING --- 获取实时天气数据失败，请检查你的和风天气API或Key是否正确！', \" at pages/index/index.vue:203\");\n              return;\n            } else if (res.data.code == '403') {\n              __f__(\"error\", 'HUAQING --- 获取实时天气数据失败，和风天气服务器故障！', \" at pages/index/index.vue:206\");\n              return;\n            }\n            try {var\n              now = res.data.now;\n              that.weather = now.text;\n            } catch (error) {\n              __f__(\"error\", error, \" at pages/index/index.vue:213\");\n            }\n          } });\n\n        uni.request({\n          url: \"\".concat(hefengAir, \"location=\").concat(longitude, \",\").concat(latitude, \"&key=\").concat(key), //获取空气数据\n          success: function success(res) {\n            __f__(\"log\", res.data, \" at pages/index/index.vue:220\");\n            if (res.data.code == '401') {\n              __f__(\"error\", 'HUAQING --- 获取空气数据失败，请检查你的和风天气API或Key是否正确！', \" at pages/index/index.vue:222\");\n              return;\n            } else if (res.data.code == '403') {\n              __f__(\"error\", 'HUAQING --- 获取空气数据失败，和风天气服务器故障！', \" at pages/index/index.vue:225\");\n              return;\n            }\n            try {var\n              now = res.data.now;\n              that.airText = now.category;\n              that.airValue = now.aqi;\n            } catch (error) {\n              __f__(\"error\", error, \" at pages/index/index.vue:233\");\n            }\n          } });\n\n      } });\n\n  },\n  onHide: function onHide() {\n    var that = this;\n    that.client.end();\n  },\n  methods: {\n    onLedChange: function onLedChange(event) {\n      var that = this;\n      __f__(\"log\", event.detail, \" at pages/index/index.vue:247\");\n      var sw = event.detail.value;\n      that.Led = sw;\n      if (sw) {\n        that.client.publish(mpPubTopic, '{\"target\":\"LED\",\"value\":1}', function (err) {\n          if (!err) {\n            __f__(\"log\", '成功下发命令——开灯', \" at pages/index/index.vue:253\");\n          }\n        });\n      } else {\n        that.client.publish(mpPubTopic, '{\"target\":\"LED\",\"value\":0}', function (err) {\n          if (!err) {\n            __f__(\"log\", '成功下发命令——关灯', \" at pages/index/index.vue:259\");\n          }\n        });\n      }\n    },\n    onBeepChange: function onBeepChange(event) {\n      var that = this;\n      __f__(\"log\", event.detail, \" at pages/index/index.vue:266\");\n      var sw = event.detail.value;\n      that.Beep = sw;\n      if (sw) {\n        that.client.publish(mpPubTopic, '{\"target\":\"BEEP\",\"value\":1}', function (err) {\n          if (!err) {\n            __f__(\"log\", '成功下发命令——打开报警器', \" at pages/index/index.vue:272\");\n          }\n        });\n      } else {\n        that.client.publish(mpPubTopic, '{\"target\":\"BEEP\",\"value\":0}', function (err) {\n          if (!err) {\n            __f__(\"log\", '成功下发命令——关闭报警器', \" at pages/index/index.vue:278\");\n          }\n        });\n      }\n    } } };exports.default = _default;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js */ 7)[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vcGFnZXMvaW5kZXgvaW5kZXgudnVlIl0sIm5hbWVzIjpbImhlZmVuZ0tleSIsIm1xdHRIb3N0IiwibXF0dFBvcnQiLCJoZWZlbmdWSVAiLCJkZXZpY2VTdWJUb3BpYyIsImRldmljZVB1YlRvcGljIiwibXBTdWJUb3BpYyIsIm1wUHViVG9waWMiLCJtcXR0VXJsIiwiaGVmZW5nQXBpIiwiaGVmZW5nRnJlZUFwaSIsImhlZmVuZ1dlYXRoZXIiLCJoZWZlbmdBaXIiLCJnZW9BcGkiLCJkYXRhIiwiY2xpZW50IiwiVGVtcCIsIkh1bSIsIkxpZ2h0IiwiTGVkIiwiQmVlcCIsImFyZWEiLCJjaXR5IiwiYWlyVGV4dCIsImFpclZhbHVlIiwid2VhdGhlciIsIndlYXRoZXJBZHZpY2UiLCJvblNob3ciLCJ0aGF0IiwidW5pIiwic2hvd1RvYXN0IiwidGl0bGUiLCJpY29uIiwiZHVyYXRpb24iLCJtYXNrIiwic2Vjb25kIiwidG9hc3RUaW1lciIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm9uIiwic2V0VGltZW91dCIsInN1YnNjcmliZSIsImVyciIsInRvcGljIiwibWVzc2FnZSIsImRhdGFGcm9tRGV2IiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJnZXRMb2NhdGlvbiIsInR5cGUiLCJzdWNjZXNzIiwicmVzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJrZXkiLCJyZXF1ZXN0IiwidXJsIiwiY29kZSIsImxvY2F0aW9uIiwibmFtZSIsImFkbTIiLCJub3ciLCJ0ZXh0IiwiY2F0ZWdvcnkiLCJhcWkiLCJvbkhpZGUiLCJlbmQiLCJtZXRob2RzIiwib25MZWRDaGFuZ2UiLCJldmVudCIsImRldGFpbCIsInN3IiwidmFsdWUiLCJwdWJsaXNoIiwib25CZWVwQ2hhbmdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThEQSxtRSxDQTlEQTtB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QjtBQUNBN0MsVUFBSSxDQUFDUixJQUFMLEdBQVlvRCxFQUFaO0FBQ0EsVUFBSUEsRUFBSixFQUFRO0FBQ041QyxZQUFJLENBQUNiLE1BQUwsQ0FBWTJELE9BQVosQ0FBb0JuRSxVQUFwQixFQUFnQyw2QkFBaEMsRUFBK0QsVUFBU21DLEdBQVQsRUFBYztBQUMzRSxjQUFJLENBQUNBLEdBQUwsRUFBVTtBQUNSLHlCQUFZLGVBQVo7QUFDRDtBQUNGLFNBSkQ7QUFLRCxPQU5ELE1BTU87QUFDTGQsWUFBSSxDQUFDYixNQUFMLENBQVkyRCxPQUFaLENBQW9CbkUsVUFBcEIsRUFBZ0MsNkJBQWhDLEVBQStELFVBQVNtQyxHQUFULEVBQWM7QUFDM0UsY0FBSSxDQUFDQSxHQUFMLEVBQVU7QUFDUix5QkFBWSxlQUFaO0FBQ0Q7QUFDRixTQUpEO0FBS0Q7QUFDRixLQXRDTSxFQTFKSSxFIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG4vL1xyXG5cclxuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJy4uLy4uL3V0aWxzL21xdHRqczMvbXF0dCc7XHJcbi8qKioqKioqKioqKioqKioqKioqIOW/hemhu+imgeaUue+8ge+8geS4jeeEtuW+l+S4jeWIsOWkqeawlO+8ge+8gSAqKioqKioqKioqKioqKioqKiovXHJcbmNvbnN0IGhlZmVuZ0tleSA9ICc4ZDkwMTE0Y2U5MzM0Y2NiYmNmNmRlYzcyZjUzNGJkNic7IC8vICDlkozpo47lpKnmsJRXZWIgYXBp55qEa2V5XHJcbi8qKioqKioqKioqKioqKioqKioqIOWPr+iDvemcgOimgeS9oOS/ruaUueeahOmDqOWIhiAqKioqKioqKioqKioqKioqKiovXHJcbmNvbnN0IG1xdHRIb3N0ID0gJ2Jyb2tlci5lbXF4LmlvJzsgLy9tcXR0IOacjeWKoeWZqOWfn+WQjS9JUFxyXG5jb25zdCBtcXR0UG9ydCA9IDgwODQ7IC8vbXF0dCDmnI3liqHlmajln5/lkI0vSVBcclxuXHJcbmNvbnN0IGhlZmVuZ1ZJUCA9IGZhbHNlOyAvLyAg5ZKM6aOO5aSp5rCU5piv5YWN6LS555qEYXBp77yIZmFsc2XvvInov5jmmK/ku5jotLlhcGnvvIh0cnVl77yJXHJcblxyXG5jb25zdCBkZXZpY2VTdWJUb3BpYyA9ICcvbXlzbWFydGhvbWUvc3ViJzsgLy8gIOiuvuWkh+iuoumYhXRvcGlj77yI5bCP56iL5bqP5Y+R5biD5ZG95LukdG9waWPvvIlcclxuY29uc3QgZGV2aWNlUHViVG9waWMgPSAnL215c21hcnRob21lL3B1Yic7IC8vICDorr7lpIflj5HluIN0b3BpY++8iOWwj+eoi+W6j+iuoumYheaVsOaNrnRvcGlj77yJXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqIOS4gOiIrOS4jeeUqOWKqOi/meS6myAqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbmNvbnN0IG1wU3ViVG9waWMgPSBkZXZpY2VQdWJUb3BpYztcclxuY29uc3QgbXBQdWJUb3BpYyA9IGRldmljZVN1YlRvcGljO1xyXG5cclxuY29uc3QgbXF0dFVybCA9IGB3eHM6Ly8ke21xdHRIb3N0fToke21xdHRQb3J0fS9tcXR0YDsgLy8gIG1xdHTov57mjqXot6/lvoRcclxuXHJcbmNvbnN0IGhlZmVuZ0FwaSA9ICdodHRwczovL2FwaS5xd2VhdGhlci5jb20vdjcnOyAvLyAg5ZKM6aOO5aSp5rCU5LuY6LS5QVBJ5YmN57yAXHJcbmNvbnN0IGhlZmVuZ0ZyZWVBcGkgPSAnaHR0cHM6Ly9kZXZhcGkucXdlYXRoZXIuY29tL3Y3JzsgLy8gIOWSjOmjjuWkqeawlOWFjei0uUFQSeWJjee8gFxyXG5cclxuY29uc3QgaGVmZW5nV2VhdGhlciA9IGAke2hlZmVuZ1ZJUCA/IGhlZmVuZ0FwaSA6IGhlZmVuZ0ZyZWVBcGl9L3dlYXRoZXIvbm93P2A7IC8vICDlkozpo47lpKnmsJTlrp7ml7blpKnmsJRhcGlcclxuY29uc3QgaGVmZW5nQWlyID0gYCR7aGVmZW5nVklQID8gaGVmZW5nQXBpIDogaGVmZW5nRnJlZUFwaX0vYWlyL25vdz9gOyAvLyAg5ZKM6aOO5aSp5rCU56m65rCU6LSo6YePYXBpXHJcblxyXG5jb25zdCBnZW9BcGkgPSAnaHR0cHM6Ly9nZW9hcGkucXdlYXRoZXIuY29tL3YyL2NpdHkvbG9va3VwPyc7IC8vICDlnLDnkIbkvY3nva5hcGnvvIjnlKjmnaXojrflj5bnu4/nuqzluqblr7nlupTnmoTln47luIIv5Z+O5Yy65ZCN5a2X77yJXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsaWVudDoge30sXHJcbiAgICAgIFRlbXA6IDAsXHJcbiAgICAgIEh1bTogMCxcclxuICAgICAgTGlnaHQ6IDAsXHJcbiAgICAgIExlZDogZmFsc2UsXHJcbiAgICAgIEJlZXA6IGZhbHNlLFxyXG4gICAgICBhcmVhOiAn6K+35rGC5LitJywgLy/ln47ljLpcclxuICAgICAgY2l0eTogJ+ivt+axguS4rScsIC8v5Z+O5biCXHJcbiAgICAgIGFpclRleHQ6ICfor7fmsYLkuK0nLCAvL+epuuawlOS8mOiJr1xyXG4gICAgICBhaXJWYWx1ZTogMCwgLy/nqbrmsJTmjIfmlbBcclxuICAgICAgd2VhdGhlcjogJ+ivt+axguS4rScsIC8v5aSp5rCUXHJcbiAgICAgIHdlYXRoZXJBZHZpY2U6ICfku4rlpKnlpKnmsJTkuI3plJknIC8v5aSp5rCU5bu66K6uXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgb25TaG93KCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdW5pLnNob3dUb2FzdCh7XHJcbiAgICAgIHRpdGxlOiAn6L+e5o6l5pyN5Yqh5ZmoLi4uLicsXHJcbiAgICAgIGljb246ICdsb2FkaW5nJyxcclxuICAgICAgZHVyYXRpb246IDEwMDAwLFxyXG4gICAgICBtYXNrOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIGxldCBzZWNvbmQgPSAxMDtcclxuICAgIHZhciB0b2FzdFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBzZWNvbmQtLTtcclxuICAgICAgaWYgKCFzZWNvbmQpIHtcclxuICAgICAgICBjbGVhckludGVydmFsKHRvYXN0VGltZXIpO1xyXG4gICAgICAgIHVuaS5zaG93VG9hc3Qoe1xyXG4gICAgICAgICAgdGl0bGU6ICfov57mjqXlpLHotKUnLFxyXG4gICAgICAgICAgaWNvbjogJ25vbmUnLFxyXG4gICAgICAgICAgbWFzazogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LCAxMDAwKTtcclxuXHJcbiAgICB0aGF0LmNsaWVudCA9IGNvbm5lY3QobXF0dFVybCk7XHJcbiAgICB0aGF0LmNsaWVudC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBjb25zb2xlLmxvZygn5oiQ5Yqf6L+e5o6lbXF0dOacjeWKoeWZqO+8gScpO1xyXG4gICAgICBjbGVhckludGVydmFsKHRvYXN0VGltZXIpO1xyXG4gICAgICB1bmkuc2hvd1RvYXN0KHtcclxuICAgICAgICB0aXRsZTogJ+i/nuaOpeaIkOWKnycsXHJcbiAgICAgICAgaWNvbjogJ3N1Y2Nlc3MnLFxyXG4gICAgICAgIG1hc2s6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIOS4gOenkuWQjuiuoumYheS4u+mimFxyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGF0LmNsaWVudC5zdWJzY3JpYmUobXBTdWJUb3BpYywgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICBpZiAoIWVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn5oiQ5Yqf6K6i6ZiF6K6+5aSH5LiK6KGM5pWw5o2uVG9waWMhJyk7XHJcbiAgICAgICAgICAgIHVuaS5zaG93VG9hc3Qoe1xyXG4gICAgICAgICAgICAgIHRpdGxlOiAn6K6i6ZiF5oiQ5YqfJyxcclxuICAgICAgICAgICAgICBpY29uOiAnc3VjY2VzcycsXHJcbiAgICAgICAgICAgICAgbWFzazogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSwgMTAwMCk7XHJcbiAgICB9KTtcclxuICAgIHRoYXQuY2xpZW50Lm9uKCdtZXNzYWdlJywgZnVuY3Rpb24odG9waWMsIG1lc3NhZ2UpIHtcclxuICAgICAgY29uc29sZS5sb2codG9waWMpO1xyXG4gICAgICAvLyBtZXNzYWdl5pivMTbov5vliLbnmoRCdWZmZXLlrZfoioLmtYFcclxuICAgICAgbGV0IGRhdGFGcm9tRGV2ID0ge307XHJcbiAgICAgIC8vIOWwneivlei/m+ihjEpTT07op6PmnpBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBkYXRhRnJvbURldiA9IEpTT04ucGFyc2UobWVzc2FnZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coZGF0YUZyb21EZXYpO1xyXG4gICAgICAgIHRoYXQuVGVtcCA9IGRhdGFGcm9tRGV2LlRlbXA7XHJcbiAgICAgICAgdGhhdC5IdW0gPSBkYXRhRnJvbURldi5IdW07XHJcbiAgICAgICAgdGhhdC5MaWdodCA9IGRhdGFGcm9tRGV2LkxpZ2h0O1xyXG4gICAgICAgIHRoYXQuTGVkID0gZGF0YUZyb21EZXYuTGVkO1xyXG4gICAgICAgIHRoYXQuQmVlcCA9IGRhdGFGcm9tRGV2LkJlZXA7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgLy8g6Kej5p6Q5aSx6LSl6ZSZ6K+v5o2V6I635bm25omT5Y2w77yI6ZSZ6K+v5o2V6I635LmL5ZCO5LiN5Lya5b2x5ZON56iL5bqP57un57ut6L+Q6KGM77yJXHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB1bmkuZ2V0TG9jYXRpb24oe1xyXG4gICAgICB0eXBlOiAnd2dzODQnLFxyXG4gICAgICBzdWNjZXNzKHJlcykge1xyXG4gICAgICAgIGNvbnN0IGxhdGl0dWRlID0gcmVzLmxhdGl0dWRlO1xyXG4gICAgICAgIGNvbnN0IGxvbmdpdHVkZSA9IHJlcy5sb25naXR1ZGU7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gaGVmZW5nS2V5O1xyXG5cclxuICAgICAgICB1bmkucmVxdWVzdCh7XHJcbiAgICAgICAgICB1cmw6IGAke2dlb0FwaX1sb2NhdGlvbj0ke2xvbmdpdHVkZX0sJHtsYXRpdHVkZX0ma2V5PSR7a2V5fWAsIC8v6I635Y+W5Zyw55CG5L2N572uXHJcbiAgICAgICAgICBzdWNjZXNzKHJlcykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXMuZGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChyZXMuZGF0YS5jb2RlID09ICc0MDEnKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSFVBUUlORyAtLS0g5Zyw55CG5L2N572u6I635Y+W5aSx6LSl77yM6K+35qOA5p+l5L2g55qE5ZKM6aOO5aSp5rCUQVBJ5oiWS2V55piv5ZCm5q2j56Gu77yBJyk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5kYXRhLmNvZGUgPT0gJzQwMycpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdIVUFRSU5HIC0tLSDlnLDnkIbkvY3nva7ojrflj5blpLHotKXvvIzlkozpo47lpKnmsJTmnI3liqHlmajmlYXpmpzvvIEnKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCB7IGxvY2F0aW9uIH0gPSByZXMuZGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgdGhhdC5hcmVhID0gbG9jYXRpb25bMF0ubmFtZTsgLy/ln47ljLpcclxuICAgICAgICAgICAgICB0aGF0LmNpdHkgPSBsb2NhdGlvblswXS5hZG0yOyAvL+WfjuW4glxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdW5pLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgdXJsOiBgJHtoZWZlbmdXZWF0aGVyfWxvY2F0aW9uPSR7bG9uZ2l0dWRlfSwke2xhdGl0dWRlfSZrZXk9JHtrZXl9YCwgLy/ojrflj5blrp7ml7blpKnmsJTmlbDmja5cclxuICAgICAgICAgIHN1Y2Nlc3MocmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcy5kYXRhKTtcclxuICAgICAgICAgICAgaWYgKHJlcy5kYXRhLmNvZGUgPT0gJzQwMScpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdIVUFRSU5HIC0tLSDojrflj5blrp7ml7blpKnmsJTmlbDmja7lpLHotKXvvIzor7fmo4Dmn6XkvaDnmoTlkozpo47lpKnmsJRBUEnmiJZLZXnmmK/lkKbmraPnoa7vvIEnKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmRhdGEuY29kZSA9PSAnNDAzJykge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0hVQVFJTkcgLS0tIOiOt+WPluWunuaXtuWkqeawlOaVsOaNruWksei0pe+8jOWSjOmjjuWkqeawlOacjeWKoeWZqOaVhemanO+8gScpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgbm93IH0gPSByZXMuZGF0YTtcclxuICAgICAgICAgICAgICB0aGF0LndlYXRoZXIgPSBub3cudGV4dDtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHVuaS5yZXF1ZXN0KHtcclxuICAgICAgICAgIHVybDogYCR7aGVmZW5nQWlyfWxvY2F0aW9uPSR7bG9uZ2l0dWRlfSwke2xhdGl0dWRlfSZrZXk9JHtrZXl9YCwgLy/ojrflj5bnqbrmsJTmlbDmja5cclxuICAgICAgICAgIHN1Y2Nlc3MocmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcy5kYXRhKTtcclxuICAgICAgICAgICAgaWYgKHJlcy5kYXRhLmNvZGUgPT0gJzQwMScpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdIVUFRSU5HIC0tLSDojrflj5bnqbrmsJTmlbDmja7lpLHotKXvvIzor7fmo4Dmn6XkvaDnmoTlkozpo47lpKnmsJRBUEnmiJZLZXnmmK/lkKbmraPnoa7vvIEnKTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmRhdGEuY29kZSA9PSAnNDAzJykge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0hVQVFJTkcgLS0tIOiOt+WPluepuuawlOaVsOaNruWksei0pe+8jOWSjOmjjuWkqeawlOacjeWKoeWZqOaVhemanO+8gScpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHsgbm93IH0gPSByZXMuZGF0YTtcclxuICAgICAgICAgICAgICB0aGF0LmFpclRleHQgPSBub3cuY2F0ZWdvcnk7XHJcbiAgICAgICAgICAgICAgdGhhdC5haXJWYWx1ZSA9IG5vdy5hcWk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuICBvbkhpZGUoKXtcclxuICAgIHZhciB0aGF0ID0gdGhpc1xyXG4gICAgdGhhdC5jbGllbnQuZW5kKClcclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIG9uTGVkQ2hhbmdlKGV2ZW50KSB7XHJcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgY29uc29sZS5sb2coZXZlbnQuZGV0YWlsKTtcclxuICAgICAgbGV0IHN3ID0gZXZlbnQuZGV0YWlsLnZhbHVlO1xyXG4gICAgICB0aGF0LkxlZCA9IHN3O1xyXG4gICAgICBpZiAoc3cpIHtcclxuICAgICAgICB0aGF0LmNsaWVudC5wdWJsaXNoKG1wUHViVG9waWMsICd7XCJ0YXJnZXRcIjpcIkxFRFwiLFwidmFsdWVcIjoxfScsIGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgaWYgKCFlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+aIkOWKn+S4i+WPkeWRveS7pOKAlOKAlOW8gOeBrycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoYXQuY2xpZW50LnB1Ymxpc2gobXBQdWJUb3BpYywgJ3tcInRhcmdldFwiOlwiTEVEXCIsXCJ2YWx1ZVwiOjB9JywgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICBpZiAoIWVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygn5oiQ5Yqf5LiL5Y+R5ZG95Luk4oCU4oCU5YWz54GvJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBvbkJlZXBDaGFuZ2UoZXZlbnQpIHtcclxuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICBjb25zb2xlLmxvZyhldmVudC5kZXRhaWwpO1xyXG4gICAgICBsZXQgc3cgPSBldmVudC5kZXRhaWwudmFsdWU7XHJcbiAgICAgIHRoYXQuQmVlcCA9IHN3O1xyXG4gICAgICBpZiAoc3cpIHtcclxuICAgICAgICB0aGF0LmNsaWVudC5wdWJsaXNoKG1wUHViVG9waWMsICd7XCJ0YXJnZXRcIjpcIkJFRVBcIixcInZhbHVlXCI6MX0nLCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgIGlmICghZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfmiJDlip/kuIvlj5Hlkb3ku6TigJTigJTmiZPlvIDmiqXorablmagnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGF0LmNsaWVudC5wdWJsaXNoKG1wUHViVG9waWMsICd7XCJ0YXJnZXRcIjpcIkJFRVBcIixcInZhbHVlXCI6MH0nLCBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgIGlmICghZXJyKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfmiJDlip/kuIvlj5Hlkb3ku6TigJTigJTlhbPpl63miqXorablmagnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/*!*********************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js ***!
  \*********************************************************************/
/*! exports provided: log, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return formatLog; });
function typof (v) {
  var s = Object.prototype.toString.call(v)
  return s.substring(8, s.length - 1)
}

function isDebugMode () {
  /* eslint-disable no-undef */
  return typeof __channelId__ === 'string' && __channelId__
}

function jsonStringifyReplacer (k, p) {
  switch (typof(p)) {
    case 'Function':
      return 'function() { [native code] }'
    default :
      return p
  }
}

function log (type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key]
  }
  console[type].apply(console, args)
}

function formatLog () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key]
  }
  var type = args.shift()
  if (isDebugMode()) {
    args.push(args.pop().replace('at ', 'uni-app:///'))
    return console[type].apply(console, args)
  }

  var msgs = args.map(function (v) {
    var type = Object.prototype.toString.call(v).toLowerCase()

    if (type === '[object object]' || type === '[object array]') {
      try {
        v = '---BEGIN:JSON---' + JSON.stringify(v, jsonStringifyReplacer) + '---END:JSON---'
      } catch (e) {
        v = type
      }
    } else {
      if (v === null) {
        v = '---NULL---'
      } else if (v === undefined) {
        v = '---UNDEFINED---'
      } else {
        var vType = typof(v).toUpperCase()

        if (vType === 'NUMBER' || vType === 'BOOLEAN') {
          v = '---BEGIN:' + vType + '---' + v + '---END:' + vType + '---'
        } else {
          v = String(v)
        }
      }
    }

    return v
  })
  var msg = ''

  if (msgs.length > 1) {
    var lastMsg = msgs.pop()
    msg = msgs.join('---COMMA---')

    if (lastMsg.indexOf(' at ') === 0) {
      msg += lastMsg
    } else {
      msg += '---COMMA---' + lastMsg
    }
  } else {
    msg = msgs[0]
  }

  console[type](msg)
}


/***/ }),
/* 8 */
/*!*************************************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/utils/mqttjs3/mqtt.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, wx, __f__) {var require;var require;(function (f) {if (true) {module.exports = f();} else { var g; }})(function () {var define, module, exports;return function () {function r(e, n, t) {function o(i, f) {if (!n[i]) {if (!e[i]) {var c = \"function\" == typeof require && require;if (!f && c) return require(i, !0);if (u) return u(i, !0);var a = new Error(\"Cannot find module '\" + i + \"'\");throw a.code = \"MODULE_NOT_FOUND\", a;}var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {var n = e[i][1][r];return o(n || r);}, p, p.exports, r, e, n, t);}return n[i].exports;}for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {o(t[i]);}return o;}return r;}()({ 1: [function (require, module, exports) {\n      (function (process, global) {\n        'use strict';\n\n        /**\n                       * Module dependencies\n                       */\n        var events = require('events');\n        var Store = require('./store');\n        var mqttPacket = require('mqtt-packet');\n        var Writable = require('readable-stream').Writable;\n        var inherits = require('inherits');\n        var reInterval = require('reinterval');\n        var validations = require('./validations');\n        var xtend = require('xtend');\n        var setImmediate = global.setImmediate || function (callback) {\n          // works in node v0.8\n          process.nextTick(callback);\n        };\n        var defaultConnectOptions = {\n          keepalive: 60,\n          reschedulePings: true,\n          protocolId: 'MQTT',\n          protocolVersion: 4,\n          reconnectPeriod: 1000,\n          connectTimeout: 30 * 1000,\n          clean: true,\n          resubscribe: true };\n\n        var errors = {\n          0: '',\n          1: 'Unacceptable protocol version',\n          2: 'Identifier rejected',\n          3: 'Server unavailable',\n          4: 'Bad username or password',\n          5: 'Not authorized',\n          16: 'No matching subscribers',\n          17: 'No subscription existed',\n          128: 'Unspecified error',\n          129: 'Malformed Packet',\n          130: 'Protocol Error',\n          131: 'Implementation specific error',\n          132: 'Unsupported Protocol Version',\n          133: 'Client Identifier not valid',\n          134: 'Bad User Name or Password',\n          135: 'Not authorized',\n          136: 'Server unavailable',\n          137: 'Server busy',\n          138: 'Banned',\n          139: 'Server shutting down',\n          140: 'Bad authentication method',\n          141: 'Keep Alive timeout',\n          142: 'Session taken over',\n          143: 'Topic Filter invalid',\n          144: 'Topic Name invalid',\n          145: 'Packet identifier in use',\n          146: 'Packet Identifier not found',\n          147: 'Receive Maximum exceeded',\n          148: 'Topic Alias invalid',\n          149: 'Packet too large',\n          150: 'Message rate too high',\n          151: 'Quota exceeded',\n          152: 'Administrative action',\n          153: 'Payload format invalid',\n          154: 'Retain not supported',\n          155: 'QoS not supported',\n          156: 'Use another server',\n          157: 'Server moved',\n          158: 'Shared Subscriptions not supported',\n          159: 'Connection rate exceeded',\n          160: 'Maximum connect time',\n          161: 'Subscription Identifiers not supported',\n          162: 'Wildcard Subscriptions not supported' };\n\n\n        function defaultId() {\n          return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n        }\n\n        function sendPacket(client, packet, cb) {\n          client.emit('packetsend', packet);\n\n          var result = mqttPacket.writeToStream(packet, client.stream, client.options);\n\n          if (!result && cb) {\n            client.stream.once('drain', cb);\n          } else if (cb) {\n            cb();\n          }\n        }\n\n        function flush(queue) {\n          if (queue) {\n            Object.keys(queue).forEach(function (messageId) {\n              if (typeof queue[messageId].cb === 'function') {\n                queue[messageId].cb(new Error('Connection closed'));\n                delete queue[messageId];\n              }\n            });\n          }\n        }\n\n        function flushVolatile(queue) {\n          if (queue) {\n            Object.keys(queue).forEach(function (messageId) {\n              if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n                queue[messageId].cb(new Error('Connection closed'));\n                delete queue[messageId];\n              }\n            });\n          }\n        }\n\n        function storeAndSend(client, packet, cb, cbStorePut) {\n          client.outgoingStore.put(packet, function storedPacket(err) {\n            if (err) {\n              return cb && cb(err);\n            }\n            cbStorePut();\n            sendPacket(client, packet, cb);\n          });\n        }\n\n        function nop() {}\n\n        /**\n                           * MqttClient constructor\n                           *\n                           * @param {Stream} stream - stream\n                           * @param {Object} [options] - connection options\n                           * (see Connection#connect)\n                           */\n        function MqttClient(streamBuilder, options) {\n          var k;\n          var that = this;\n\n          if (!(this instanceof MqttClient)) {\n            return new MqttClient(streamBuilder, options);\n          }\n\n          this.options = options || {};\n\n          // Defaults\n          for (k in defaultConnectOptions) {\n            if (typeof this.options[k] === 'undefined') {\n              this.options[k] = defaultConnectOptions[k];\n            } else {\n              this.options[k] = options[k];\n            }\n          }\n\n          this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n\n          this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {arguments[3](0);};\n\n          this.streamBuilder = streamBuilder;\n\n          // Inflight message storages\n          this.outgoingStore = options.outgoingStore || new Store();\n          this.incomingStore = options.incomingStore || new Store();\n\n          // Should QoS zero messages be queued when the connection is broken?\n          this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero;\n\n          // map of subscribed topics to support reconnection\n          this._resubscribeTopics = {};\n\n          // map of a subscribe messageId and a topic\n          this.messageIdToTopic = {};\n\n          // Ping timer, setup in _setupPingTimer\n          this.pingTimer = null;\n          // Is the client connected?\n          this.connected = false;\n          // Are we disconnecting?\n          this.disconnecting = false;\n          // Packet queue\n          this.queue = [];\n          // connack timer\n          this.connackTimer = null;\n          // Reconnect timer\n          this.reconnectTimer = null;\n          // Is processing store?\n          this._storeProcessing = false;\n          // Packet Ids are put into the store during store processing\n          this._packetIdsDuringStoreProcessing = {};\n          /**\n                                                      * MessageIDs starting with 1\n                                                      * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n                                                      */\n          this.nextId = Math.max(1, Math.floor(Math.random() * 65535));\n\n          // Inflight callbacks\n          this.outgoing = {};\n\n          // True if connection is first time.\n          this._firstConnection = true;\n\n          // Mark disconnected on stream close\n          this.on('close', function () {\n            this.connected = false;\n            clearTimeout(this.connackTimer);\n          });\n\n          // Send queued packets\n          this.on('connect', function () {\n            var queue = this.queue;\n\n            function deliver() {\n              var entry = queue.shift();\n              var packet = null;\n\n              if (!entry) {\n                return;\n              }\n\n              packet = entry.packet;\n\n              that._sendPacket(\n              packet,\n              function (err) {\n                if (entry.cb) {\n                  entry.cb(err);\n                }\n                deliver();\n              });\n\n            }\n\n            deliver();\n          });\n\n          // Clear ping timer\n          this.on('close', function () {\n            if (that.pingTimer !== null) {\n              that.pingTimer.clear();\n              that.pingTimer = null;\n            }\n          });\n\n          // Setup reconnect timer on disconnect\n          this.on('close', this._setupReconnect);\n\n          events.EventEmitter.call(this);\n\n          this._setupStream();\n        }\n        inherits(MqttClient, events.EventEmitter);\n\n        /**\n                                                    * setup the event handlers in the inner stream.\n                                                    *\n                                                    * @api private\n                                                    */\n        MqttClient.prototype._setupStream = function () {\n          var connectPacket;\n          var that = this;\n          var writable = new Writable();\n          var parser = mqttPacket.parser(this.options);\n          var completeParse = null;\n          var packets = [];\n\n          this._clearReconnect();\n\n          this.stream = this.streamBuilder(this);\n\n          parser.on('packet', function (packet) {\n            packets.push(packet);\n          });\n\n          function nextTickWork() {\n            if (packets.length) {\n              process.nextTick(work);\n            } else {\n              var done = completeParse;\n              completeParse = null;\n              done();\n            }\n          }\n\n          function work() {\n            var packet = packets.shift();\n\n            if (packet) {\n              that._handlePacket(packet, nextTickWork);\n            } else {\n              var done = completeParse;\n              completeParse = null;\n              if (done) done();\n            }\n          }\n\n          writable._write = function (buf, enc, done) {\n            completeParse = done;\n            parser.parse(buf);\n            work();\n          };\n\n          this.stream.pipe(writable);\n\n          // Suppress connection errors\n          this.stream.on('error', nop);\n\n          // Echo stream close\n          this.stream.on('close', function () {\n            flushVolatile(that.outgoing);\n            that.emit('close');\n          });\n\n          // Send a connect packet\n          connectPacket = Object.create(this.options);\n          connectPacket.cmd = 'connect';\n          // avoid message queue\n          sendPacket(this, connectPacket);\n\n          // Echo connection errors\n          parser.on('error', this.emit.bind(this, 'error'));\n\n          // auth\n          if (this.options.properties) {\n            if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n              this.emit('error', new Error('Packet has no Authentication Method'));\n              return this;\n            }\n            if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n              var authPacket = xtend({ cmd: 'auth', reasonCode: 0 }, this.options.authPacket);\n              sendPacket(this, authPacket);\n            }\n          }\n\n          // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n          this.stream.setMaxListeners(1000);\n\n          clearTimeout(this.connackTimer);\n          this.connackTimer = setTimeout(function () {\n            that._cleanUp(true);\n          }, this.options.connectTimeout);\n        };\n\n        MqttClient.prototype._handlePacket = function (packet, done) {\n          var options = this.options;\n\n          if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n            this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n            this.end({ reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' } });\n            return this;\n          }\n\n          this.emit('packetreceive', packet);\n\n          switch (packet.cmd) {\n            case 'publish':\n              this._handlePublish(packet, done);\n              break;\n            case 'puback':\n            case 'pubrec':\n            case 'pubcomp':\n            case 'suback':\n            case 'unsuback':\n              this._handleAck(packet);\n              done();\n              break;\n            case 'pubrel':\n              this._handlePubrel(packet, done);\n              break;\n            case 'connack':\n              this._handleConnack(packet);\n              done();\n              break;\n            case 'pingresp':\n              this._handlePingresp(packet);\n              done();\n              break;\n            case 'disconnect':\n              this._handleDisconnect(packet);\n              done();\n              break;\n            default:\n              // do nothing\n              // maybe we should do an error handling\n              // or just log it\n              break;}\n\n        };\n\n        MqttClient.prototype._checkDisconnecting = function (callback) {\n          if (this.disconnecting) {\n            if (callback) {\n              callback(new Error('client disconnecting'));\n            } else {\n              this.emit('error', new Error('client disconnecting'));\n            }\n          }\n          return this.disconnecting;\n        };\n\n        /**\n            * publish - publish <message> to <topic>\n            *\n            * @param {String} topic - topic to publish to\n            * @param {String, Buffer} message - message to publish\n            * @param {Object} [opts] - publish options, includes:\n            *    {Number} qos - qos level to publish on\n            *    {Boolean} retain - whether or not to retain the message\n            *    {Boolean} dup - whether or not mark a message as duplicate\n            *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n            * @param {Function} [callback] - function(err){}\n            *    called when publish succeeds or fails\n            * @returns {MqttClient} this - for chaining\n            * @api public\n            *\n            * @example client.publish('topic', 'message');\n            * @example\n            *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n            * @example client.publish('topic', 'message', console.log);\n            */\n        MqttClient.prototype.publish = function (topic, message, opts, callback) {\n          var packet;\n          var options = this.options;\n\n          // .publish(topic, payload, cb);\n          if (typeof opts === 'function') {\n            callback = opts;\n            opts = null;\n          }\n\n          // default opts\n          var defaultOpts = { qos: 0, retain: false, dup: false };\n          opts = xtend(defaultOpts, opts);\n\n          if (this._checkDisconnecting(callback)) {\n            return this;\n          }\n\n          packet = {\n            cmd: 'publish',\n            topic: topic,\n            payload: message,\n            qos: opts.qos,\n            retain: opts.retain,\n            messageId: this._nextId(),\n            dup: opts.dup };\n\n\n          if (options.protocolVersion === 5) {\n            packet.properties = opts.properties;\n            if (!options.properties && packet.properties && packet.properties.topicAlias || opts.properties && options.properties && (\n            opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum ||\n            !options.properties.topicAliasMaximum && opts.properties.topicAlias)) {\n              /*\n                                                                                   if we are don`t setup topic alias or\n                                                                                   topic alias maximum less than topic alias or\n                                                                                   server don`t give topic alias maximum,\n                                                                                   we are removing topic alias from packet\n                                                                                   */\n              delete packet.properties.topicAlias;\n            }\n          }\n\n          switch (opts.qos) {\n            case 1:\n            case 2:\n              // Add to callbacks\n              this.outgoing[packet.messageId] = {\n                volatile: false,\n                cb: callback || nop };\n\n              if (this._storeProcessing) {\n                this._packetIdsDuringStoreProcessing[packet.messageId] = false;\n                this._storePacket(packet, undefined, opts.cbStorePut);\n              } else {\n                this._sendPacket(packet, undefined, opts.cbStorePut);\n              }\n              break;\n            default:\n              if (this._storeProcessing) {\n                this._storePacket(packet, callback, opts.cbStorePut);\n              } else {\n                this._sendPacket(packet, callback, opts.cbStorePut);\n              }\n              break;}\n\n\n          return this;\n        };\n\n        /**\n            * subscribe - subscribe to <topic>\n            *\n            * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n            * @param {Object} [opts] - optional subscription options, includes:\n            *    {Number} qos - subscribe qos level\n            * @param {Function} [callback] - function(err, granted){} where:\n            *    {Error} err - subscription error (none at the moment!)\n            *    {Array} granted - array of {topic: 't', qos: 0}\n            * @returns {MqttClient} this - for chaining\n            * @api public\n            * @example client.subscribe('topic');\n            * @example client.subscribe('topic', {qos: 1});\n            * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n            * @example client.subscribe('topic', console.log);\n            */\n        MqttClient.prototype.subscribe = function () {\n          var packet;\n          var args = new Array(arguments.length);\n          for (var i = 0; i < arguments.length; i++) {\n            args[i] = arguments[i];\n          }\n          var subs = [];\n          var obj = args.shift();\n          var resubscribe = obj.resubscribe;\n          var callback = args.pop() || nop;\n          var opts = args.pop();\n          var invalidTopic;\n          var that = this;\n          var version = this.options.protocolVersion;\n\n          delete obj.resubscribe;\n\n          if (typeof obj === 'string') {\n            obj = [obj];\n          }\n\n          if (typeof callback !== 'function') {\n            opts = callback;\n            callback = nop;\n          }\n\n          invalidTopic = validations.validateTopics(obj);\n          if (invalidTopic !== null) {\n            setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n            return this;\n          }\n\n          if (this._checkDisconnecting(callback)) {\n            return this;\n          }\n\n          var defaultOpts = {\n            qos: 0 };\n\n          if (version === 5) {\n            defaultOpts.nl = false;\n            defaultOpts.rap = false;\n            defaultOpts.rh = 0;\n          }\n          opts = xtend(defaultOpts, opts);\n\n          if (Array.isArray(obj)) {\n            obj.forEach(function (topic) {\n              if (!that._resubscribeTopics.hasOwnProperty(topic) ||\n              that._resubscribeTopics[topic].qos < opts.qos ||\n              resubscribe) {\n                var currentOpts = {\n                  topic: topic,\n                  qos: opts.qos };\n\n                if (version === 5) {\n                  currentOpts.nl = opts.nl;\n                  currentOpts.rap = opts.rap;\n                  currentOpts.rh = opts.rh;\n                  currentOpts.properties = opts.properties;\n                }\n                subs.push(currentOpts);\n              }\n            });\n          } else {\n            Object.\n            keys(obj).\n            forEach(function (k) {\n              if (!that._resubscribeTopics.hasOwnProperty(k) ||\n              that._resubscribeTopics[k].qos < obj[k].qos ||\n              resubscribe) {\n                var currentOpts = {\n                  topic: k,\n                  qos: obj[k].qos };\n\n                if (version === 5) {\n                  currentOpts.nl = obj[k].nl;\n                  currentOpts.rap = obj[k].rap;\n                  currentOpts.rh = obj[k].rh;\n                  currentOpts.properties = opts.properties;\n                }\n                subs.push(currentOpts);\n              }\n            });\n          }\n\n          packet = {\n            cmd: 'subscribe',\n            subscriptions: subs,\n            qos: 1,\n            retain: false,\n            dup: false,\n            messageId: this._nextId() };\n\n\n          if (opts.properties) {\n            packet.properties = opts.properties;\n          }\n\n          if (!subs.length) {\n            callback(null, []);\n            return;\n          }\n\n          // subscriptions to resubscribe to in case of disconnect\n          if (this.options.resubscribe) {\n            var topics = [];\n            subs.forEach(function (sub) {\n              if (that.options.reconnectPeriod > 0) {\n                var topic = { qos: sub.qos };\n                if (version === 5) {\n                  topic.nl = sub.nl || false;\n                  topic.rap = sub.rap || false;\n                  topic.rh = sub.rh || 0;\n                  topic.properties = sub.properties;\n                }\n                that._resubscribeTopics[sub.topic] = topic;\n                topics.push(sub.topic);\n              }\n            });\n            that.messageIdToTopic[packet.messageId] = topics;\n          }\n\n          this.outgoing[packet.messageId] = {\n            volatile: true,\n            cb: function cb(err, packet) {\n              if (!err) {\n                var granted = packet.granted;\n                for (var i = 0; i < granted.length; i += 1) {\n                  subs[i].qos = granted[i];\n                }\n              }\n\n              callback(err, subs);\n            } };\n\n\n          this._sendPacket(packet);\n\n          return this;\n        };\n\n        /**\n            * unsubscribe - unsubscribe from topic(s)\n            *\n            * @param {String, Array} topic - topics to unsubscribe from\n            * @param {Object} [opts] - optional subscription options, includes:\n            *    {Object} properties - properties of unsubscribe packet\n            * @param {Function} [callback] - callback fired on unsuback\n            * @returns {MqttClient} this - for chaining\n            * @api public\n            * @example client.unsubscribe('topic');\n            * @example client.unsubscribe('topic', console.log);\n            */\n        MqttClient.prototype.unsubscribe = function () {\n          var packet = {\n            cmd: 'unsubscribe',\n            qos: 1,\n            messageId: this._nextId() };\n\n          var that = this;\n          var args = new Array(arguments.length);\n          for (var i = 0; i < arguments.length; i++) {\n            args[i] = arguments[i];\n          }\n          var topic = args.shift();\n          var callback = args.pop() || nop;\n          var opts = args.pop();\n\n          if (typeof topic === 'string') {\n            topic = [topic];\n          }\n\n          if (typeof callback !== 'function') {\n            opts = callback;\n            callback = nop;\n          }\n\n          if (this._checkDisconnecting(callback)) {\n            return this;\n          }\n\n          if (typeof topic === 'string') {\n            packet.unsubscriptions = [topic];\n          } else if (typeof topic === 'object' && topic.length) {\n            packet.unsubscriptions = topic;\n          }\n\n          if (this.options.resubscribe) {\n            packet.unsubscriptions.forEach(function (topic) {\n              delete that._resubscribeTopics[topic];\n            });\n          }\n\n          if (typeof opts === 'object' && opts.properties) {\n            packet.properties = opts.properties;\n          }\n\n          this.outgoing[packet.messageId] = {\n            volatile: true,\n            cb: callback };\n\n\n          this._sendPacket(packet);\n\n          return this;\n        };\n\n        /**\n            * end - close connection\n            *\n            * @returns {MqttClient} this - for chaining\n            * @param {Boolean} force - do not wait for all in-flight messages to be acked\n            * @param {Function} cb - called when the client has been closed\n            *\n            * @api public\n            */\n        MqttClient.prototype.end = function () {\n          var that = this;\n\n          var force = arguments[0];\n          var opts = arguments[1];\n          var cb = arguments[2];\n\n          if (force == null || typeof force !== 'boolean') {\n            cb = opts || nop;\n            opts = force;\n            force = false;\n            if (typeof opts !== 'object') {\n              cb = opts;\n              opts = null;\n              if (typeof cb !== 'function') {\n                cb = nop;\n              }\n            }\n          }\n\n          if (typeof opts !== 'object') {\n            cb = opts;\n            opts = null;\n          }\n\n          cb = cb || nop;\n\n          function closeStores() {\n            that.disconnected = true;\n            that.incomingStore.close(function () {\n              that.outgoingStore.close(function () {\n                if (cb) {\n                  cb.apply(null, arguments);\n                }\n                that.emit('end');\n              });\n            });\n            if (that._deferredReconnect) {\n              that._deferredReconnect();\n            }\n          }\n\n          function finish() {\n            // defer closesStores of an I/O cycle,\n            // just to make sure things are\n            // ok for websockets\n            that._cleanUp(force, setImmediate.bind(null, closeStores), opts);\n          }\n\n          if (this.disconnecting) {\n            return this;\n          }\n\n          this._clearReconnect();\n\n          this.disconnecting = true;\n\n          if (!force && Object.keys(this.outgoing).length > 0) {\n            // wait 10ms, just to be sure we received all of it\n            this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n          } else {\n            finish();\n          }\n\n          return this;\n        };\n\n        /**\n            * removeOutgoingMessage - remove a message in outgoing store\n            * the outgoing callback will be called withe Error('Message removed') if the message is removed\n            *\n            * @param {Number} mid - messageId to remove message\n            * @returns {MqttClient} this - for chaining\n            * @api public\n            *\n            * @example client.removeOutgoingMessage(client.getLastMessageId());\n            */\n        MqttClient.prototype.removeOutgoingMessage = function (mid) {\n          var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null;\n          delete this.outgoing[mid];\n          this.outgoingStore.del({ messageId: mid }, function () {\n            cb(new Error('Message removed'));\n          });\n          return this;\n        };\n\n        /**\n            * reconnect - connect again using the same options as connect()\n            *\n            * @param {Object} [opts] - optional reconnect options, includes:\n            *    {Store} incomingStore - a store for the incoming packets\n            *    {Store} outgoingStore - a store for the outgoing packets\n            *    if opts is not given, current stores are used\n            * @returns {MqttClient} this - for chaining\n            *\n            * @api public\n            */\n        MqttClient.prototype.reconnect = function (opts) {\n          var that = this;\n          var f = function f() {\n            if (opts) {\n              that.options.incomingStore = opts.incomingStore;\n              that.options.outgoingStore = opts.outgoingStore;\n            } else {\n              that.options.incomingStore = null;\n              that.options.outgoingStore = null;\n            }\n            that.incomingStore = that.options.incomingStore || new Store();\n            that.outgoingStore = that.options.outgoingStore || new Store();\n            that.disconnecting = false;\n            that.disconnected = false;\n            that._deferredReconnect = null;\n            that._reconnect();\n          };\n\n          if (this.disconnecting && !this.disconnected) {\n            this._deferredReconnect = f;\n          } else {\n            f();\n          }\n          return this;\n        };\n\n        /**\n            * _reconnect - implement reconnection\n            * @api privateish\n            */\n        MqttClient.prototype._reconnect = function () {\n          this.emit('reconnect');\n          this._setupStream();\n        };\n\n        /**\n            * _setupReconnect - setup reconnect timer\n            */\n        MqttClient.prototype._setupReconnect = function () {\n          var that = this;\n\n          if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n            if (!this.reconnecting) {\n              this.emit('offline');\n              this.reconnecting = true;\n            }\n            that.reconnectTimer = setInterval(function () {\n              that._reconnect();\n            }, that.options.reconnectPeriod);\n          }\n        };\n\n        /**\n            * _clearReconnect - clear the reconnect timer\n            */\n        MqttClient.prototype._clearReconnect = function () {\n          if (this.reconnectTimer) {\n            clearInterval(this.reconnectTimer);\n            this.reconnectTimer = null;\n          }\n        };\n\n        /**\n            * _cleanUp - clean up on connection end\n            * @api private\n            */\n        MqttClient.prototype._cleanUp = function (forced, done) {\n          var opts = arguments[2];\n          if (done) {\n            this.stream.on('close', done);\n          }\n\n          if (forced) {\n            if (this.options.reconnectPeriod === 0 && this.options.clean) {\n              flush(this.outgoing);\n            }\n            this.stream.destroy();\n          } else {\n            var packet = xtend({ cmd: 'disconnect' }, opts);\n            this._sendPacket(\n            packet,\n            setImmediate.bind(\n            null,\n            this.stream.end.bind(this.stream)));\n\n\n          }\n\n          if (!this.disconnecting) {\n            this._clearReconnect();\n            this._setupReconnect();\n          }\n\n          if (this.pingTimer !== null) {\n            this.pingTimer.clear();\n            this.pingTimer = null;\n          }\n\n          if (done && !this.connected) {\n            this.stream.removeListener('close', done);\n            done();\n          }\n        };\n\n        /**\n            * _sendPacket - send or queue a packet\n            * @param {String} type - packet type (see `protocol`)\n            * @param {Object} packet - packet options\n            * @param {Function} cb - callback when the packet is sent\n            * @param {Function} cbStorePut - called when message is put into outgoingStore\n            * @api private\n            */\n        MqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n          cbStorePut = cbStorePut || nop;\n\n          if (!this.connected) {\n            this._storePacket(packet, cb, cbStorePut);\n            return;\n          }\n\n          // When sending a packet, reschedule the ping timer\n          this._shiftPingInterval();\n\n          switch (packet.cmd) {\n            case 'publish':\n              break;\n            case 'pubrel':\n              storeAndSend(this, packet, cb, cbStorePut);\n              return;\n            default:\n              sendPacket(this, packet, cb);\n              return;}\n\n\n          switch (packet.qos) {\n            case 2:\n            case 1:\n              storeAndSend(this, packet, cb, cbStorePut);\n              break;\n            /**\n                      * no need of case here since it will be caught by default\n                      * and jshint comply that before default it must be a break\n                      * anyway it will result in -1 evaluation\n                      */\n            case 0:\n            /* falls through */\n            default:\n              sendPacket(this, packet, cb);\n              break;}\n\n        };\n\n        /**\n            * _storePacket - queue a packet\n            * @param {String} type - packet type (see `protocol`)\n            * @param {Object} packet - packet options\n            * @param {Function} cb - callback when the packet is sent\n            * @param {Function} cbStorePut - called when message is put into outgoingStore\n            * @api private\n            */\n        MqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n          cbStorePut = cbStorePut || nop;\n\n          if ((packet.qos || 0) === 0 && this.queueQoSZero || packet.cmd !== 'publish') {\n            this.queue.push({ packet: packet, cb: cb });\n          } else if (packet.qos > 0) {\n            cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null;\n            this.outgoingStore.put(packet, function (err) {\n              if (err) {\n                return cb && cb(err);\n              }\n              cbStorePut();\n            });\n          } else if (cb) {\n            cb(new Error('No connection to broker'));\n          }\n        };\n\n        /**\n            * _setupPingTimer - setup the ping timer\n            *\n            * @api private\n            */\n        MqttClient.prototype._setupPingTimer = function () {\n          var that = this;\n\n          if (!this.pingTimer && this.options.keepalive) {\n            this.pingResp = true;\n            this.pingTimer = reInterval(function () {\n              that._checkPing();\n            }, this.options.keepalive * 1000);\n          }\n        };\n\n        /**\n            * _shiftPingInterval - reschedule the ping interval\n            *\n            * @api private\n            */\n        MqttClient.prototype._shiftPingInterval = function () {\n          if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n            this.pingTimer.reschedule(this.options.keepalive * 1000);\n          }\n        };\n        /**\n            * _checkPing - check if a pingresp has come back, and ping the server again\n            *\n            * @api private\n            */\n        MqttClient.prototype._checkPing = function () {\n          if (this.pingResp) {\n            this.pingResp = false;\n            this._sendPacket({ cmd: 'pingreq' });\n          } else {\n            // do a forced cleanup since socket will be in bad shape\n            this._cleanUp(true);\n          }\n        };\n\n        /**\n            * _handlePingresp - handle a pingresp\n            *\n            * @api private\n            */\n        MqttClient.prototype._handlePingresp = function () {\n          this.pingResp = true;\n        };\n\n        /**\n            * _handleConnack\n            *\n            * @param {Object} packet\n            * @api private\n            */\n\n        MqttClient.prototype._handleConnack = function (packet) {\n          var options = this.options;\n          var version = options.protocolVersion;\n          var rc = version === 5 ? packet.reasonCode : packet.returnCode;\n\n          clearTimeout(this.connackTimer);\n\n          if (packet.properties) {\n            if (packet.properties.topicAliasMaximum) {\n              if (!options.properties) {options.properties = {};}\n              options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum;\n            }\n            if (packet.properties.serverKeepAlive && options.keepalive) {\n              options.keepalive = packet.properties.serverKeepAlive;\n              this._shiftPingInterval();\n            }\n            if (packet.properties.maximumPacketSize) {\n              if (!options.properties) {options.properties = {};}\n              options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n            }\n          }\n\n          if (rc === 0) {\n            this.reconnecting = false;\n            this._onConnect(packet);\n          } else if (rc > 0) {\n            var err = new Error('Connection refused: ' + errors[rc]);\n            err.code = rc;\n            this.emit('error', err);\n          }\n        };\n\n        /**\n            * _handlePublish\n            *\n            * @param {Object} packet\n            * @api private\n            */\n        /*\n               those late 2 case should be rewrite to comply with coding style:\n               \n               case 1:\n               case 0:\n                 // do not wait sending a puback\n                 // no callback passed\n                 if (1 === qos) {\n                   this._sendPacket({\n                     cmd: 'puback',\n                     messageId: mid\n                   });\n                 }\n                 // emit the message event for both qos 1 and 0\n                 this.emit('message', topic, message, packet);\n                 this.handleMessage(packet, done);\n                 break;\n               default:\n                 // do nothing but every switch mus have a default\n                 // log or throw an error about unknown qos\n                 break;\n               \n               for now i just suppressed the warnings\n               */\n        MqttClient.prototype._handlePublish = function (packet, done) {\n          done = typeof done !== 'undefined' ? done : nop;\n          var topic = packet.topic.toString();\n          var message = packet.payload;\n          var qos = packet.qos;\n          var mid = packet.messageId;\n          var that = this;\n          var options = this.options;\n          var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n\n          switch (qos) {\n            case 2:{\n                options.customHandleAcks(topic, message, packet, function (error, code) {\n                  if (!(error instanceof Error)) {\n                    code = error;\n                    error = null;\n                  }\n                  if (error) {return that.emit('error', error);}\n                  if (validReasonCodes.indexOf(code) === -1) {return that.emit('error', new Error('Wrong reason code for pubrec'));}\n                  if (code) {\n                    that._sendPacket({ cmd: 'pubrec', messageId: mid, reasonCode: code }, done);\n                  } else {\n                    that.incomingStore.put(packet, function () {\n                      that._sendPacket({ cmd: 'pubrec', messageId: mid }, done);\n                    });\n                  }\n                });\n                break;\n              }\n            case 1:{\n                // emit the message event\n                options.customHandleAcks(topic, message, packet, function (error, code) {\n                  if (!(error instanceof Error)) {\n                    code = error;\n                    error = null;\n                  }\n                  if (error) {return that.emit('error', error);}\n                  if (validReasonCodes.indexOf(code) === -1) {return that.emit('error', new Error('Wrong reason code for puback'));}\n                  if (!code) {that.emit('message', topic, message, packet);}\n                  that.handleMessage(packet, function (err) {\n                    if (err) {\n                      return done && done(err);\n                    }\n                    that._sendPacket({ cmd: 'puback', messageId: mid, reasonCode: code }, done);\n                  });\n                });\n                break;\n              }\n            case 0:\n              // emit the message event\n              this.emit('message', topic, message, packet);\n              this.handleMessage(packet, done);\n              break;\n            default:\n              // do nothing\n              // log or throw an error about unknown qos\n              break;}\n\n        };\n\n        /**\n            * Handle messages with backpressure support, one at a time.\n            * Override at will.\n            *\n            * @param Packet packet the packet\n            * @param Function callback call when finished\n            * @api public\n            */\n        MqttClient.prototype.handleMessage = function (packet, callback) {\n          callback();\n        };\n\n        /**\n            * _handleAck\n            *\n            * @param {Object} packet\n            * @api private\n            */\n\n        MqttClient.prototype._handleAck = function (packet) {\n          /* eslint no-fallthrough: \"off\" */\n          var mid = packet.messageId;\n          var type = packet.cmd;\n          var response = null;\n          var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null;\n          var that = this;\n          var err;\n\n          if (!cb) {\n            // Server sent an ack in error, ignore it.\n            return;\n          }\n\n          // Process\n          switch (type) {\n            case 'pubcomp':\n            // same thing as puback for QoS 2\n            case 'puback':\n              var pubackRC = packet.reasonCode;\n              // Callback - we're done\n              if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n                err = new Error('Publish error: ' + errors[pubackRC]);\n                err.code = pubackRC;\n                cb(err, packet);\n              }\n              delete this.outgoing[mid];\n              this.outgoingStore.del(packet, cb);\n              break;\n            case 'pubrec':\n              response = {\n                cmd: 'pubrel',\n                qos: 2,\n                messageId: mid };\n\n              var pubrecRC = packet.reasonCode;\n\n              if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n                err = new Error('Publish error: ' + errors[pubrecRC]);\n                err.code = pubrecRC;\n                cb(err, packet);\n              } else {\n                this._sendPacket(response);\n              }\n              break;\n            case 'suback':\n              delete this.outgoing[mid];\n              for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n                if ((packet.granted[grantedI] & 0x80) !== 0) {\n                  // suback with Failure status\n                  var topics = this.messageIdToTopic[mid];\n                  if (topics) {\n                    topics.forEach(function (topic) {\n                      delete that._resubscribeTopics[topic];\n                    });\n                  }\n                }\n              }\n              cb(null, packet);\n              break;\n            case 'unsuback':\n              delete this.outgoing[mid];\n              cb(null);\n              break;\n            default:\n              that.emit('error', new Error('unrecognized packet type'));}\n\n\n          if (this.disconnecting &&\n          Object.keys(this.outgoing).length === 0) {\n            this.emit('outgoingEmpty');\n          }\n        };\n\n        /**\n            * _handlePubrel\n            *\n            * @param {Object} packet\n            * @api private\n            */\n        MqttClient.prototype._handlePubrel = function (packet, callback) {\n          callback = typeof callback !== 'undefined' ? callback : nop;\n          var mid = packet.messageId;\n          var that = this;\n\n          var comp = { cmd: 'pubcomp', messageId: mid };\n\n          that.incomingStore.get(packet, function (err, pub) {\n            if (!err) {\n              that.emit('message', pub.topic, pub.payload, pub);\n              that.handleMessage(pub, function (err) {\n                if (err) {\n                  return callback(err);\n                }\n                that.incomingStore.del(pub, nop);\n                that._sendPacket(comp, callback);\n              });\n            } else {\n              that._sendPacket(comp, callback);\n            }\n          });\n        };\n\n        /**\n            * _handleDisconnect\n            *\n            * @param {Object} packet\n            * @api private\n            */\n        MqttClient.prototype._handleDisconnect = function (packet) {\n          this.emit('disconnect', packet);\n        };\n\n        /**\n            * _nextId\n            * @return unsigned int\n            */\n        MqttClient.prototype._nextId = function () {\n          // id becomes current state of this.nextId and increments afterwards\n          var id = this.nextId++;\n          // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n          if (this.nextId === 65536) {\n            this.nextId = 1;\n          }\n          return id;\n        };\n\n        /**\n            * getLastMessageId\n            * @return unsigned int\n            */\n        MqttClient.prototype.getLastMessageId = function () {\n          return this.nextId === 1 ? 65535 : this.nextId - 1;\n        };\n\n        /**\n            * _resubscribe\n            * @api private\n            */\n        MqttClient.prototype._resubscribe = function (connack) {\n          var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n          if (!this._firstConnection && (\n          this.options.clean || this.options.protocolVersion === 5 && !connack.sessionPresent) &&\n          _resubscribeTopicsKeys.length > 0) {\n            if (this.options.resubscribe) {\n              if (this.options.protocolVersion === 5) {\n                for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n                  var resubscribeTopic = {};\n                  resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n                  resubscribeTopic.resubscribe = true;\n                  this.subscribe(resubscribeTopic, { properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties });\n                }\n              } else {\n                this._resubscribeTopics.resubscribe = true;\n                this.subscribe(this._resubscribeTopics);\n              }\n            } else {\n              this._resubscribeTopics = {};\n            }\n          }\n\n          this._firstConnection = false;\n        };\n\n        /**\n            * _onConnect\n            *\n            * @api private\n            */\n        MqttClient.prototype._onConnect = function (packet) {\n          if (this.disconnected) {\n            this.emit('connect', packet);\n            return;\n          }\n\n          var that = this;\n\n          this._setupPingTimer();\n          this._resubscribe(packet);\n\n          this.connected = true;\n\n          function startStreamProcess() {\n            var outStore = that.outgoingStore.createStream();\n\n            function clearStoreProcessing() {\n              that._storeProcessing = false;\n              that._packetIdsDuringStoreProcessing = {};\n            }\n\n            that.once('close', remove);\n            outStore.on('error', function (err) {\n              clearStoreProcessing();\n              that.removeListener('close', remove);\n              that.emit('error', err);\n            });\n\n            function remove() {\n              outStore.destroy();\n              outStore = null;\n              clearStoreProcessing();\n            }\n\n            function storeDeliver() {\n              // edge case, we wrapped this twice\n              if (!outStore) {\n                return;\n              }\n              that._storeProcessing = true;\n\n              var packet = outStore.read(1);\n\n              var _cb;\n\n              if (!packet) {\n                // read when data is available in the future\n                outStore.once('readable', storeDeliver);\n                return;\n              }\n\n              // Skip already processed store packets\n              if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n                storeDeliver();\n                return;\n              }\n\n              // Avoid unnecessary stream read operations when disconnected\n              if (!that.disconnecting && !that.reconnectTimer) {\n                _cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n                that.outgoing[packet.messageId] = {\n                  volatile: false,\n                  cb: function cb(err, status) {\n                    // Ensure that the original callback passed in to publish gets invoked\n                    if (_cb) {\n                      _cb(err, status);\n                    }\n\n                    storeDeliver();\n                  } };\n\n                that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n                that._sendPacket(packet);\n              } else if (outStore.destroy) {\n                outStore.destroy();\n              }\n            }\n\n            outStore.on('end', function () {\n              var allProcessed = true;\n              for (var id in that._packetIdsDuringStoreProcessing) {\n                if (!that._packetIdsDuringStoreProcessing[id]) {\n                  allProcessed = false;\n                  break;\n                }\n              }\n              if (allProcessed) {\n                clearStoreProcessing();\n                that.removeListener('close', remove);\n                that.emit('connect', packet);\n              } else {\n                startStreamProcess();\n              }\n            });\n            storeDeliver();\n          }\n          // start flowing\n          startStreamProcess();\n        };\n\n        module.exports = MqttClient;\n\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, { \"./store\": 7, \"./validations\": 8, \"_process\": 92, \"events\": 13, \"inherits\": 80, \"mqtt-packet\": 84, \"readable-stream\": 108, \"reinterval\": 109, \"xtend\": 121 }], 2: [function (require, module, exports) {\n      (function (Buffer) {\n        'use strict';\n\n        var Transform = require('readable-stream').Transform;\n        var duplexify = require('duplexify');\n        var base64 = require('base64-js');\n\n        /* global FileReader */\n        var my;\n        var proxy;\n        var stream;\n        var isInitialized = false;\n\n        function buildProxy() {\n          var proxy = new Transform();\n          proxy._write = function (chunk, encoding, next) {\n            my.sendSocketMessage({\n              data: chunk.buffer,\n              success: function success() {\n                next();\n              },\n              fail: function fail() {\n                next(new Error());\n              } });\n\n          };\n          proxy._flush = function socketEnd(done) {\n            my.closeSocket({\n              success: function success() {\n                done();\n              } });\n\n          };\n\n          return proxy;\n        }\n\n        function setDefaultOpts(opts) {\n          if (!opts.hostname) {\n            opts.hostname = 'localhost';\n          }\n          if (!opts.path) {\n            opts.path = '/';\n          }\n\n          if (!opts.wsOptions) {\n            opts.wsOptions = {};\n          }\n        }\n\n        function buildUrl(opts, client) {\n          var protocol = opts.protocol === 'alis' ? 'wss' : 'ws';\n          var url = protocol + '://' + opts.hostname + opts.path;\n          if (opts.port && opts.port !== 80 && opts.port !== 443) {\n            url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n          }\n          if (typeof opts.transformWsUrl === 'function') {\n            url = opts.transformWsUrl(url, opts, client);\n          }\n          return url;\n        }\n\n        function bindEventHandler() {\n          if (isInitialized) return;\n\n          isInitialized = true;\n\n          my.onSocketOpen(function () {\n            stream.setReadable(proxy);\n            stream.setWritable(proxy);\n            stream.emit('connect');\n          });\n\n          my.onSocketMessage(function (res) {\n            if (typeof res.data === 'string') {\n              var array = base64.toByteArray(res.data);\n              var buffer = Buffer.from(array);\n              proxy.push(buffer);\n            } else {\n              var reader = new FileReader();\n              reader.addEventListener('load', function () {\n                var data = reader.result;\n\n                if (data instanceof ArrayBuffer) data = Buffer.from(data);else\n                data = Buffer.from(data, 'utf8');\n                proxy.push(data);\n              });\n              reader.readAsArrayBuffer(res.data);\n            }\n          });\n\n          my.onSocketClose(function () {\n            stream.end();\n            stream.destroy();\n          });\n\n          my.onSocketError(function (res) {\n            stream.destroy(res);\n          });\n        }\n\n        function buildStream(client, opts) {\n          opts.hostname = opts.hostname || opts.host;\n\n          if (!opts.hostname) {\n            throw new Error('Could not determine host. Specify host manually.');\n          }\n\n          var websocketSubProtocol =\n          opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ?\n          'mqttv3.1' :\n          'mqtt';\n\n          setDefaultOpts(opts);\n\n          var url = buildUrl(opts, client);\n          my = opts.my;\n          my.connectSocket({\n            url: url,\n            protocols: websocketSubProtocol });\n\n\n          proxy = buildProxy();\n          stream = duplexify.obj();\n\n          bindEventHandler();\n\n          return stream;\n        }\n\n        module.exports = buildStream;\n\n      }).call(this, require(\"buffer\").Buffer);\n    }, { \"base64-js\": 10, \"buffer\": 12, \"duplexify\": 17, \"readable-stream\": 108 }], 3: [function (require, module, exports) {\n      'use strict';\n      var net = require('net');\n\n      /*\n                                  variables port and host can be removed since\n                                  you have all required information in opts object\n                                */\n      function buildBuilder(client, opts) {\n        var port, host;\n        opts.port = opts.port || 1883;\n        opts.hostname = opts.hostname || opts.host || 'localhost';\n\n        port = opts.port;\n        host = opts.hostname;\n\n        return net.createConnection(port, host);\n      }\n\n      module.exports = buildBuilder;\n\n    }, { \"net\": 11 }], 4: [function (require, module, exports) {\n      'use strict';\n      var tls = require('tls');\n\n      function buildBuilder(mqttClient, opts) {\n        var connection;\n        opts.port = opts.port || 8883;\n        opts.host = opts.hostname || opts.host || 'localhost';\n\n        opts.rejectUnauthorized = opts.rejectUnauthorized !== false;\n\n        delete opts.path;\n\n        connection = tls.connect(opts);\n        /* eslint no-use-before-define: [2, \"nofunc\"] */\n        connection.on('secureConnect', function () {\n          if (opts.rejectUnauthorized && !connection.authorized) {\n            connection.emit('error', new Error('TLS not authorized'));\n          } else {\n            connection.removeListener('error', handleTLSerrors);\n          }\n        });\n\n        function handleTLSerrors(err) {\n          // How can I get verify this error is a tls error?\n          if (opts.rejectUnauthorized) {\n            mqttClient.emit('error', err);\n          }\n\n          // close this connection to match the behaviour of net\n          // otherwise all we get is an error from the connection\n          // and close event doesn't fire. This is a work around\n          // to enable the reconnect code to work the same as with\n          // net.createConnection\n          connection.end();\n        }\n\n        connection.on('error', handleTLSerrors);\n        return connection;\n      }\n\n      module.exports = buildBuilder;\n\n    }, { \"tls\": 11 }], 5: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        var websocket = require('websocket-stream');\n        var urlModule = require('url');\n        var WSS_OPTIONS = [\n        'rejectUnauthorized',\n        'ca',\n        'cert',\n        'key',\n        'pfx',\n        'passphrase'];\n\n        var IS_BROWSER = process.title === 'browser';\n\n        function buildUrl(opts, client) {\n          var url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n          if (typeof opts.transformWsUrl === 'function') {\n            url = opts.transformWsUrl(url, opts, client);\n          }\n          return url;\n        }\n\n        function setDefaultOpts(opts) {\n          if (!opts.hostname) {\n            opts.hostname = 'localhost';\n          }\n          if (!opts.port) {\n            if (opts.protocol === 'wss') {\n              opts.port = 443;\n            } else {\n              opts.port = 80;\n            }\n          }\n          if (!opts.path) {\n            opts.path = '/';\n          }\n\n          if (!opts.wsOptions) {\n            opts.wsOptions = {};\n          }\n          if (!IS_BROWSER && opts.protocol === 'wss') {\n            // Add cert/key/ca etc options\n            WSS_OPTIONS.forEach(function (prop) {\n              if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {\n                opts.wsOptions[prop] = opts[prop];\n              }\n            });\n          }\n        }\n\n        function createWebSocket(client, opts) {\n          var websocketSubProtocol =\n          opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ?\n          'mqttv3.1' :\n          'mqtt';\n\n          setDefaultOpts(opts);\n          var url = buildUrl(opts, client);\n          return websocket(url, [websocketSubProtocol], opts.wsOptions);\n        }\n\n        function buildBuilder(client, opts) {\n          return createWebSocket(client, opts);\n        }\n\n        function buildBuilderBrowser(client, opts) {\n          if (!opts.hostname) {\n            opts.hostname = opts.host;\n          }\n\n          if (!opts.hostname) {\n            // Throwing an error in a Web Worker if no `hostname` is given, because we\n            // can not determine the `hostname` automatically.  If connecting to\n            // localhost, please supply the `hostname` as an argument.\n            if (typeof document === 'undefined') {\n              throw new Error('Could not determine host. Specify host manually.');\n            }\n            var parsed = urlModule.parse(document.URL);\n            opts.hostname = parsed.hostname;\n\n            if (!opts.port) {\n              opts.port = parsed.port;\n            }\n          }\n          return createWebSocket(client, opts);\n        }\n\n        if (IS_BROWSER) {\n          module.exports = buildBuilderBrowser;\n        } else {\n          module.exports = buildBuilder;\n        }\n\n      }).call(this, require('_process'));\n    }, { \"_process\": 92, \"url\": 113, \"websocket-stream\": 118 }], 6: [function (require, module, exports) {\n      (function (process, Buffer) {\n        'use strict';\n\n        var Transform = require('readable-stream').Transform;\n        var duplexify = require('duplexify');\n\n        /* global wx */\n        var socketTask;\n        var proxy;\n        var stream;\n\n        function buildProxy() {\n          var proxy = new Transform();\n          proxy._write = function (chunk, encoding, next) {\n            socketTask.send({\n              data: chunk.buffer,\n              success: function success() {\n                next();\n              },\n              fail: function fail(errMsg) {\n                next(new Error(errMsg));\n              } });\n\n          };\n          proxy._flush = function socketEnd(done) {\n            socketTask.close({\n              success: function success() {\n                done();\n              } });\n\n          };\n\n          return proxy;\n        }\n\n        function setDefaultOpts(opts) {\n          if (!opts.hostname) {\n            opts.hostname = 'localhost';\n          }\n          if (!opts.path) {\n            opts.path = '/';\n          }\n\n          if (!opts.wsOptions) {\n            opts.wsOptions = {};\n          }\n        }\n\n        function buildUrl(opts, client) {\n          var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws';\n          var url = protocol + '://' + opts.hostname + opts.path;\n          if (opts.port && opts.port !== 80 && opts.port !== 443) {\n            url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n          }\n          if (typeof opts.transformWsUrl === 'function') {\n            url = opts.transformWsUrl(url, opts, client);\n          }\n          return url;\n        }\n\n        function bindEventHandler() {\n          socketTask.onOpen(function () {\n            stream.setReadable(proxy);\n            stream.setWritable(proxy);\n            stream.emit('connect');\n          });\n\n          socketTask.onMessage(function (res) {\n            var data = res.data;\n\n            if (data instanceof ArrayBuffer) data = Buffer.from(data);else\n            data = Buffer.from(data, 'utf8');\n            proxy.push(data);\n          });\n\n          socketTask.onClose(function () {\n            stream.end();\n            stream.destroy();\n          });\n\n          socketTask.onError(function (res) {\n            stream.destroy(new Error(res.errMsg));\n          });\n        }\n\n        function buildStream(client, opts) {\n          opts.hostname = opts.hostname || opts.host;\n\n          if (!opts.hostname) {\n            throw new Error('Could not determine host. Specify host manually.');\n          }\n\n          var websocketSubProtocol =\n          opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ?\n          'mqttv3.1' :\n          'mqtt';\n\n          setDefaultOpts(opts);\n\n          var url = buildUrl(opts, client);\n          socketTask = wx.connectSocket({\n            url: url,\n            protocols: websocketSubProtocol });\n\n\n          proxy = buildProxy();\n          stream = duplexify.obj();\n          stream._destroy = function (err, cb) {\n            socketTask.close({\n              success: function success() {\n                cb && cb(err);\n              } });\n\n          };\n\n          var destroyRef = stream.destroy;\n          stream.destroy = function () {\n            stream.destroy = destroyRef;\n\n            var self = this;\n            process.nextTick(function () {\n              socketTask.close({\n                fail: function fail() {\n                  self._destroy(new Error());\n                } });\n\n            });\n          }.bind(stream);\n\n          bindEventHandler();\n\n          return stream;\n        }\n\n        module.exports = buildStream;\n\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, { \"_process\": 92, \"buffer\": 12, \"duplexify\": 17, \"readable-stream\": 108 }], 7: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        /**\n                       * Module dependencies\n                       */\n        var xtend = require('xtend');\n\n        var Readable = require('readable-stream').Readable;\n        var streamsOpts = { objectMode: true };\n        var defaultStoreOptions = {\n          clean: true };\n\n\n        /**\n                          * es6-map can preserve insertion order even if ES version is older.\n                          *\n                          * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Description\n                          * It should be noted that a Map which is a map of an object, especially\n                          * a dictionary of dictionaries, will only map to the object's insertion\n                          * order. In ES2015 this is ordered for objects but for older versions of\n                          * ES, this may be random and not ordered.\n                          *\n                          */\n        var Map = require('es6-map');\n\n        /**\n                                       * In-memory implementation of the message store\n                                       * This can actually be saved into files.\n                                       *\n                                       * @param {Object} [options] - store options\n                                       */\n        function Store(options) {\n          if (!(this instanceof Store)) {\n            return new Store(options);\n          }\n\n          this.options = options || {};\n\n          // Defaults\n          this.options = xtend(defaultStoreOptions, options);\n\n          this._inflights = new Map();\n        }\n\n        /**\n           * Adds a packet to the store, a packet is\n           * anything that has a messageId property.\n           *\n           */\n        Store.prototype.put = function (packet, cb) {\n          this._inflights.set(packet.messageId, packet);\n\n          if (cb) {\n            cb();\n          }\n\n          return this;\n        };\n\n        /**\n            * Creates a stream with all the packets in the store\n            *\n            */\n        Store.prototype.createStream = function () {\n          var stream = new Readable(streamsOpts);\n          var destroyed = false;\n          var values = [];\n          var i = 0;\n\n          this._inflights.forEach(function (value, key) {\n            values.push(value);\n          });\n\n          stream._read = function () {\n            if (!destroyed && i < values.length) {\n              this.push(values[i++]);\n            } else {\n              this.push(null);\n            }\n          };\n\n          stream.destroy = function () {\n            if (destroyed) {\n              return;\n            }\n\n            var self = this;\n\n            destroyed = true;\n\n            process.nextTick(function () {\n              self.emit('close');\n            });\n          };\n\n          return stream;\n        };\n\n        /**\n            * deletes a packet from the store.\n            */\n        Store.prototype.del = function (packet, cb) {\n          packet = this._inflights.get(packet.messageId);\n          if (packet) {\n            this._inflights.delete(packet.messageId);\n            cb(null, packet);\n          } else if (cb) {\n            cb(new Error('missing packet'));\n          }\n\n          return this;\n        };\n\n        /**\n            * get a packet from the store.\n            */\n        Store.prototype.get = function (packet, cb) {\n          packet = this._inflights.get(packet.messageId);\n          if (packet) {\n            cb(null, packet);\n          } else if (cb) {\n            cb(new Error('missing packet'));\n          }\n\n          return this;\n        };\n\n        /**\n            * Close the store\n            */\n        Store.prototype.close = function (cb) {\n          if (this.options.clean) {\n            this._inflights = null;\n          }\n          if (cb) {\n            cb();\n          }\n        };\n\n        module.exports = Store;\n\n      }).call(this, require('_process'));\n    }, { \"_process\": 92, \"es6-map\": 67, \"readable-stream\": 108, \"xtend\": 121 }], 8: [function (require, module, exports) {\n      'use strict';\n\n      /**\n                     * Validate a topic to see if it's valid or not.\n                     * A topic is valid if it follow below rules:\n                     * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'\n                     * - Rule #2: Part `#` must be located at the end of the mailbox\n                     *\n                     * @param {String} topic - A topic\n                     * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.\n                     */\n      function validateTopic(topic) {\n        var parts = topic.split('/');\n\n        for (var i = 0; i < parts.length; i++) {\n          if (parts[i] === '+') {\n            continue;\n          }\n\n          if (parts[i] === '#') {\n            // for Rule #2\n            return i === parts.length - 1;\n          }\n\n          if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      /**\n         * Validate an array of topics to see if any of them is valid or not\n          * @param {Array} topics - Array of topics\n         * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one\n         */\n      function validateTopics(topics) {\n        if (topics.length === 0) {\n          return 'empty_topic_list';\n        }\n        for (var i = 0; i < topics.length; i++) {\n          if (!validateTopic(topics[i])) {\n            return topics[i];\n          }\n        }\n        return null;\n      }\n\n      module.exports = {\n        validateTopics: validateTopics };\n\n\n    }, {}], 9: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        var MqttClient = require('../client');\n        var Store = require('../store');\n        var url = require('url');\n        var xtend = require('xtend');\n        var protocols = {};\n\n        if (process.title !== 'browser') {\n          protocols.mqtt = require('./tcp');\n          protocols.tcp = require('./tcp');\n          protocols.ssl = require('./tls');\n          protocols.tls = require('./tls');\n          protocols.mqtts = require('./tls');\n        } else {\n          protocols.wx = require('./wx');\n          protocols.wxs = require('./wx');\n\n          protocols.ali = require('./ali');\n          protocols.alis = require('./ali');\n        }\n\n        protocols.ws = require('./ws');\n        protocols.wss = require('./ws');\n\n        /**\n                                          * Parse the auth attribute and merge username and password in the options object.\n                                          *\n                                          * @param {Object} [opts] option object\n                                          */\n        function parseAuthOptions(opts) {\n          var matches;\n          if (opts.auth) {\n            matches = opts.auth.match(/^(.+):(.+)$/);\n            if (matches) {\n              opts.username = matches[1];\n              opts.password = matches[2];\n            } else {\n              opts.username = opts.auth;\n            }\n          }\n        }\n\n        /**\n           * connect - connect to an MQTT broker.\n           *\n           * @param {String} [brokerUrl] - url of the broker, optional\n           * @param {Object} opts - see MqttClient#constructor\n           */\n        function connect(brokerUrl, opts) {\n          if (typeof brokerUrl === 'object' && !opts) {\n            opts = brokerUrl;\n            brokerUrl = null;\n          }\n\n          opts = opts || {};\n\n          if (brokerUrl) {\n            var parsed = url.parse(brokerUrl, true);\n            if (parsed.port != null) {\n              parsed.port = Number(parsed.port);\n            }\n\n            opts = xtend(parsed, opts);\n\n            if (opts.protocol === null) {\n              throw new Error('Missing protocol');\n            }\n            opts.protocol = opts.protocol.replace(/:$/, '');\n          }\n\n          // merge in the auth options if supplied\n          parseAuthOptions(opts);\n\n          // support clientId passed in the query string of the url\n          if (opts.query && typeof opts.query.clientId === 'string') {\n            opts.clientId = opts.query.clientId;\n          }\n\n          if (opts.cert && opts.key) {\n            if (opts.protocol) {\n              if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n                switch (opts.protocol) {\n                  case 'mqtt':\n                    opts.protocol = 'mqtts';\n                    break;\n                  case 'ws':\n                    opts.protocol = 'wss';\n                    break;\n                  case 'wx':\n                    opts.protocol = 'wxs';\n                    break;\n                  case 'ali':\n                    opts.protocol = 'alis';\n                    break;\n                  default:\n                    throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!');}\n\n              }\n            } else {\n              // don't know what protocol he want to use, mqtts or wss\n              throw new Error('Missing secure protocol key');\n            }\n          }\n\n          if (!protocols[opts.protocol]) {\n            var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;\n            opts.protocol = [\n            'mqtt',\n            'mqtts',\n            'ws',\n            'wss',\n            'wx',\n            'wxs',\n            'ali',\n            'alis'].\n            filter(function (key, index) {\n              if (isSecure && index % 2 === 0) {\n                // Skip insecure protocols when requesting a secure one.\n                return false;\n              }\n              return typeof protocols[key] === 'function';\n            })[0];\n          }\n\n          if (opts.clean === false && !opts.clientId) {\n            throw new Error('Missing clientId for unclean clients');\n          }\n\n          if (opts.protocol) {\n            opts.defaultProtocol = opts.protocol;\n          }\n\n          function wrapper(client) {\n            if (opts.servers) {\n              if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n                client._reconnectCount = 0;\n              }\n\n              opts.host = opts.servers[client._reconnectCount].host;\n              opts.port = opts.servers[client._reconnectCount].port;\n              opts.protocol = !opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol;\n              opts.hostname = opts.host;\n\n              client._reconnectCount++;\n            }\n\n            return protocols[opts.protocol](client, opts);\n          }\n\n          return new MqttClient(wrapper, opts);\n        }\n\n        module.exports = connect;\n        module.exports.connect = connect;\n        module.exports.MqttClient = MqttClient;\n        module.exports.Store = Store;\n\n      }).call(this, require('_process'));\n    }, { \"../client\": 1, \"../store\": 7, \"./ali\": 2, \"./tcp\": 3, \"./tls\": 4, \"./ws\": 5, \"./wx\": 6, \"_process\": 92, \"url\": 113, \"xtend\": 121 }], 10: [function (require, module, exports) {\n      'use strict';\n\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\n      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n      for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n\n      // Support decoding URL-safe base64 strings, as Node.js does.\n      // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n      revLookup['-'.charCodeAt(0)] = 62;\n      revLookup['_'.charCodeAt(0)] = 63;\n\n      function getLens(b64) {\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n\n        // Trim off extra bytes after placeholder bytes are found\n        // See: https://github.com/beatgammit/base64-js/issues/42\n        var validLen = b64.indexOf('=');\n        if (validLen === -1) validLen = len;\n\n        var placeHoldersLen = validLen === len ?\n        0 :\n        4 - validLen % 4;\n\n        return [validLen, placeHoldersLen];\n      }\n\n      // base64 is 4/3 + up to two characters of the original data\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n        var curByte = 0;\n\n        // if there are placeholders, only get up to the last complete 4 chars\n        var len = placeHoldersLen > 0 ?\n        validLen - 4 :\n        validLen;\n\n        for (var i = 0; i < len; i += 4) {\n          tmp =\n          revLookup[b64.charCodeAt(i)] << 18 |\n          revLookup[b64.charCodeAt(i + 1)] << 12 |\n          revLookup[b64.charCodeAt(i + 2)] << 6 |\n          revLookup[b64.charCodeAt(i + 3)];\n          arr[curByte++] = tmp >> 16 & 0xFF;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 2) {\n          tmp =\n          revLookup[b64.charCodeAt(i)] << 2 |\n          revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 1) {\n          tmp =\n          revLookup[b64.charCodeAt(i)] << 10 |\n          revLookup[b64.charCodeAt(i + 1)] << 4 |\n          revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        return arr;\n      }\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3F] +\n        lookup[num >> 12 & 0x3F] +\n        lookup[num >> 6 & 0x3F] +\n        lookup[num & 0x3F];\n      }\n\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i = start; i < end; i += 3) {\n          tmp =\n          (uint8[i] << 16 & 0xFF0000) + (\n          uint8[i + 1] << 8 & 0xFF00) + (\n          uint8[i + 2] & 0xFF);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join('');\n      }\n\n      function fromByteArray(uint8) {\n        var tmp;\n        var len = uint8.length;\n        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        var parts = [];\n        var maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n          parts.push(encodeChunk(\n          uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n          tmp = uint8[len - 1];\n          parts.push(\n          lookup[tmp >> 2] +\n          lookup[tmp << 4 & 0x3F] +\n          '==');\n\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n          parts.push(\n          lookup[tmp >> 10] +\n          lookup[tmp >> 4 & 0x3F] +\n          lookup[tmp << 2 & 0x3F] +\n          '=');\n\n        }\n\n        return parts.join('');\n      }\n\n    }, {}], 11: [function (require, module, exports) {\n\n    }, {}], 12: [function (require, module, exports) {\n      /*!\n                                                       * The buffer module from node.js, for the browser.\n                                                       *\n                                                       * @author   Feross Aboukhadijeh <https://feross.org>\n                                                       * @license  MIT\n                                                       */\n      /* eslint-disable no-proto */\n\n      'use strict';\n\n      var base64 = require('base64-js');\n      var ieee754 = require('ieee754');\n\n      exports.Buffer = Buffer;\n      exports.SlowBuffer = SlowBuffer;\n      exports.INSPECT_MAX_BYTES = 50;\n\n      var K_MAX_LENGTH = 0x7fffffff;\n      exports.kMaxLength = K_MAX_LENGTH;\n\n      /**\n                                          * If `Buffer.TYPED_ARRAY_SUPPORT`:\n                                          *   === true    Use Uint8Array implementation (fastest)\n                                          *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n                                          *               implementation (most compatible, even IE6)\n                                          *\n                                          * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n                                          * Opera 11.6+, iOS 4.2+.\n                                          *\n                                          * We report that the browser does not support typed arrays if the are not subclassable\n                                          * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n                                          * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n                                          * for __proto__ and has a buggy typed array implementation.\n                                          */\n      Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n      if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n      typeof console.error === 'function') {\n        __f__(\"error\",\n        'This browser lacks typed array (Uint8Array) support which is required by ' +\n        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.', \" at utils/mqttjs3/mqtt.js:2450\");\n\n      }\n\n      function typedArraySupport() {\n        // Can typed array instances can be augmented?\n        try {\n          var arr = new Uint8Array(1);\n          arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {return 42;} };\n          return arr.foo() === 42;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      Object.defineProperty(Buffer.prototype, 'parent', {\n        enumerable: true,\n        get: function get() {\n          if (!Buffer.isBuffer(this)) return undefined;\n          return this.buffer;\n        } });\n\n\n      Object.defineProperty(Buffer.prototype, 'offset', {\n        enumerable: true,\n        get: function get() {\n          if (!Buffer.isBuffer(this)) return undefined;\n          return this.byteOffset;\n        } });\n\n\n      function createBuffer(length) {\n        if (length > K_MAX_LENGTH) {\n          throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n        }\n        // Return an augmented `Uint8Array` instance\n        var buf = new Uint8Array(length);\n        buf.__proto__ = Buffer.prototype;\n        return buf;\n      }\n\n      /**\n         * The Buffer constructor returns instances of `Uint8Array` that have their\n         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n         * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n         * returns a single octet.\n         *\n         * The `Uint8Array` prototype remains unmodified.\n         */\n\n      function Buffer(arg, encodingOrOffset, length) {\n        // Common case.\n        if (typeof arg === 'number') {\n          if (typeof encodingOrOffset === 'string') {\n            throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number');\n\n          }\n          return allocUnsafe(arg);\n        }\n        return from(arg, encodingOrOffset, length);\n      }\n\n      // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n      if (typeof Symbol !== 'undefined' && Symbol.species != null &&\n      Buffer[Symbol.species] === Buffer) {\n        Object.defineProperty(Buffer, Symbol.species, {\n          value: null,\n          configurable: true,\n          enumerable: false,\n          writable: false });\n\n      }\n\n      Buffer.poolSize = 8192; // not used by this implementation\n\n      function from(value, encodingOrOffset, length) {\n        if (typeof value === 'string') {\n          return fromString(value, encodingOrOffset);\n        }\n\n        if (ArrayBuffer.isView(value)) {\n          return fromArrayLike(value);\n        }\n\n        if (value == null) {\n          throw TypeError(\n          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n          'or Array-like Object. Received type ' + typeof value);\n\n        }\n\n        if (isInstance(value, ArrayBuffer) ||\n        value && isInstance(value.buffer, ArrayBuffer)) {\n          return fromArrayBuffer(value, encodingOrOffset, length);\n        }\n\n        if (typeof value === 'number') {\n          throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number');\n\n        }\n\n        var valueOf = value.valueOf && value.valueOf();\n        if (valueOf != null && valueOf !== value) {\n          return Buffer.from(valueOf, encodingOrOffset, length);\n        }\n\n        var b = fromObject(value);\n        if (b) return b;\n\n        if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n        typeof value[Symbol.toPrimitive] === 'function') {\n          return Buffer.from(\n          value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n\n        }\n\n        throw new TypeError(\n        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n        'or Array-like Object. Received type ' + typeof value);\n\n      }\n\n      /**\n         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n         * if value is a number.\n         * Buffer.from(str[, encoding])\n         * Buffer.from(array)\n         * Buffer.from(buffer)\n         * Buffer.from(arrayBuffer[, byteOffset[, length]])\n         **/\n      Buffer.from = function (value, encodingOrOffset, length) {\n        return from(value, encodingOrOffset, length);\n      };\n\n      // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n      // https://github.com/feross/buffer/pull/148\n      Buffer.prototype.__proto__ = Uint8Array.prototype;\n      Buffer.__proto__ = Uint8Array;\n\n      function assertSize(size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('\"size\" argument must be of type number');\n        } else if (size < 0) {\n          throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n        }\n      }\n\n      function alloc(size, fill, encoding) {\n        assertSize(size);\n        if (size <= 0) {\n          return createBuffer(size);\n        }\n        if (fill !== undefined) {\n          // Only pay attention to encoding if it's a string. This\n          // prevents accidentally sending in a number that would\n          // be interpretted as a start offset.\n          return typeof encoding === 'string' ?\n          createBuffer(size).fill(fill, encoding) :\n          createBuffer(size).fill(fill);\n        }\n        return createBuffer(size);\n      }\n\n      /**\n         * Creates a new filled Buffer instance.\n         * alloc(size[, fill[, encoding]])\n         **/\n      Buffer.alloc = function (size, fill, encoding) {\n        return alloc(size, fill, encoding);\n      };\n\n      function allocUnsafe(size) {\n        assertSize(size);\n        return createBuffer(size < 0 ? 0 : checked(size) | 0);\n      }\n\n      /**\n         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n         * */\n      Buffer.allocUnsafe = function (size) {\n        return allocUnsafe(size);\n      };\n      /**\n          * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n          */\n      Buffer.allocUnsafeSlow = function (size) {\n        return allocUnsafe(size);\n      };\n\n      function fromString(string, encoding) {\n        if (typeof encoding !== 'string' || encoding === '') {\n          encoding = 'utf8';\n        }\n\n        if (!Buffer.isEncoding(encoding)) {\n          throw new TypeError('Unknown encoding: ' + encoding);\n        }\n\n        var length = byteLength(string, encoding) | 0;\n        var buf = createBuffer(length);\n\n        var actual = buf.write(string, encoding);\n\n        if (actual !== length) {\n          // Writing a hex string, for example, that contains invalid characters will\n          // cause everything after the first invalid character to be ignored. (e.g.\n          // 'abxxcd' will be treated as 'ab')\n          buf = buf.slice(0, actual);\n        }\n\n        return buf;\n      }\n\n      function fromArrayLike(array) {\n        var length = array.length < 0 ? 0 : checked(array.length) | 0;\n        var buf = createBuffer(length);\n        for (var i = 0; i < length; i += 1) {\n          buf[i] = array[i] & 255;\n        }\n        return buf;\n      }\n\n      function fromArrayBuffer(array, byteOffset, length) {\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('\"offset\" is outside of buffer bounds');\n        }\n\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('\"length\" is outside of buffer bounds');\n        }\n\n        var buf;\n        if (byteOffset === undefined && length === undefined) {\n          buf = new Uint8Array(array);\n        } else if (length === undefined) {\n          buf = new Uint8Array(array, byteOffset);\n        } else {\n          buf = new Uint8Array(array, byteOffset, length);\n        }\n\n        // Return an augmented `Uint8Array` instance\n        buf.__proto__ = Buffer.prototype;\n        return buf;\n      }\n\n      function fromObject(obj) {\n        if (Buffer.isBuffer(obj)) {\n          var len = checked(obj.length) | 0;\n          var buf = createBuffer(len);\n\n          if (buf.length === 0) {\n            return buf;\n          }\n\n          obj.copy(buf, 0, 0, len);\n          return buf;\n        }\n\n        if (obj.length !== undefined) {\n          if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n            return createBuffer(0);\n          }\n          return fromArrayLike(obj);\n        }\n\n        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n          return fromArrayLike(obj.data);\n        }\n      }\n\n      function checked(length) {\n        // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n        // length is NaN (which is otherwise coerced to zero.)\n        if (length >= K_MAX_LENGTH) {\n          throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n          'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n        }\n        return length | 0;\n      }\n\n      function SlowBuffer(length) {\n        if (+length != length) {// eslint-disable-line eqeqeq\n          length = 0;\n        }\n        return Buffer.alloc(+length);\n      }\n\n      Buffer.isBuffer = function isBuffer(b) {\n        return b != null && b._isBuffer === true &&\n        b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n      };\n\n      Buffer.compare = function compare(a, b) {\n        if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n        if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n          throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n\n        }\n\n        if (a === b) return 0;\n\n        var x = a.length;\n        var y = b.length;\n\n        for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n          if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n          }\n        }\n\n        if (x < y) return -1;\n        if (y < x) return 1;\n        return 0;\n      };\n\n      Buffer.isEncoding = function isEncoding(encoding) {\n        switch (String(encoding).toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'latin1':\n          case 'binary':\n          case 'base64':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n            return true;\n          default:\n            return false;}\n\n      };\n\n      Buffer.concat = function concat(list, length) {\n        if (!Array.isArray(list)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n\n        if (list.length === 0) {\n          return Buffer.alloc(0);\n        }\n\n        var i;\n        if (length === undefined) {\n          length = 0;\n          for (i = 0; i < list.length; ++i) {\n            length += list[i].length;\n          }\n        }\n\n        var buffer = Buffer.allocUnsafe(length);\n        var pos = 0;\n        for (i = 0; i < list.length; ++i) {\n          var buf = list[i];\n          if (isInstance(buf, Uint8Array)) {\n            buf = Buffer.from(buf);\n          }\n          if (!Buffer.isBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          }\n          buf.copy(buffer, pos);\n          pos += buf.length;\n        }\n        return buffer;\n      };\n\n      function byteLength(string, encoding) {\n        if (Buffer.isBuffer(string)) {\n          return string.length;\n        }\n        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n          return string.byteLength;\n        }\n        if (typeof string !== 'string') {\n          throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n          'Received type ' + typeof string);\n\n        }\n\n        var len = string.length;\n        var mustMatch = arguments.length > 2 && arguments[2] === true;\n        if (!mustMatch && len === 0) return 0;\n\n        // Use a for loop to avoid recursion\n        var loweredCase = false;\n        for (;;) {\n          switch (encoding) {\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n              return len;\n            case 'utf8':\n            case 'utf-8':\n              return utf8ToBytes(string).length;\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return len * 2;\n            case 'hex':\n              return len >>> 1;\n            case 'base64':\n              return base64ToBytes(string).length;\n            default:\n              if (loweredCase) {\n                return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n              }\n              encoding = ('' + encoding).toLowerCase();\n              loweredCase = true;}\n\n        }\n      }\n      Buffer.byteLength = byteLength;\n\n      function slowToString(encoding, start, end) {\n        var loweredCase = false;\n\n        // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n        // property of a typed array.\n\n        // This behaves neither like String nor Uint8Array in that we set start/end\n        // to their upper/lower bounds if the value passed is out of range.\n        // undefined is handled specially as per ECMA-262 6th Edition,\n        // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n        if (start === undefined || start < 0) {\n          start = 0;\n        }\n        // Return early if start > this.length. Done here to prevent potential uint32\n        // coercion fail below.\n        if (start > this.length) {\n          return '';\n        }\n\n        if (end === undefined || end > this.length) {\n          end = this.length;\n        }\n\n        if (end <= 0) {\n          return '';\n        }\n\n        // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n        end >>>= 0;\n        start >>>= 0;\n\n        if (end <= start) {\n          return '';\n        }\n\n        if (!encoding) encoding = 'utf8';\n\n        while (true) {\n          switch (encoding) {\n            case 'hex':\n              return hexSlice(this, start, end);\n\n            case 'utf8':\n            case 'utf-8':\n              return utf8Slice(this, start, end);\n\n            case 'ascii':\n              return asciiSlice(this, start, end);\n\n            case 'latin1':\n            case 'binary':\n              return latin1Slice(this, start, end);\n\n            case 'base64':\n              return base64Slice(this, start, end);\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return utf16leSlice(this, start, end);\n\n            default:\n              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n              encoding = (encoding + '').toLowerCase();\n              loweredCase = true;}\n\n        }\n      }\n\n      // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n      // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n      // reliably in a browserify context because there could be multiple different\n      // copies of the 'buffer' package in use. This method works even for Buffer\n      // instances that were created from another copy of the `buffer` package.\n      // See: https://github.com/feross/buffer/issues/154\n      Buffer.prototype._isBuffer = true;\n\n      function swap(b, n, m) {\n        var i = b[n];\n        b[n] = b[m];\n        b[m] = i;\n      }\n\n      Buffer.prototype.swap16 = function swap16() {\n        var len = this.length;\n        if (len % 2 !== 0) {\n          throw new RangeError('Buffer size must be a multiple of 16-bits');\n        }\n        for (var i = 0; i < len; i += 2) {\n          swap(this, i, i + 1);\n        }\n        return this;\n      };\n\n      Buffer.prototype.swap32 = function swap32() {\n        var len = this.length;\n        if (len % 4 !== 0) {\n          throw new RangeError('Buffer size must be a multiple of 32-bits');\n        }\n        for (var i = 0; i < len; i += 4) {\n          swap(this, i, i + 3);\n          swap(this, i + 1, i + 2);\n        }\n        return this;\n      };\n\n      Buffer.prototype.swap64 = function swap64() {\n        var len = this.length;\n        if (len % 8 !== 0) {\n          throw new RangeError('Buffer size must be a multiple of 64-bits');\n        }\n        for (var i = 0; i < len; i += 8) {\n          swap(this, i, i + 7);\n          swap(this, i + 1, i + 6);\n          swap(this, i + 2, i + 5);\n          swap(this, i + 3, i + 4);\n        }\n        return this;\n      };\n\n      Buffer.prototype.toString = function toString() {\n        var length = this.length;\n        if (length === 0) return '';\n        if (arguments.length === 0) return utf8Slice(this, 0, length);\n        return slowToString.apply(this, arguments);\n      };\n\n      Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n      Buffer.prototype.equals = function equals(b) {\n        if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n        if (this === b) return true;\n        return Buffer.compare(this, b) === 0;\n      };\n\n      Buffer.prototype.inspect = function inspect() {\n        var str = '';\n        var max = exports.INSPECT_MAX_BYTES;\n        str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n        if (this.length > max) str += ' ... ';\n        return '<Buffer ' + str + '>';\n      };\n\n      Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n        if (isInstance(target, Uint8Array)) {\n          target = Buffer.from(target, target.offset, target.byteLength);\n        }\n        if (!Buffer.isBuffer(target)) {\n          throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n          'Received type ' + typeof target);\n\n        }\n\n        if (start === undefined) {\n          start = 0;\n        }\n        if (end === undefined) {\n          end = target ? target.length : 0;\n        }\n        if (thisStart === undefined) {\n          thisStart = 0;\n        }\n        if (thisEnd === undefined) {\n          thisEnd = this.length;\n        }\n\n        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n          throw new RangeError('out of range index');\n        }\n\n        if (thisStart >= thisEnd && start >= end) {\n          return 0;\n        }\n        if (thisStart >= thisEnd) {\n          return -1;\n        }\n        if (start >= end) {\n          return 1;\n        }\n\n        start >>>= 0;\n        end >>>= 0;\n        thisStart >>>= 0;\n        thisEnd >>>= 0;\n\n        if (this === target) return 0;\n\n        var x = thisEnd - thisStart;\n        var y = end - start;\n        var len = Math.min(x, y);\n\n        var thisCopy = this.slice(thisStart, thisEnd);\n        var targetCopy = target.slice(start, end);\n\n        for (var i = 0; i < len; ++i) {\n          if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n          }\n        }\n\n        if (x < y) return -1;\n        if (y < x) return 1;\n        return 0;\n      };\n\n      // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n      // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n      //\n      // Arguments:\n      // - buffer - a Buffer to search\n      // - val - a string, Buffer, or number\n      // - byteOffset - an index into `buffer`; will be clamped to an int32\n      // - encoding - an optional encoding, relevant is val is a string\n      // - dir - true for indexOf, false for lastIndexOf\n      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n        // Empty buffer means no match\n        if (buffer.length === 0) return -1;\n\n        // Normalize byteOffset\n        if (typeof byteOffset === 'string') {\n          encoding = byteOffset;\n          byteOffset = 0;\n        } else if (byteOffset > 0x7fffffff) {\n          byteOffset = 0x7fffffff;\n        } else if (byteOffset < -0x80000000) {\n          byteOffset = -0x80000000;\n        }\n        byteOffset = +byteOffset; // Coerce to Number.\n        if (numberIsNaN(byteOffset)) {\n          // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n          byteOffset = dir ? 0 : buffer.length - 1;\n        }\n\n        // Normalize byteOffset: negative offsets start from the end of the buffer\n        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n        if (byteOffset >= buffer.length) {\n          if (dir) return -1;else\n          byteOffset = buffer.length - 1;\n        } else if (byteOffset < 0) {\n          if (dir) byteOffset = 0;else\n          return -1;\n        }\n\n        // Normalize val\n        if (typeof val === 'string') {\n          val = Buffer.from(val, encoding);\n        }\n\n        // Finally, search either indexOf (if dir is true) or lastIndexOf\n        if (Buffer.isBuffer(val)) {\n          // Special case: looking for empty string/buffer always fails\n          if (val.length === 0) {\n            return -1;\n          }\n          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n        } else if (typeof val === 'number') {\n          val = val & 0xFF; // Search for a byte value [0-255]\n          if (typeof Uint8Array.prototype.indexOf === 'function') {\n            if (dir) {\n              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n          }\n          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n        }\n\n        throw new TypeError('val must be string, number or Buffer');\n      }\n\n      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n        var indexSize = 1;\n        var arrLength = arr.length;\n        var valLength = val.length;\n\n        if (encoding !== undefined) {\n          encoding = String(encoding).toLowerCase();\n          if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n          encoding === 'utf16le' || encoding === 'utf-16le') {\n            if (arr.length < 2 || val.length < 2) {\n              return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n          }\n        }\n\n        function read(buf, i) {\n          if (indexSize === 1) {\n            return buf[i];\n          } else {\n            return buf.readUInt16BE(i * indexSize);\n          }\n        }\n\n        var i;\n        if (dir) {\n          var foundIndex = -1;\n          for (i = byteOffset; i < arrLength; i++) {\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n              if (foundIndex === -1) foundIndex = i;\n              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n              if (foundIndex !== -1) i -= i - foundIndex;\n              foundIndex = -1;\n            }\n          }\n        } else {\n          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n          for (i = byteOffset; i >= 0; i--) {\n            var found = true;\n            for (var j = 0; j < valLength; j++) {\n              if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n              }\n            }\n            if (found) return i;\n          }\n        }\n\n        return -1;\n      }\n\n      Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n        return this.indexOf(val, byteOffset, encoding) !== -1;\n      };\n\n      Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n      };\n\n      Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n      };\n\n      function hexWrite(buf, string, offset, length) {\n        offset = Number(offset) || 0;\n        var remaining = buf.length - offset;\n        if (!length) {\n          length = remaining;\n        } else {\n          length = Number(length);\n          if (length > remaining) {\n            length = remaining;\n          }\n        }\n\n        var strLen = string.length;\n\n        if (length > strLen / 2) {\n          length = strLen / 2;\n        }\n        for (var i = 0; i < length; ++i) {\n          var parsed = parseInt(string.substr(i * 2, 2), 16);\n          if (numberIsNaN(parsed)) return i;\n          buf[offset + i] = parsed;\n        }\n        return i;\n      }\n\n      function utf8Write(buf, string, offset, length) {\n        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n      }\n\n      function asciiWrite(buf, string, offset, length) {\n        return blitBuffer(asciiToBytes(string), buf, offset, length);\n      }\n\n      function latin1Write(buf, string, offset, length) {\n        return asciiWrite(buf, string, offset, length);\n      }\n\n      function base64Write(buf, string, offset, length) {\n        return blitBuffer(base64ToBytes(string), buf, offset, length);\n      }\n\n      function ucs2Write(buf, string, offset, length) {\n        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n      }\n\n      Buffer.prototype.write = function write(string, offset, length, encoding) {\n        // Buffer#write(string)\n        if (offset === undefined) {\n          encoding = 'utf8';\n          length = this.length;\n          offset = 0;\n          // Buffer#write(string, encoding)\n        } else if (length === undefined && typeof offset === 'string') {\n          encoding = offset;\n          length = this.length;\n          offset = 0;\n          // Buffer#write(string, offset[, length][, encoding])\n        } else if (isFinite(offset)) {\n          offset = offset >>> 0;\n          if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === undefined) encoding = 'utf8';\n          } else {\n            encoding = length;\n            length = undefined;\n          }\n        } else {\n          throw new Error(\n          'Buffer.write(string, encoding, offset[, length]) is no longer supported');\n\n        }\n\n        var remaining = this.length - offset;\n        if (length === undefined || length > remaining) length = remaining;\n\n        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n          throw new RangeError('Attempt to write outside buffer bounds');\n        }\n\n        if (!encoding) encoding = 'utf8';\n\n        var loweredCase = false;\n        for (;;) {\n          switch (encoding) {\n            case 'hex':\n              return hexWrite(this, string, offset, length);\n\n            case 'utf8':\n            case 'utf-8':\n              return utf8Write(this, string, offset, length);\n\n            case 'ascii':\n              return asciiWrite(this, string, offset, length);\n\n            case 'latin1':\n            case 'binary':\n              return latin1Write(this, string, offset, length);\n\n            case 'base64':\n              // Warning: maxLength not taken into account in base64Write\n              return base64Write(this, string, offset, length);\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return ucs2Write(this, string, offset, length);\n\n            default:\n              if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n              encoding = ('' + encoding).toLowerCase();\n              loweredCase = true;}\n\n        }\n      };\n\n      Buffer.prototype.toJSON = function toJSON() {\n        return {\n          type: 'Buffer',\n          data: Array.prototype.slice.call(this._arr || this, 0) };\n\n      };\n\n      function base64Slice(buf, start, end) {\n        if (start === 0 && end === buf.length) {\n          return base64.fromByteArray(buf);\n        } else {\n          return base64.fromByteArray(buf.slice(start, end));\n        }\n      }\n\n      function utf8Slice(buf, start, end) {\n        end = Math.min(buf.length, end);\n        var res = [];\n\n        var i = start;\n        while (i < end) {\n          var firstByte = buf[i];\n          var codePoint = null;\n          var bytesPerSequence = firstByte > 0xEF ? 4 :\n          firstByte > 0xDF ? 3 :\n          firstByte > 0xBF ? 2 :\n          1;\n\n          if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n            switch (bytesPerSequence) {\n              case 1:\n                if (firstByte < 0x80) {\n                  codePoint = firstByte;\n                }\n                break;\n              case 2:\n                secondByte = buf[i + 1];\n                if ((secondByte & 0xC0) === 0x80) {\n                  tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                  if (tempCodePoint > 0x7F) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 3:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                    codePoint = tempCodePoint;\n                  }\n                }\n                break;\n              case 4:\n                secondByte = buf[i + 1];\n                thirdByte = buf[i + 2];\n                fourthByte = buf[i + 3];\n                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                    codePoint = tempCodePoint;\n                  }\n                }}\n\n          }\n\n          if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n          } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n          }\n\n          res.push(codePoint);\n          i += bytesPerSequence;\n        }\n\n        return decodeCodePointsArray(res);\n      }\n\n      // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n      // the lowest limit is Chrome, with 0x10000 args.\n      // We go 1 magnitude less, for safety\n      var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n      function decodeCodePointsArray(codePoints) {\n        var len = codePoints.length;\n        if (len <= MAX_ARGUMENTS_LENGTH) {\n          return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n        }\n\n        // Decode in chunks to avoid \"call stack size exceeded\".\n        var res = '';\n        var i = 0;\n        while (i < len) {\n          res += String.fromCharCode.apply(\n          String,\n          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n\n        }\n        return res;\n      }\n\n      function asciiSlice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i] & 0x7F);\n        }\n        return ret;\n      }\n\n      function latin1Slice(buf, start, end) {\n        var ret = '';\n        end = Math.min(buf.length, end);\n\n        for (var i = start; i < end; ++i) {\n          ret += String.fromCharCode(buf[i]);\n        }\n        return ret;\n      }\n\n      function hexSlice(buf, start, end) {\n        var len = buf.length;\n\n        if (!start || start < 0) start = 0;\n        if (!end || end < 0 || end > len) end = len;\n\n        var out = '';\n        for (var i = start; i < end; ++i) {\n          out += toHex(buf[i]);\n        }\n        return out;\n      }\n\n      function utf16leSlice(buf, start, end) {\n        var bytes = buf.slice(start, end);\n        var res = '';\n        for (var i = 0; i < bytes.length; i += 2) {\n          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n        }\n        return res;\n      }\n\n      Buffer.prototype.slice = function slice(start, end) {\n        var len = this.length;\n        start = ~~start;\n        end = end === undefined ? len : ~~end;\n\n        if (start < 0) {\n          start += len;\n          if (start < 0) start = 0;\n        } else if (start > len) {\n          start = len;\n        }\n\n        if (end < 0) {\n          end += len;\n          if (end < 0) end = 0;\n        } else if (end > len) {\n          end = len;\n        }\n\n        if (end < start) end = start;\n\n        var newBuf = this.subarray(start, end);\n        // Return an augmented `Uint8Array` instance\n        newBuf.__proto__ = Buffer.prototype;\n        return newBuf;\n      };\n\n      /*\n          * Need to make sure that buffer isn't trying to write out of bounds.\n          */\n      function checkOffset(offset, ext, length) {\n        if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n        if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n      }\n\n      Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n        var val = this[offset];\n        var mul = 1;\n        var i = 0;\n        while (++i < byteLength && (mul *= 0x100)) {\n          val += this[offset + i] * mul;\n        }\n\n        return val;\n      };\n\n      Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) {\n          checkOffset(offset, byteLength, this.length);\n        }\n\n        var val = this[offset + --byteLength];\n        var mul = 1;\n        while (byteLength > 0 && (mul *= 0x100)) {\n          val += this[offset + --byteLength] * mul;\n        }\n\n        return val;\n      };\n\n      Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 1, this.length);\n        return this[offset];\n      };\n\n      Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        return this[offset] | this[offset + 1] << 8;\n      };\n\n      Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        return this[offset] << 8 | this[offset + 1];\n      };\n\n      Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n\n        return (this[offset] |\n        this[offset + 1] << 8 |\n        this[offset + 2] << 16) +\n        this[offset + 3] * 0x1000000;\n      };\n\n      Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n\n        return this[offset] * 0x1000000 + (\n        this[offset + 1] << 16 |\n        this[offset + 2] << 8 |\n        this[offset + 3]);\n      };\n\n      Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n        var val = this[offset];\n        var mul = 1;\n        var i = 0;\n        while (++i < byteLength && (mul *= 0x100)) {\n          val += this[offset + i] * mul;\n        }\n        mul *= 0x80;\n\n        if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n        return val;\n      };\n\n      Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n        var i = byteLength;\n        var mul = 1;\n        var val = this[offset + --i];\n        while (i > 0 && (mul *= 0x100)) {\n          val += this[offset + --i] * mul;\n        }\n        mul *= 0x80;\n\n        if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n        return val;\n      };\n\n      Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 1, this.length);\n        if (!(this[offset] & 0x80)) return this[offset];\n        return (0xff - this[offset] + 1) * -1;\n      };\n\n      Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        var val = this[offset] | this[offset + 1] << 8;\n        return val & 0x8000 ? val | 0xFFFF0000 : val;\n      };\n\n      Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 2, this.length);\n        var val = this[offset + 1] | this[offset] << 8;\n        return val & 0x8000 ? val | 0xFFFF0000 : val;\n      };\n\n      Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n\n        return this[offset] |\n        this[offset + 1] << 8 |\n        this[offset + 2] << 16 |\n        this[offset + 3] << 24;\n      };\n\n      Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n\n        return this[offset] << 24 |\n        this[offset + 1] << 16 |\n        this[offset + 2] << 8 |\n        this[offset + 3];\n      };\n\n      Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, true, 23, 4);\n      };\n\n      Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 4, this.length);\n        return ieee754.read(this, offset, false, 23, 4);\n      };\n\n      Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, true, 52, 8);\n      };\n\n      Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n        offset = offset >>> 0;\n        if (!noAssert) checkOffset(offset, 8, this.length);\n        return ieee754.read(this, offset, false, 52, 8);\n      };\n\n      function checkInt(buf, value, offset, ext, max, min) {\n        if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n        if (offset + ext > buf.length) throw new RangeError('Index out of range');\n      }\n\n      Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) {\n          var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n          checkInt(this, value, offset, byteLength, maxBytes, 0);\n        }\n\n        var mul = 1;\n        var i = 0;\n        this[offset] = value & 0xFF;\n        while (++i < byteLength && (mul *= 0x100)) {\n          this[offset + i] = value / mul & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        byteLength = byteLength >>> 0;\n        if (!noAssert) {\n          var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n          checkInt(this, value, offset, byteLength, maxBytes, 0);\n        }\n\n        var i = byteLength - 1;\n        var mul = 1;\n        this[offset + i] = value & 0xFF;\n        while (--i >= 0 && (mul *= 0x100)) {\n          this[offset + i] = value / mul & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n        this[offset] = value & 0xff;\n        return offset + 1;\n      };\n\n      Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n        return offset + 4;\n      };\n\n      Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n        return offset + 4;\n      };\n\n      Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          var limit = Math.pow(2, 8 * byteLength - 1);\n\n          checkInt(this, value, offset, byteLength, limit - 1, -limit);\n        }\n\n        var i = 0;\n        var mul = 1;\n        var sub = 0;\n        this[offset] = value & 0xFF;\n        while (++i < byteLength && (mul *= 0x100)) {\n          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          var limit = Math.pow(2, 8 * byteLength - 1);\n\n          checkInt(this, value, offset, byteLength, limit - 1, -limit);\n        }\n\n        var i = byteLength - 1;\n        var mul = 1;\n        var sub = 0;\n        this[offset + i] = value & 0xFF;\n        while (--i >= 0 && (mul *= 0x100)) {\n          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n          }\n          this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n        }\n\n        return offset + byteLength;\n      };\n\n      Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n        if (value < 0) value = 0xff + value + 1;\n        this[offset] = value & 0xff;\n        return offset + 1;\n      };\n\n      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n        return offset + 2;\n      };\n\n      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n        return offset + 4;\n      };\n\n      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n        if (value < 0) value = 0xffffffff + value + 1;\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n        return offset + 4;\n      };\n\n      function checkIEEE754(buf, value, offset, ext, max, min) {\n        if (offset + ext > buf.length) throw new RangeError('Index out of range');\n        if (offset < 0) throw new RangeError('Index out of range');\n      }\n\n      function writeFloat(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 23, 4);\n        return offset + 4;\n      }\n\n      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n        return writeFloat(this, value, offset, false, noAssert);\n      };\n\n      function writeDouble(buf, value, offset, littleEndian, noAssert) {\n        value = +value;\n        offset = offset >>> 0;\n        if (!noAssert) {\n          checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n        }\n        ieee754.write(buf, value, offset, littleEndian, 52, 8);\n        return offset + 8;\n      }\n\n      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, true, noAssert);\n      };\n\n      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n        return writeDouble(this, value, offset, false, noAssert);\n      };\n\n      // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n      Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n        if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n        if (!start) start = 0;\n        if (!end && end !== 0) end = this.length;\n        if (targetStart >= target.length) targetStart = target.length;\n        if (!targetStart) targetStart = 0;\n        if (end > 0 && end < start) end = start;\n\n        // Copy 0 bytes; we're done\n        if (end === start) return 0;\n        if (target.length === 0 || this.length === 0) return 0;\n\n        // Fatal error conditions\n        if (targetStart < 0) {\n          throw new RangeError('targetStart out of bounds');\n        }\n        if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n        if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n        // Are we oob?\n        if (end > this.length) end = this.length;\n        if (target.length - targetStart < end - start) {\n          end = target.length - targetStart + start;\n        }\n\n        var len = end - start;\n\n        if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n          // Use built-in when available, missing from IE11\n          this.copyWithin(targetStart, start, end);\n        } else if (this === target && start < targetStart && targetStart < end) {\n          // descending copy from end\n          for (var i = len - 1; i >= 0; --i) {\n            target[i + targetStart] = this[i + start];\n          }\n        } else {\n          Uint8Array.prototype.set.call(\n          target,\n          this.subarray(start, end),\n          targetStart);\n\n        }\n\n        return len;\n      };\n\n      // Usage:\n      //    buffer.fill(number[, offset[, end]])\n      //    buffer.fill(buffer[, offset[, end]])\n      //    buffer.fill(string[, offset[, end]][, encoding])\n      Buffer.prototype.fill = function fill(val, start, end, encoding) {\n        // Handle string cases:\n        if (typeof val === 'string') {\n          if (typeof start === 'string') {\n            encoding = start;\n            start = 0;\n            end = this.length;\n          } else if (typeof end === 'string') {\n            encoding = end;\n            end = this.length;\n          }\n          if (encoding !== undefined && typeof encoding !== 'string') {\n            throw new TypeError('encoding must be a string');\n          }\n          if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n            throw new TypeError('Unknown encoding: ' + encoding);\n          }\n          if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (encoding === 'utf8' && code < 128 ||\n            encoding === 'latin1') {\n              // Fast path: If `val` fits into a single byte, use that numeric value.\n              val = code;\n            }\n          }\n        } else if (typeof val === 'number') {\n          val = val & 255;\n        }\n\n        // Invalid ranges are not set to a default, so can range check early.\n        if (start < 0 || this.length < start || this.length < end) {\n          throw new RangeError('Out of range index');\n        }\n\n        if (end <= start) {\n          return this;\n        }\n\n        start = start >>> 0;\n        end = end === undefined ? this.length : end >>> 0;\n\n        if (!val) val = 0;\n\n        var i;\n        if (typeof val === 'number') {\n          for (i = start; i < end; ++i) {\n            this[i] = val;\n          }\n        } else {\n          var bytes = Buffer.isBuffer(val) ?\n          val :\n          Buffer.from(val, encoding);\n          var len = bytes.length;\n          if (len === 0) {\n            throw new TypeError('The value \"' + val +\n            '\" is invalid for argument \"value\"');\n          }\n          for (i = 0; i < end - start; ++i) {\n            this[i + start] = bytes[i % len];\n          }\n        }\n\n        return this;\n      };\n\n      // HELPER FUNCTIONS\n      // ================\n\n      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n      function base64clean(str) {\n        // Node takes equal signs as end of the Base64 encoding\n        str = str.split('=')[0];\n        // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n        str = str.trim().replace(INVALID_BASE64_RE, '');\n        // Node converts strings with length < 2 to ''\n        if (str.length < 2) return '';\n        // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n        while (str.length % 4 !== 0) {\n          str = str + '=';\n        }\n        return str;\n      }\n\n      function toHex(n) {\n        if (n < 16) return '0' + n.toString(16);\n        return n.toString(16);\n      }\n\n      function utf8ToBytes(string, units) {\n        units = units || Infinity;\n        var codePoint;\n        var length = string.length;\n        var leadSurrogate = null;\n        var bytes = [];\n\n        for (var i = 0; i < length; ++i) {\n          codePoint = string.charCodeAt(i);\n\n          // is surrogate component\n          if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n              // no lead yet\n              if (codePoint > 0xDBFF) {\n                // unexpected trail\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                continue;\n              } else if (i + 1 === length) {\n                // unpaired lead\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                continue;\n              }\n\n              // valid lead\n              leadSurrogate = codePoint;\n\n              continue;\n            }\n\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              leadSurrogate = codePoint;\n              continue;\n            }\n\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n          } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          }\n\n          leadSurrogate = null;\n\n          // encode utf8\n          if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n          } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(\n            codePoint >> 0x6 | 0xC0,\n            codePoint & 0x3F | 0x80);\n\n          } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(\n            codePoint >> 0xC | 0xE0,\n            codePoint >> 0x6 & 0x3F | 0x80,\n            codePoint & 0x3F | 0x80);\n\n          } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(\n            codePoint >> 0x12 | 0xF0,\n            codePoint >> 0xC & 0x3F | 0x80,\n            codePoint >> 0x6 & 0x3F | 0x80,\n            codePoint & 0x3F | 0x80);\n\n          } else {\n            throw new Error('Invalid code point');\n          }\n        }\n\n        return bytes;\n      }\n\n      function asciiToBytes(str) {\n        var byteArray = [];\n        for (var i = 0; i < str.length; ++i) {\n          // Node's code seems to be doing this and not & 0x7F..\n          byteArray.push(str.charCodeAt(i) & 0xFF);\n        }\n        return byteArray;\n      }\n\n      function utf16leToBytes(str, units) {\n        var c, hi, lo;\n        var byteArray = [];\n        for (var i = 0; i < str.length; ++i) {\n          if ((units -= 2) < 0) break;\n\n          c = str.charCodeAt(i);\n          hi = c >> 8;\n          lo = c % 256;\n          byteArray.push(lo);\n          byteArray.push(hi);\n        }\n\n        return byteArray;\n      }\n\n      function base64ToBytes(str) {\n        return base64.toByteArray(base64clean(str));\n      }\n\n      function blitBuffer(src, dst, offset, length) {\n        for (var i = 0; i < length; ++i) {\n          if (i + offset >= dst.length || i >= src.length) break;\n          dst[i + offset] = src[i];\n        }\n        return i;\n      }\n\n      // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n      // the `instanceof` check but they should be treated as of that type.\n      // See: https://github.com/feross/buffer/issues/166\n      function isInstance(obj, type) {\n        return obj instanceof type ||\n        obj != null && obj.constructor != null && obj.constructor.name != null &&\n        obj.constructor.name === type.name;\n      }\n      function numberIsNaN(obj) {\n        // For IE11 support\n        return obj !== obj; // eslint-disable-line no-self-compare\n      }\n\n    }, { \"base64-js\": 10, \"ieee754\": 79 }], 13: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      var objectCreate = Object.create || objectCreatePolyfill;\n      var objectKeys = Object.keys || objectKeysPolyfill;\n      var bind = Function.prototype.bind || functionBindPolyfill;\n\n      function EventEmitter() {\n        if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        }\n\n        this._maxListeners = this._maxListeners || undefined;\n      }\n      module.exports = EventEmitter;\n\n      // Backwards-compat with node 0.10.x\n      EventEmitter.EventEmitter = EventEmitter;\n\n      EventEmitter.prototype._events = undefined;\n      EventEmitter.prototype._maxListeners = undefined;\n\n      // By default EventEmitters will print a warning if more than 10 listeners are\n      // added to it. This is a useful default which helps finding memory leaks.\n      var defaultMaxListeners = 10;\n\n      var hasDefineProperty;\n      try {\n        var o = {};\n        if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n        hasDefineProperty = o.x === 0;\n      } catch (err) {hasDefineProperty = false;}\n      if (hasDefineProperty) {\n        Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n          enumerable: true,\n          get: function get() {\n            return defaultMaxListeners;\n          },\n          set: function set(arg) {\n            // check whether the input is a positive number (whose value is zero or\n            // greater and not a NaN).\n            if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n            throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n            defaultMaxListeners = arg;\n          } });\n\n      } else {\n        EventEmitter.defaultMaxListeners = defaultMaxListeners;\n      }\n\n      // Obviously not all Emitters should be limited to 10. This function allows\n      // that to be increased. Set to zero for unlimited.\n      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n        if (typeof n !== 'number' || n < 0 || isNaN(n))\n        throw new TypeError('\"n\" argument must be a positive number');\n        this._maxListeners = n;\n        return this;\n      };\n\n      function $getMaxListeners(that) {\n        if (that._maxListeners === undefined)\n        return EventEmitter.defaultMaxListeners;\n        return that._maxListeners;\n      }\n\n      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n        return $getMaxListeners(this);\n      };\n\n      // These standalone emit* functions are used to optimize calling of event\n      // handlers for fast cases because emit() itself often has a variable number of\n      // arguments and can be deoptimized because of that. These functions always have\n      // the same number of arguments and thus do not get deoptimized, so the code\n      // inside them can execute faster.\n      function emitNone(handler, isFn, self) {\n        if (isFn)\n        handler.call(self);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self);}\n        }\n      }\n      function emitOne(handler, isFn, self, arg1) {\n        if (isFn)\n        handler.call(self, arg1);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self, arg1);}\n        }\n      }\n      function emitTwo(handler, isFn, self, arg1, arg2) {\n        if (isFn)\n        handler.call(self, arg1, arg2);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self, arg1, arg2);}\n        }\n      }\n      function emitThree(handler, isFn, self, arg1, arg2, arg3) {\n        if (isFn)\n        handler.call(self, arg1, arg2, arg3);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self, arg1, arg2, arg3);}\n        }\n      }\n\n      function emitMany(handler, isFn, self, args) {\n        if (isFn)\n        handler.apply(self, args);else\n        {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].apply(self, args);}\n        }\n      }\n\n      EventEmitter.prototype.emit = function emit(type) {\n        var er, handler, len, args, i, events;\n        var doError = type === 'error';\n\n        events = this._events;\n        if (events)\n        doError = doError && events.error == null;else\n        if (!doError)\n        return false;\n\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n          if (arguments.length > 1)\n          er = arguments[1];\n          if (er instanceof Error) {\n            throw er; // Unhandled 'error' event\n          } else {\n            // At least give some kind of context to the user\n            var err = new Error('Unhandled \"error\" event. (' + er + ')');\n            err.context = er;\n            throw err;\n          }\n          return false;\n        }\n\n        handler = events[type];\n\n        if (!handler)\n        return false;\n\n        var isFn = typeof handler === 'function';\n        len = arguments.length;\n        switch (len) {\n          // fast cases\n          case 1:\n            emitNone(handler, isFn, this);\n            break;\n          case 2:\n            emitOne(handler, isFn, this, arguments[1]);\n            break;\n          case 3:\n            emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n            break;\n          case 4:\n            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n            break;\n          // slower\n          default:\n            args = new Array(len - 1);\n            for (i = 1; i < len; i++) {\n              args[i - 1] = arguments[i];}\n            emitMany(handler, isFn, this, args);}\n\n\n        return true;\n      };\n\n      function _addListener(target, type, listener, prepend) {\n        var m;\n        var events;\n        var existing;\n\n        if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n        events = target._events;\n        if (!events) {\n          events = target._events = objectCreate(null);\n          target._eventsCount = 0;\n        } else {\n          // To avoid recursion in the case that type === \"newListener\"! Before\n          // adding it to the listeners, first emit \"newListener\".\n          if (events.newListener) {\n            target.emit('newListener', type,\n            listener.listener ? listener.listener : listener);\n\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n          }\n          existing = events[type];\n        }\n\n        if (!existing) {\n          // Optimize the case of one listener. Don't need the extra array object.\n          existing = events[type] = listener;\n          ++target._eventsCount;\n        } else {\n          if (typeof existing === 'function') {\n            // Adding the second element, need to change to array.\n            existing = events[type] =\n            prepend ? [listener, existing] : [existing, listener];\n          } else {\n            // If we've already got an array, just append.\n            if (prepend) {\n              existing.unshift(listener);\n            } else {\n              existing.push(listener);\n            }\n          }\n\n          // Check for listener leak\n          if (!existing.warned) {\n            m = $getMaxListeners(target);\n            if (m && m > 0 && existing.length > m) {\n              existing.warned = true;\n              var w = new Error('Possible EventEmitter memory leak detected. ' +\n              existing.length + ' \"' + String(type) + '\" listeners ' +\n              'added. Use emitter.setMaxListeners() to ' +\n              'increase limit.');\n              w.name = 'MaxListenersExceededWarning';\n              w.emitter = target;\n              w.type = type;\n              w.count = existing.length;\n              if (typeof console === 'object' && console.warn) {\n                __f__(\"warn\", '%s: %s', w.name, w.message, \" at utils/mqttjs3/mqtt.js:4451\");\n              }\n            }\n          }\n        }\n\n        return target;\n      }\n\n      EventEmitter.prototype.addListener = function addListener(type, listener) {\n        return _addListener(this, type, listener, false);\n      };\n\n      EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n      EventEmitter.prototype.prependListener =\n      function prependListener(type, listener) {\n        return _addListener(this, type, listener, true);\n      };\n\n      function onceWrapper() {\n        if (!this.fired) {\n          this.target.removeListener(this.type, this.wrapFn);\n          this.fired = true;\n          switch (arguments.length) {\n            case 0:\n              return this.listener.call(this.target);\n            case 1:\n              return this.listener.call(this.target, arguments[0]);\n            case 2:\n              return this.listener.call(this.target, arguments[0], arguments[1]);\n            case 3:\n              return this.listener.call(this.target, arguments[0], arguments[1],\n              arguments[2]);\n            default:\n              var args = new Array(arguments.length);\n              for (var i = 0; i < args.length; ++i) {\n                args[i] = arguments[i];}\n              this.listener.apply(this.target, args);}\n\n        }\n      }\n\n      function _onceWrap(target, type, listener) {\n        var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n        var wrapped = bind.call(onceWrapper, state);\n        wrapped.listener = listener;\n        state.wrapFn = wrapped;\n        return wrapped;\n      }\n\n      EventEmitter.prototype.once = function once(type, listener) {\n        if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n        this.on(type, _onceWrap(this, type, listener));\n        return this;\n      };\n\n      EventEmitter.prototype.prependOnceListener =\n      function prependOnceListener(type, listener) {\n        if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n        this.prependListener(type, _onceWrap(this, type, listener));\n        return this;\n      };\n\n      // Emits a 'removeListener' event if and only if the listener was removed.\n      EventEmitter.prototype.removeListener =\n      function removeListener(type, listener) {\n        var list, events, position, i, originalListener;\n\n        if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n        events = this._events;\n        if (!events)\n        return this;\n\n        list = events[type];\n        if (!list)\n        return this;\n\n        if (list === listener || list.listener === listener) {\n          if (--this._eventsCount === 0)\n          this._events = objectCreate(null);else\n          {\n            delete events[type];\n            if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n          }\n        } else if (typeof list !== 'function') {\n          position = -1;\n\n          for (i = list.length - 1; i >= 0; i--) {\n            if (list[i] === listener || list[i].listener === listener) {\n              originalListener = list[i].listener;\n              position = i;\n              break;\n            }\n          }\n\n          if (position < 0)\n          return this;\n\n          if (position === 0)\n          list.shift();else\n\n          spliceOne(list, position);\n\n          if (list.length === 1)\n          events[type] = list[0];\n\n          if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n        }\n\n        return this;\n      };\n\n      EventEmitter.prototype.removeAllListeners =\n      function removeAllListeners(type) {\n        var listeners, events, i;\n\n        events = this._events;\n        if (!events)\n        return this;\n\n        // not listening for removeListener, no need to emit\n        if (!events.removeListener) {\n          if (arguments.length === 0) {\n            this._events = objectCreate(null);\n            this._eventsCount = 0;\n          } else if (events[type]) {\n            if (--this._eventsCount === 0)\n            this._events = objectCreate(null);else\n\n            delete events[type];\n          }\n          return this;\n        }\n\n        // emit removeListener for all listeners on all events\n        if (arguments.length === 0) {\n          var keys = objectKeys(events);\n          var key;\n          for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n          }\n          this.removeAllListeners('removeListener');\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n          return this;\n        }\n\n        listeners = events[type];\n\n        if (typeof listeners === 'function') {\n          this.removeListener(type, listeners);\n        } else if (listeners) {\n          // LIFO order\n          for (i = listeners.length - 1; i >= 0; i--) {\n            this.removeListener(type, listeners[i]);\n          }\n        }\n\n        return this;\n      };\n\n      function _listeners(target, type, unwrap) {\n        var events = target._events;\n\n        if (!events)\n        return [];\n\n        var evlistener = events[type];\n        if (!evlistener)\n        return [];\n\n        if (typeof evlistener === 'function')\n        return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n      }\n\n      EventEmitter.prototype.listeners = function listeners(type) {\n        return _listeners(this, type, true);\n      };\n\n      EventEmitter.prototype.rawListeners = function rawListeners(type) {\n        return _listeners(this, type, false);\n      };\n\n      EventEmitter.listenerCount = function (emitter, type) {\n        if (typeof emitter.listenerCount === 'function') {\n          return emitter.listenerCount(type);\n        } else {\n          return listenerCount.call(emitter, type);\n        }\n      };\n\n      EventEmitter.prototype.listenerCount = listenerCount;\n      function listenerCount(type) {\n        var events = this._events;\n\n        if (events) {\n          var evlistener = events[type];\n\n          if (typeof evlistener === 'function') {\n            return 1;\n          } else if (evlistener) {\n            return evlistener.length;\n          }\n        }\n\n        return 0;\n      }\n\n      EventEmitter.prototype.eventNames = function eventNames() {\n        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n      };\n\n      // About 1.5x faster than the two-arg version of Array#splice().\n      function spliceOne(list, index) {\n        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n          list[i] = list[k];}\n        list.pop();\n      }\n\n      function arrayClone(arr, n) {\n        var copy = new Array(n);\n        for (var i = 0; i < n; ++i) {\n          copy[i] = arr[i];}\n        return copy;\n      }\n\n      function unwrapListeners(arr) {\n        var ret = new Array(arr.length);\n        for (var i = 0; i < ret.length; ++i) {\n          ret[i] = arr[i].listener || arr[i];\n        }\n        return ret;\n      }\n\n      function objectCreatePolyfill(proto) {\n        var F = function F() {};\n        F.prototype = proto;\n        return new F();\n      }\n      function objectKeysPolyfill(obj) {\n        var keys = [];\n        for (var k in obj) {if (Object.prototype.hasOwnProperty.call(obj, k)) {\n            keys.push(k);\n          }}\n        return k;\n      }\n      function functionBindPolyfill(context) {\n        var fn = this;\n        return function () {\n          return fn.apply(context, arguments);\n        };\n      }\n\n    }, {}], 14: [function (require, module, exports) {\n      (function (Buffer) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        // NOTE: These type checking functions intentionally don't use `instanceof`\n        // because it is fragile and can be easily faked with `Object.create()`.\n\n        function isArray(arg) {\n          if (Array.isArray) {\n            return Array.isArray(arg);\n          }\n          return objectToString(arg) === '[object Array]';\n        }\n        exports.isArray = isArray;\n\n        function isBoolean(arg) {\n          return typeof arg === 'boolean';\n        }\n        exports.isBoolean = isBoolean;\n\n        function isNull(arg) {\n          return arg === null;\n        }\n        exports.isNull = isNull;\n\n        function isNullOrUndefined(arg) {\n          return arg == null;\n        }\n        exports.isNullOrUndefined = isNullOrUndefined;\n\n        function isNumber(arg) {\n          return typeof arg === 'number';\n        }\n        exports.isNumber = isNumber;\n\n        function isString(arg) {\n          return typeof arg === 'string';\n        }\n        exports.isString = isString;\n\n        function isSymbol(arg) {\n          return typeof arg === 'symbol';\n        }\n        exports.isSymbol = isSymbol;\n\n        function isUndefined(arg) {\n          return arg === void 0;\n        }\n        exports.isUndefined = isUndefined;\n\n        function isRegExp(re) {\n          return objectToString(re) === '[object RegExp]';\n        }\n        exports.isRegExp = isRegExp;\n\n        function isObject(arg) {\n          return typeof arg === 'object' && arg !== null;\n        }\n        exports.isObject = isObject;\n\n        function isDate(d) {\n          return objectToString(d) === '[object Date]';\n        }\n        exports.isDate = isDate;\n\n        function isError(e) {\n          return objectToString(e) === '[object Error]' || e instanceof Error;\n        }\n        exports.isError = isError;\n\n        function isFunction(arg) {\n          return typeof arg === 'function';\n        }\n        exports.isFunction = isFunction;\n\n        function isPrimitive(arg) {\n          return arg === null ||\n          typeof arg === 'boolean' ||\n          typeof arg === 'number' ||\n          typeof arg === 'string' ||\n          typeof arg === 'symbol' || // ES6 symbol\n          typeof arg === 'undefined';\n        }\n        exports.isPrimitive = isPrimitive;\n\n        exports.isBuffer = Buffer.isBuffer;\n\n        function objectToString(o) {\n          return Object.prototype.toString.call(o);\n        }\n\n      }).call(this, { \"isBuffer\": require(\"../../is-buffer/index.js\") });\n    }, { \"../../is-buffer/index.js\": 81 }], 15: [function (require, module, exports) {\n      'use strict';\n\n      var copy = require('es5-ext/object/copy'),\n      normalizeOptions = require('es5-ext/object/normalize-options'),\n      ensureCallable = require('es5-ext/object/valid-callable'),\n      map = require('es5-ext/object/map'),\n      callable = require('es5-ext/object/valid-callable'),\n      validValue = require('es5-ext/object/valid-value'),\n\n      bind = Function.prototype.bind,defineProperty = Object.defineProperty,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      define;\n\n      define = function define(name, desc, options) {\n        var value = validValue(desc) && callable(desc.value),dgs;\n        dgs = copy(desc);\n        delete dgs.writable;\n        delete dgs.value;\n        dgs.get = function () {\n          if (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;\n          desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);\n          defineProperty(this, name, desc);\n          return this[name];\n        };\n        return dgs;\n      };\n\n      module.exports = function (props /*, options*/) {\n        var options = normalizeOptions(arguments[1]);\n        if (options.resolveContext != null) ensureCallable(options.resolveContext);\n        return map(props, function (desc, name) {return define(name, desc, options);});\n      };\n\n    }, { \"es5-ext/object/copy\": 39, \"es5-ext/object/map\": 48, \"es5-ext/object/normalize-options\": 49, \"es5-ext/object/valid-callable\": 54, \"es5-ext/object/valid-value\": 55 }], 16: [function (require, module, exports) {\n      'use strict';\n\n      var assign = require('es5-ext/object/assign'),\n      normalizeOpts = require('es5-ext/object/normalize-options'),\n      isCallable = require('es5-ext/object/is-callable'),\n      contains = require('es5-ext/string/#/contains'),\n\n      d;\n\n      d = module.exports = function (dscr, value /*, options*/) {\n        var c, e, w, options, desc;\n        if (arguments.length < 2 || typeof dscr !== 'string') {\n          options = value;\n          value = dscr;\n          dscr = null;\n        } else {\n          options = arguments[2];\n        }\n        if (dscr == null) {\n          c = w = true;\n          e = false;\n        } else {\n          c = contains.call(dscr, 'c');\n          e = contains.call(dscr, 'e');\n          w = contains.call(dscr, 'w');\n        }\n\n        desc = { value: value, configurable: c, enumerable: e, writable: w };\n        return !options ? desc : assign(normalizeOpts(options), desc);\n      };\n\n      d.gs = function (dscr, get, set /*, options*/) {\n        var c, e, options, desc;\n        if (typeof dscr !== 'string') {\n          options = set;\n          set = get;\n          get = dscr;\n          dscr = null;\n        } else {\n          options = arguments[3];\n        }\n        if (get == null) {\n          get = undefined;\n        } else if (!isCallable(get)) {\n          options = get;\n          get = set = undefined;\n        } else if (set == null) {\n          set = undefined;\n        } else if (!isCallable(set)) {\n          options = set;\n          set = undefined;\n        }\n        if (dscr == null) {\n          c = true;\n          e = false;\n        } else {\n          c = contains.call(dscr, 'c');\n          e = contains.call(dscr, 'e');\n        }\n\n        desc = { get: get, set: set, configurable: c, enumerable: e };\n        return !options ? desc : assign(normalizeOpts(options), desc);\n      };\n\n    }, { \"es5-ext/object/assign\": 36, \"es5-ext/object/is-callable\": 42, \"es5-ext/object/normalize-options\": 49, \"es5-ext/string/#/contains\": 56 }], 17: [function (require, module, exports) {\n      (function (process, Buffer) {\n        var stream = require('readable-stream');\n        var eos = require('end-of-stream');\n        var inherits = require('inherits');\n        var shift = require('stream-shift');\n\n        var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ?\n        Buffer.from([0]) :\n        new Buffer([0]);\n\n        var onuncork = function onuncork(self, fn) {\n          if (self._corked) self.once('uncork', fn);else\n          fn();\n        };\n\n        var autoDestroy = function autoDestroy(self, err) {\n          if (self._autoDestroy) self.destroy(err);\n        };\n\n        var destroyer = function destroyer(self, end) {\n          return function (err) {\n            if (err) autoDestroy(self, err.message === 'premature close' ? null : err);else\n            if (end && !self._ended) self.end();\n          };\n        };\n\n        var end = function end(ws, fn) {\n          if (!ws) return fn();\n          if (ws._writableState && ws._writableState.finished) return fn();\n          if (ws._writableState) return ws.end(fn);\n          ws.end();\n          fn();\n        };\n\n        var toStreams2 = function toStreams2(rs) {\n          return new stream.Readable({ objectMode: true, highWaterMark: 16 }).wrap(rs);\n        };\n\n        var Duplexify = function Duplexify(writable, readable, opts) {\n          if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts);\n          stream.Duplex.call(this, opts);\n\n          this._writable = null;\n          this._readable = null;\n          this._readable2 = null;\n\n          this._autoDestroy = !opts || opts.autoDestroy !== false;\n          this._forwardDestroy = !opts || opts.destroy !== false;\n          this._forwardEnd = !opts || opts.end !== false;\n          this._corked = 1; // start corked\n          this._ondrain = null;\n          this._drained = false;\n          this._forwarding = false;\n          this._unwrite = null;\n          this._unread = null;\n          this._ended = false;\n\n          this.destroyed = false;\n\n          if (writable) this.setWritable(writable);\n          if (readable) this.setReadable(readable);\n        };\n\n        inherits(Duplexify, stream.Duplex);\n\n        Duplexify.obj = function (writable, readable, opts) {\n          if (!opts) opts = {};\n          opts.objectMode = true;\n          opts.highWaterMark = 16;\n          return new Duplexify(writable, readable, opts);\n        };\n\n        Duplexify.prototype.cork = function () {\n          if (++this._corked === 1) this.emit('cork');\n        };\n\n        Duplexify.prototype.uncork = function () {\n          if (this._corked && --this._corked === 0) this.emit('uncork');\n        };\n\n        Duplexify.prototype.setWritable = function (writable) {\n          if (this._unwrite) this._unwrite();\n\n          if (this.destroyed) {\n            if (writable && writable.destroy) writable.destroy();\n            return;\n          }\n\n          if (writable === null || writable === false) {\n            this.end();\n            return;\n          }\n\n          var self = this;\n          var unend = eos(writable, { writable: true, readable: false }, destroyer(this, this._forwardEnd));\n\n          var ondrain = function ondrain() {\n            var ondrain = self._ondrain;\n            self._ondrain = null;\n            if (ondrain) ondrain();\n          };\n\n          var clear = function clear() {\n            self._writable.removeListener('drain', ondrain);\n            unend();\n          };\n\n          if (this._unwrite) process.nextTick(ondrain); // force a drain on stream reset to avoid livelocks\n\n          this._writable = writable;\n          this._writable.on('drain', ondrain);\n          this._unwrite = clear;\n\n          this.uncork(); // always uncork setWritable\n        };\n\n        Duplexify.prototype.setReadable = function (readable) {\n          if (this._unread) this._unread();\n\n          if (this.destroyed) {\n            if (readable && readable.destroy) readable.destroy();\n            return;\n          }\n\n          if (readable === null || readable === false) {\n            this.push(null);\n            this.resume();\n            return;\n          }\n\n          var self = this;\n          var unend = eos(readable, { writable: false, readable: true }, destroyer(this));\n\n          var onreadable = function onreadable() {\n            self._forward();\n          };\n\n          var onend = function onend() {\n            self.push(null);\n          };\n\n          var clear = function clear() {\n            self._readable2.removeListener('readable', onreadable);\n            self._readable2.removeListener('end', onend);\n            unend();\n          };\n\n          this._drained = true;\n          this._readable = readable;\n          this._readable2 = readable._readableState ? readable : toStreams2(readable);\n          this._readable2.on('readable', onreadable);\n          this._readable2.on('end', onend);\n          this._unread = clear;\n\n          this._forward();\n        };\n\n        Duplexify.prototype._read = function () {\n          this._drained = true;\n          this._forward();\n        };\n\n        Duplexify.prototype._forward = function () {\n          if (this._forwarding || !this._readable2 || !this._drained) return;\n          this._forwarding = true;\n\n          var data;\n\n          while (this._drained && (data = shift(this._readable2)) !== null) {\n            if (this.destroyed) continue;\n            this._drained = this.push(data);\n          }\n\n          this._forwarding = false;\n        };\n\n        Duplexify.prototype.destroy = function (err) {\n          if (this.destroyed) return;\n          this.destroyed = true;\n\n          var self = this;\n          process.nextTick(function () {\n            self._destroy(err);\n          });\n        };\n\n        Duplexify.prototype._destroy = function (err) {\n          if (err) {\n            var ondrain = this._ondrain;\n            this._ondrain = null;\n            if (ondrain) ondrain(err);else\n            this.emit('error', err);\n          }\n\n          if (this._forwardDestroy) {\n            if (this._readable && this._readable.destroy) this._readable.destroy();\n            if (this._writable && this._writable.destroy) this._writable.destroy();\n          }\n\n          this.emit('close');\n        };\n\n        Duplexify.prototype._write = function (data, enc, cb) {\n          if (this.destroyed) return cb();\n          if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb));\n          if (data === SIGNAL_FLUSH) return this._finish(cb);\n          if (!this._writable) return cb();\n\n          if (this._writable.write(data) === false) this._ondrain = cb;else\n          cb();\n        };\n\n        Duplexify.prototype._finish = function (cb) {\n          var self = this;\n          this.emit('preend');\n          onuncork(this, function () {\n            end(self._forwardEnd && self._writable, function () {\n              // haxx to not emit prefinish twice\n              if (self._writableState.prefinished === false) self._writableState.prefinished = true;\n              self.emit('prefinish');\n              onuncork(self, cb);\n            });\n          });\n        };\n\n        Duplexify.prototype.end = function (data, enc, cb) {\n          if (typeof data === 'function') return this.end(null, null, data);\n          if (typeof enc === 'function') return this.end(data, null, enc);\n          this._ended = true;\n          if (data) this.write(data);\n          if (!this._writableState.ending) this.write(SIGNAL_FLUSH);\n          return stream.Writable.prototype.end.call(this, cb);\n        };\n\n        module.exports = Duplexify;\n\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, { \"_process\": 92, \"buffer\": 12, \"end-of-stream\": 18, \"inherits\": 80, \"readable-stream\": 108, \"stream-shift\": 111 }], 18: [function (require, module, exports) {\n      var once = require('once');\n\n      var noop = function noop() {};\n\n      var isRequest = function isRequest(stream) {\n        return stream.setHeader && typeof stream.abort === 'function';\n      };\n\n      var isChildProcess = function isChildProcess(stream) {\n        return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;\n      };\n\n      var eos = function eos(stream, opts, callback) {\n        if (typeof opts === 'function') return eos(stream, null, opts);\n        if (!opts) opts = {};\n\n        callback = once(callback || noop);\n\n        var ws = stream._writableState;\n        var rs = stream._readableState;\n        var readable = opts.readable || opts.readable !== false && stream.readable;\n        var writable = opts.writable || opts.writable !== false && stream.writable;\n\n        var onlegacyfinish = function onlegacyfinish() {\n          if (!stream.writable) onfinish();\n        };\n\n        var onfinish = function onfinish() {\n          writable = false;\n          if (!readable) callback.call(stream);\n        };\n\n        var onend = function onend() {\n          readable = false;\n          if (!writable) callback.call(stream);\n        };\n\n        var onexit = function onexit(exitCode) {\n          callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n        };\n\n        var onerror = function onerror(err) {\n          callback.call(stream, err);\n        };\n\n        var onclose = function onclose() {\n          if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));\n          if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));\n        };\n\n        var onrequest = function onrequest() {\n          stream.req.on('finish', onfinish);\n        };\n\n        if (isRequest(stream)) {\n          stream.on('complete', onfinish);\n          stream.on('abort', onclose);\n          if (stream.req) onrequest();else\n          stream.on('request', onrequest);\n        } else if (writable && !ws) {// legacy streams\n          stream.on('end', onlegacyfinish);\n          stream.on('close', onlegacyfinish);\n        }\n\n        if (isChildProcess(stream)) stream.on('exit', onexit);\n\n        stream.on('end', onend);\n        stream.on('finish', onfinish);\n        if (opts.error !== false) stream.on('error', onerror);\n        stream.on('close', onclose);\n\n        return function () {\n          stream.removeListener('complete', onfinish);\n          stream.removeListener('abort', onclose);\n          stream.removeListener('request', onrequest);\n          if (stream.req) stream.req.removeListener('finish', onfinish);\n          stream.removeListener('end', onlegacyfinish);\n          stream.removeListener('close', onlegacyfinish);\n          stream.removeListener('finish', onfinish);\n          stream.removeListener('exit', onexit);\n          stream.removeListener('end', onend);\n          stream.removeListener('error', onerror);\n          stream.removeListener('close', onclose);\n        };\n      };\n\n      module.exports = eos;\n\n    }, { \"once\": 90 }], 19: [function (require, module, exports) {\n      // Inspired by Google Closure:\n      // http://closure-library.googlecode.com/svn/docs/\n      // closure_goog_array_array.js.html#goog.array.clear\n\n      \"use strict\";\n\n      var value = require(\"../../object/valid-value\");\n\n      module.exports = function () {\n        value(this).length = 0;\n        return this;\n      };\n\n    }, { \"../../object/valid-value\": 55 }], 20: [function (require, module, exports) {\n      \"use strict\";\n\n      var numberIsNaN = require(\"../../number/is-nan\"),\n      toPosInt = require(\"../../number/to-pos-integer\"),\n      value = require(\"../../object/valid-value\"),\n      indexOf = Array.prototype.indexOf,\n      objHasOwnProperty = Object.prototype.hasOwnProperty,\n      abs = Math.abs,\n      floor = Math.floor;\n\n      module.exports = function (searchElement /*, fromIndex*/) {\n        var i, length, fromIndex, val;\n        if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);\n\n        length = toPosInt(value(this).length);\n        fromIndex = arguments[1];\n        if (isNaN(fromIndex)) fromIndex = 0;else\n        if (fromIndex >= 0) fromIndex = floor(fromIndex);else\n        fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n\n        for (i = fromIndex; i < length; ++i) {\n          if (objHasOwnProperty.call(this, i)) {\n            val = this[i];\n            if (numberIsNaN(val)) return i; // Jslint: ignore\n          }\n        }\n        return -1;\n      };\n\n    }, { \"../../number/is-nan\": 30, \"../../number/to-pos-integer\": 34, \"../../object/valid-value\": 55 }], 21: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Array.from :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 22, \"./shim\": 23 }], 22: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var from = Array.from,arr,result;\n        if (typeof from !== \"function\") return false;\n        arr = [\"raz\", \"dwa\"];\n        result = from(arr);\n        return Boolean(result && result !== arr && result[1] === \"dwa\");\n      };\n\n    }, {}], 23: [function (require, module, exports) {\n      \"use strict\";\n\n      var iteratorSymbol = require(\"es6-symbol\").iterator,\n      isArguments = require(\"../../function/is-arguments\"),\n      isFunction = require(\"../../function/is-function\"),\n      toPosInt = require(\"../../number/to-pos-integer\"),\n      callable = require(\"../../object/valid-callable\"),\n      validValue = require(\"../../object/valid-value\"),\n      isValue = require(\"../../object/is-value\"),\n      isString = require(\"../../string/is-string\"),\n      isArray = Array.isArray,\n      call = Function.prototype.call,\n      desc = { configurable: true, enumerable: true, writable: true, value: null },\n      defineProperty = Object.defineProperty;\n\n      // eslint-disable-next-line complexity\n      module.exports = function (arrayLike /*, mapFn, thisArg*/) {\n        var mapFn = arguments[1],\n        thisArg = arguments[2],\n        Context,\n        i,\n        j,\n        arr,\n        length,\n        code,\n        iterator,\n        result,\n        getIterator,\n        value;\n\n        arrayLike = Object(validValue(arrayLike));\n\n        if (isValue(mapFn)) callable(mapFn);\n        if (!this || this === Array || !isFunction(this)) {\n          // Result: Plain array\n          if (!mapFn) {\n            if (isArguments(arrayLike)) {\n              // Source: Arguments\n              length = arrayLike.length;\n              if (length !== 1) return Array.apply(null, arrayLike);\n              arr = new Array(1);\n              arr[0] = arrayLike[0];\n              return arr;\n            }\n            if (isArray(arrayLike)) {\n              // Source: Array\n              arr = new Array(length = arrayLike.length);\n              for (i = 0; i < length; ++i) {arr[i] = arrayLike[i];}\n              return arr;\n            }\n          }\n          arr = [];\n        } else {\n          // Result: Non plain array\n          Context = this;\n        }\n\n        if (!isArray(arrayLike)) {\n          if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {\n            // Source: Iterator\n            iterator = callable(getIterator).call(arrayLike);\n            if (Context) arr = new Context();\n            result = iterator.next();\n            i = 0;\n            while (!result.done) {\n              value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;\n              if (Context) {\n                desc.value = value;\n                defineProperty(arr, i, desc);\n              } else {\n                arr[i] = value;\n              }\n              result = iterator.next();\n              ++i;\n            }\n            length = i;\n          } else if (isString(arrayLike)) {\n            // Source: String\n            length = arrayLike.length;\n            if (Context) arr = new Context();\n            for (i = 0, j = 0; i < length; ++i) {\n              value = arrayLike[i];\n              if (i + 1 < length) {\n                code = value.charCodeAt(0);\n                // eslint-disable-next-line max-depth\n                if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];\n              }\n              value = mapFn ? call.call(mapFn, thisArg, value, j) : value;\n              if (Context) {\n                desc.value = value;\n                defineProperty(arr, j, desc);\n              } else {\n                arr[j] = value;\n              }\n              ++j;\n            }\n            length = j;\n          }\n        }\n        if (length === undefined) {\n          // Source: array or array-like\n          length = toPosInt(arrayLike.length);\n          if (Context) arr = new Context(length);\n          for (i = 0; i < length; ++i) {\n            value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];\n            if (Context) {\n              desc.value = value;\n              defineProperty(arr, i, desc);\n            } else {\n              arr[i] = value;\n            }\n          }\n        }\n        if (Context) {\n          desc.value = null;\n          arr.length = length;\n        }\n        return arr;\n      };\n\n    }, { \"../../function/is-arguments\": 24, \"../../function/is-function\": 25, \"../../number/to-pos-integer\": 34, \"../../object/is-value\": 44, \"../../object/valid-callable\": 54, \"../../object/valid-value\": 55, \"../../string/is-string\": 59, \"es6-symbol\": 73 }], 24: [function (require, module, exports) {\n      \"use strict\";\n\n      var objToString = Object.prototype.toString,\n      id = objToString.call(\n      function () {\n        return arguments;\n      }());\n\n\n      module.exports = function (value) {\n        return objToString.call(value) === id;\n      };\n\n    }, {}], 25: [function (require, module, exports) {\n      \"use strict\";\n\n      var objToString = Object.prototype.toString,id = objToString.call(require(\"./noop\"));\n\n      module.exports = function (value) {\n        return typeof value === \"function\" && objToString.call(value) === id;\n      };\n\n    }, { \"./noop\": 26 }], 26: [function (require, module, exports) {\n      \"use strict\";\n\n      // eslint-disable-next-line no-empty-function\n      module.exports = function () {};\n\n    }, {}], 27: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Math.sign :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 28, \"./shim\": 29 }], 28: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var sign = Math.sign;\n        if (typeof sign !== \"function\") return false;\n        return sign(10) === 1 && sign(-20) === -1;\n      };\n\n    }, {}], 29: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (value) {\n        value = Number(value);\n        if (isNaN(value) || value === 0) return value;\n        return value > 0 ? 1 : -1;\n      };\n\n    }, {}], 30: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Number.isNaN :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 31, \"./shim\": 32 }], 31: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var numberIsNaN = Number.isNaN;\n        if (typeof numberIsNaN !== \"function\") return false;\n        return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);\n      };\n\n    }, {}], 32: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (value) {\n        // eslint-disable-next-line no-self-compare\n        return value !== value;\n      };\n\n    }, {}], 33: [function (require, module, exports) {\n      \"use strict\";\n\n      var sign = require(\"../math/sign\"),\n\n      abs = Math.abs,floor = Math.floor;\n\n      module.exports = function (value) {\n        if (isNaN(value)) return 0;\n        value = Number(value);\n        if (value === 0 || !isFinite(value)) return value;\n        return sign(value) * floor(abs(value));\n      };\n\n    }, { \"../math/sign\": 27 }], 34: [function (require, module, exports) {\n      \"use strict\";\n\n      var toInteger = require(\"./to-integer\"),\n\n      max = Math.max;\n\n      module.exports = function (value) {\n        return max(0, toInteger(value));\n      };\n\n    }, { \"./to-integer\": 33 }], 35: [function (require, module, exports) {\n      // Internal method, used by iteration functions.\n      // Calls a function for each key-value pair found in object\n      // Optionally takes compareFn to iterate object in specific order\n\n      \"use strict\";\n\n      var callable = require(\"./valid-callable\"),\n      value = require(\"./valid-value\"),\n      bind = Function.prototype.bind,\n      call = Function.prototype.call,\n      keys = Object.keys,\n      objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n      module.exports = function (method, defVal) {\n        return function (obj, cb /*, thisArg, compareFn*/) {\n          var list,thisArg = arguments[2],compareFn = arguments[3];\n          obj = Object(value(obj));\n          callable(cb);\n\n          list = keys(obj);\n          if (compareFn) {\n            list.sort(typeof compareFn === \"function\" ? bind.call(compareFn, obj) : undefined);\n          }\n          if (typeof method !== \"function\") method = list[method];\n          return call.call(method, list, function (key, index) {\n            if (!objPropertyIsEnumerable.call(obj, key)) return defVal;\n            return call.call(cb, thisArg, obj[key], key, obj, index);\n          });\n        };\n      };\n\n    }, { \"./valid-callable\": 54, \"./valid-value\": 55 }], 36: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Object.assign :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 37, \"./shim\": 38 }], 37: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var assign = Object.assign,obj;\n        if (typeof assign !== \"function\") return false;\n        obj = { foo: \"raz\" };\n        assign(obj, { bar: \"dwa\" }, { trzy: \"trzy\" });\n        return obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n      };\n\n    }, {}], 38: [function (require, module, exports) {\n      \"use strict\";\n\n      var keys = require(\"../keys\"),\n      value = require(\"../valid-value\"),\n      max = Math.max;\n\n      module.exports = function (dest, src /*, …srcn*/) {\n        var error,i,length = max(arguments.length, 2),assign;\n        dest = Object(value(dest));\n        assign = function assign(key) {\n          try {\n            dest[key] = src[key];\n          } catch (e) {\n            if (!error) error = e;\n          }\n        };\n        for (i = 1; i < length; ++i) {\n          src = arguments[i];\n          keys(src).forEach(assign);\n        }\n        if (error !== undefined) throw error;\n        return dest;\n      };\n\n    }, { \"../keys\": 45, \"../valid-value\": 55 }], 39: [function (require, module, exports) {\n      \"use strict\";\n\n      var aFrom = require(\"../array/from\"),\n      assign = require(\"./assign\"),\n      value = require(\"./valid-value\");\n\n      module.exports = function (obj /*, propertyNames, options*/) {\n        var copy = Object(value(obj)),propertyNames = arguments[1],options = Object(arguments[2]);\n        if (copy !== obj && !propertyNames) return copy;\n        var result = {};\n        if (propertyNames) {\n          aFrom(propertyNames, function (propertyName) {\n            if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];\n          });\n        } else {\n          assign(result, obj);\n        }\n        return result;\n      };\n\n    }, { \"../array/from\": 21, \"./assign\": 36, \"./valid-value\": 55 }], 40: [function (require, module, exports) {\n      // Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n      \"use strict\";\n\n      var create = Object.create,shim;\n\n      if (!require(\"./set-prototype-of/is-implemented\")()) {\n        shim = require(\"./set-prototype-of/shim\");\n      }\n\n      module.exports = function () {\n        var nullObject, polyProps, desc;\n        if (!shim) return create;\n        if (shim.level !== 1) return create;\n\n        nullObject = {};\n        polyProps = {};\n        desc = {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: undefined };\n\n        Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n          if (name === \"__proto__\") {\n            polyProps[name] = {\n              configurable: true,\n              enumerable: false,\n              writable: true,\n              value: undefined };\n\n            return;\n          }\n          polyProps[name] = desc;\n        });\n        Object.defineProperties(nullObject, polyProps);\n\n        Object.defineProperty(shim, \"nullPolyfill\", {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: nullObject });\n\n\n        return function (prototype, props) {\n          return create(prototype === null ? nullObject : prototype, props);\n        };\n      }();\n\n    }, { \"./set-prototype-of/is-implemented\": 52, \"./set-prototype-of/shim\": 53 }], 41: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./_iterate\")(\"forEach\");\n\n    }, { \"./_iterate\": 35 }], 42: [function (require, module, exports) {\n      // Deprecated\n\n      \"use strict\";\n\n      module.exports = function (obj) {\n        return typeof obj === \"function\";\n      };\n\n    }, {}], 43: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"./is-value\");\n\n      var map = { function: true, object: true };\n\n      module.exports = function (value) {\n        return isValue(value) && map[typeof value] || false;\n      };\n\n    }, { \"./is-value\": 44 }], 44: [function (require, module, exports) {\n      \"use strict\";\n\n      var _undefined = require(\"../function/noop\")(); // Support ES3 engines\n\n      module.exports = function (val) {\n        return val !== _undefined && val !== null;\n      };\n\n    }, { \"../function/noop\": 26 }], 45: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? Object.keys : require(\"./shim\");\n\n    }, { \"./is-implemented\": 46, \"./shim\": 47 }], 46: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        try {\n          Object.keys(\"primitive\");\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n    }, {}], 47: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"../is-value\");\n\n      var keys = Object.keys;\n\n      module.exports = function (object) {return keys(isValue(object) ? Object(object) : object);};\n\n    }, { \"../is-value\": 44 }], 48: [function (require, module, exports) {\n      \"use strict\";\n\n      var callable = require(\"./valid-callable\"),\n      forEach = require(\"./for-each\"),\n      call = Function.prototype.call;\n\n      module.exports = function (obj, cb /*, thisArg*/) {\n        var result = {},thisArg = arguments[2];\n        callable(cb);\n        forEach(obj, function (value, key, targetObj, index) {\n          result[key] = call.call(cb, thisArg, value, key, targetObj, index);\n        });\n        return result;\n      };\n\n    }, { \"./for-each\": 41, \"./valid-callable\": 54 }], 49: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"./is-value\");\n\n      var forEach = Array.prototype.forEach,create = Object.create;\n\n      var process = function process(src, obj) {\n        var key;\n        for (key in src) {obj[key] = src[key];}\n      };\n\n      // eslint-disable-next-line no-unused-vars\n      module.exports = function (opts1 /*, …options*/) {\n        var result = create(null);\n        forEach.call(arguments, function (options) {\n          if (!isValue(options)) return;\n          process(Object(options), result);\n        });\n        return result;\n      };\n\n    }, { \"./is-value\": 44 }], 50: [function (require, module, exports) {\n      \"use strict\";\n\n      var forEach = Array.prototype.forEach,create = Object.create;\n\n      // eslint-disable-next-line no-unused-vars\n      module.exports = function (arg /*, …args*/) {\n        var set = create(null);\n        forEach.call(arguments, function (name) {\n          set[name] = true;\n        });\n        return set;\n      };\n\n    }, {}], 51: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      Object.setPrototypeOf :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 52, \"./shim\": 53 }], 52: [function (require, module, exports) {\n      \"use strict\";\n\n      var create = Object.create,getPrototypeOf = Object.getPrototypeOf,plainObject = {};\n\n      module.exports = function () /* CustomCreate*/{\n        var setPrototypeOf = Object.setPrototypeOf,customCreate = arguments[0] || create;\n        if (typeof setPrototypeOf !== \"function\") return false;\n        return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;\n      };\n\n    }, {}], 53: [function (require, module, exports) {\n      /* eslint no-proto: \"off\" */\n\n      // Big thanks to @WebReflection for sorting this out\n      // https://gist.github.com/WebReflection/5593554\n\n      \"use strict\";\n\n      var isObject = require(\"../is-object\"),\n      value = require(\"../valid-value\"),\n      objIsPrototypeOf = Object.prototype.isPrototypeOf,\n      defineProperty = Object.defineProperty,\n      nullDesc = {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: undefined },\n\n      validate;\n\n      validate = function validate(obj, prototype) {\n        value(obj);\n        if (prototype === null || isObject(prototype)) return obj;\n        throw new TypeError(\"Prototype must be null or an object\");\n      };\n\n      module.exports = function (status) {\n        var fn, set;\n        if (!status) return null;\n        if (status.level === 2) {\n          if (status.set) {\n            set = status.set;\n            fn = function fn(obj, prototype) {\n              set.call(validate(obj, prototype), prototype);\n              return obj;\n            };\n          } else {\n            fn = function fn(obj, prototype) {\n              validate(obj, prototype).__proto__ = prototype;\n              return obj;\n            };\n          }\n        } else {\n          fn = function self(obj, prototype) {\n            var isNullBase;\n            validate(obj, prototype);\n            isNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);\n            if (isNullBase) delete self.nullPolyfill.__proto__;\n            if (prototype === null) prototype = self.nullPolyfill;\n            obj.__proto__ = prototype;\n            if (isNullBase) defineProperty(self.nullPolyfill, \"__proto__\", nullDesc);\n            return obj;\n          };\n        }\n        return Object.defineProperty(fn, \"level\", {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: status.level });\n\n      }(\n      function () {\n        var tmpObj1 = Object.create(null),\n        tmpObj2 = {},\n        set,\n        desc = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\");\n\n        if (desc) {\n          try {\n            set = desc.set; // Opera crashes at this point\n            set.call(tmpObj1, tmpObj2);\n          } catch (ignore) {}\n          if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };\n        }\n\n        tmpObj1.__proto__ = tmpObj2;\n        if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };\n\n        tmpObj1 = {};\n        tmpObj1.__proto__ = tmpObj2;\n        if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };\n\n        return false;\n      }());\n\n\n      require(\"../create\");\n\n    }, { \"../create\": 40, \"../is-object\": 43, \"../valid-value\": 55 }], 54: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (fn) {\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        return fn;\n      };\n\n    }, {}], 55: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"./is-value\");\n\n      module.exports = function (value) {\n        if (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n        return value;\n      };\n\n    }, { \"./is-value\": 44 }], 56: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ?\n      String.prototype.contains :\n      require(\"./shim\");\n\n    }, { \"./is-implemented\": 57, \"./shim\": 58 }], 57: [function (require, module, exports) {\n      \"use strict\";\n\n      var str = \"razdwatrzy\";\n\n      module.exports = function () {\n        if (typeof str.contains !== \"function\") return false;\n        return str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n      };\n\n    }, {}], 58: [function (require, module, exports) {\n      \"use strict\";\n\n      var indexOf = String.prototype.indexOf;\n\n      module.exports = function (searchString /*, position*/) {\n        return indexOf.call(this, searchString, arguments[1]) > -1;\n      };\n\n    }, {}], 59: [function (require, module, exports) {\n      \"use strict\";\n\n      var objToString = Object.prototype.toString,id = objToString.call(\"\");\n\n      module.exports = function (value) {\n        return (\n          typeof value === \"string\" ||\n          value &&\n          typeof value === \"object\" && (\n          value instanceof String || objToString.call(value) === id) ||\n          false);\n\n      };\n\n    }, {}], 60: [function (require, module, exports) {\n      \"use strict\";\n\n      var setPrototypeOf = require(\"es5-ext/object/set-prototype-of\"),\n      contains = require(\"es5-ext/string/#/contains\"),\n      d = require(\"d\"),\n      Symbol = require(\"es6-symbol\"),\n      Iterator = require(\"./\");\n\n      var defineProperty = Object.defineProperty,ArrayIterator;\n\n      ArrayIterator = module.exports = function (arr, kind) {\n        if (!(this instanceof ArrayIterator)) throw new TypeError(\"Constructor requires 'new'\");\n        Iterator.call(this, arr);\n        if (!kind) kind = \"value\";else\n        if (contains.call(kind, \"key+value\")) kind = \"key+value\";else\n        if (contains.call(kind, \"key\")) kind = \"key\";else\n        kind = \"value\";\n        defineProperty(this, \"__kind__\", d(\"\", kind));\n      };\n      if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\n      // Internal %ArrayIteratorPrototype% doesn't expose its constructor\n      delete ArrayIterator.prototype.constructor;\n\n      ArrayIterator.prototype = Object.create(Iterator.prototype, {\n        _resolve: d(function (i) {\n          if (this.__kind__ === \"value\") return this.__list__[i];\n          if (this.__kind__ === \"key+value\") return [i, this.__list__[i]];\n          return i;\n        }) });\n\n      defineProperty(ArrayIterator.prototype, Symbol.toStringTag, d(\"c\", \"Array Iterator\"));\n\n    }, { \"./\": 63, \"d\": 16, \"es5-ext/object/set-prototype-of\": 51, \"es5-ext/string/#/contains\": 56, \"es6-symbol\": 73 }], 61: [function (require, module, exports) {\n      \"use strict\";\n\n      var isArguments = require(\"es5-ext/function/is-arguments\"),\n      callable = require(\"es5-ext/object/valid-callable\"),\n      isString = require(\"es5-ext/string/is-string\"),\n      get = require(\"./get\");\n\n      var isArray = Array.isArray,call = Function.prototype.call,some = Array.prototype.some;\n\n      module.exports = function (iterable, cb /*, thisArg*/) {\n        var mode,thisArg = arguments[2],result,doBreak,broken,i,length,_char,code;\n        if (isArray(iterable) || isArguments(iterable)) mode = \"array\";else\n        if (isString(iterable)) mode = \"string\";else\n        iterable = get(iterable);\n\n        callable(cb);\n        doBreak = function doBreak() {\n          broken = true;\n        };\n        if (mode === \"array\") {\n          some.call(iterable, function (value) {\n            call.call(cb, thisArg, value, doBreak);\n            return broken;\n          });\n          return;\n        }\n        if (mode === \"string\") {\n          length = iterable.length;\n          for (i = 0; i < length; ++i) {\n            _char = iterable[i];\n            if (i + 1 < length) {\n              code = _char.charCodeAt(0);\n              if (code >= 0xd800 && code <= 0xdbff) _char += iterable[++i];\n            }\n            call.call(cb, thisArg, _char, doBreak);\n            if (broken) break;\n          }\n          return;\n        }\n        result = iterable.next();\n\n        while (!result.done) {\n          call.call(cb, thisArg, result.value, doBreak);\n          if (broken) return;\n          result = iterable.next();\n        }\n      };\n\n    }, { \"./get\": 62, \"es5-ext/function/is-arguments\": 24, \"es5-ext/object/valid-callable\": 54, \"es5-ext/string/is-string\": 59 }], 62: [function (require, module, exports) {\n      \"use strict\";\n\n      var isArguments = require(\"es5-ext/function/is-arguments\"),\n      isString = require(\"es5-ext/string/is-string\"),\n      ArrayIterator = require(\"./array\"),\n      StringIterator = require(\"./string\"),\n      iterable = require(\"./valid-iterable\"),\n      iteratorSymbol = require(\"es6-symbol\").iterator;\n\n      module.exports = function (obj) {\n        if (typeof iterable(obj)[iteratorSymbol] === \"function\") return obj[iteratorSymbol]();\n        if (isArguments(obj)) return new ArrayIterator(obj);\n        if (isString(obj)) return new StringIterator(obj);\n        return new ArrayIterator(obj);\n      };\n\n    }, { \"./array\": 60, \"./string\": 65, \"./valid-iterable\": 66, \"es5-ext/function/is-arguments\": 24, \"es5-ext/string/is-string\": 59, \"es6-symbol\": 73 }], 63: [function (require, module, exports) {\n      \"use strict\";\n\n      var clear = require(\"es5-ext/array/#/clear\"),\n      assign = require(\"es5-ext/object/assign\"),\n      callable = require(\"es5-ext/object/valid-callable\"),\n      value = require(\"es5-ext/object/valid-value\"),\n      d = require(\"d\"),\n      autoBind = require(\"d/auto-bind\"),\n      Symbol = require(\"es6-symbol\");\n\n      var defineProperty = Object.defineProperty,defineProperties = Object.defineProperties,_Iterator;\n\n      module.exports = _Iterator = function Iterator(list, context) {\n        if (!(this instanceof _Iterator)) throw new TypeError(\"Constructor requires 'new'\");\n        defineProperties(this, {\n          __list__: d(\"w\", value(list)),\n          __context__: d(\"w\", context),\n          __nextIndex__: d(\"w\", 0) });\n\n        if (!context) return;\n        callable(context.on);\n        context.on(\"_add\", this._onAdd);\n        context.on(\"_delete\", this._onDelete);\n        context.on(\"_clear\", this._onClear);\n      };\n\n      // Internal %IteratorPrototype% doesn't expose its constructor\n      delete _Iterator.prototype.constructor;\n\n      defineProperties(\n      _Iterator.prototype,\n      assign(\n      {\n        _next: d(function () {\n          var i;\n          if (!this.__list__) return undefined;\n          if (this.__redo__) {\n            i = this.__redo__.shift();\n            if (i !== undefined) return i;\n          }\n          if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n          this._unBind();\n          return undefined;\n        }),\n        next: d(function () {\n          return this._createResult(this._next());\n        }),\n        _createResult: d(function (i) {\n          if (i === undefined) return { done: true, value: undefined };\n          return { done: false, value: this._resolve(i) };\n        }),\n        _resolve: d(function (i) {\n          return this.__list__[i];\n        }),\n        _unBind: d(function () {\n          this.__list__ = null;\n          delete this.__redo__;\n          if (!this.__context__) return;\n          this.__context__.off(\"_add\", this._onAdd);\n          this.__context__.off(\"_delete\", this._onDelete);\n          this.__context__.off(\"_clear\", this._onClear);\n          this.__context__ = null;\n        }),\n        toString: d(function () {\n          return \"[object \" + (this[Symbol.toStringTag] || \"Object\") + \"]\";\n        }) },\n\n      autoBind({\n        _onAdd: d(function (index) {\n          if (index >= this.__nextIndex__) return;\n          ++this.__nextIndex__;\n          if (!this.__redo__) {\n            defineProperty(this, \"__redo__\", d(\"c\", [index]));\n            return;\n          }\n          this.__redo__.forEach(function (redo, i) {\n            if (redo >= index) this.__redo__[i] = ++redo;\n          }, this);\n          this.__redo__.push(index);\n        }),\n        _onDelete: d(function (index) {\n          var i;\n          if (index >= this.__nextIndex__) return;\n          --this.__nextIndex__;\n          if (!this.__redo__) return;\n          i = this.__redo__.indexOf(index);\n          if (i !== -1) this.__redo__.splice(i, 1);\n          this.__redo__.forEach(function (redo, j) {\n            if (redo > index) this.__redo__[j] = --redo;\n          }, this);\n        }),\n        _onClear: d(function () {\n          if (this.__redo__) clear.call(this.__redo__);\n          this.__nextIndex__ = 0;\n        }) })));\n\n\n\n\n      defineProperty(\n      _Iterator.prototype,\n      Symbol.iterator,\n      d(function () {\n        return this;\n      }));\n\n\n    }, { \"d\": 16, \"d/auto-bind\": 15, \"es5-ext/array/#/clear\": 19, \"es5-ext/object/assign\": 36, \"es5-ext/object/valid-callable\": 54, \"es5-ext/object/valid-value\": 55, \"es6-symbol\": 73 }], 64: [function (require, module, exports) {\n      \"use strict\";\n\n      var isArguments = require(\"es5-ext/function/is-arguments\"),\n      isValue = require(\"es5-ext/object/is-value\"),\n      isString = require(\"es5-ext/string/is-string\");\n\n      var iteratorSymbol = require(\"es6-symbol\").iterator,\n      isArray = Array.isArray;\n\n      module.exports = function (value) {\n        if (!isValue(value)) return false;\n        if (isArray(value)) return true;\n        if (isString(value)) return true;\n        if (isArguments(value)) return true;\n        return typeof value[iteratorSymbol] === \"function\";\n      };\n\n    }, { \"es5-ext/function/is-arguments\": 24, \"es5-ext/object/is-value\": 44, \"es5-ext/string/is-string\": 59, \"es6-symbol\": 73 }], 65: [function (require, module, exports) {\n      // Thanks @mathiasbynens\n      // http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n      \"use strict\";\n\n      var setPrototypeOf = require(\"es5-ext/object/set-prototype-of\"),\n      d = require(\"d\"),\n      Symbol = require(\"es6-symbol\"),\n      Iterator = require(\"./\");\n\n      var defineProperty = Object.defineProperty,StringIterator;\n\n      StringIterator = module.exports = function (str) {\n        if (!(this instanceof StringIterator)) throw new TypeError(\"Constructor requires 'new'\");\n        str = String(str);\n        Iterator.call(this, str);\n        defineProperty(this, \"__length__\", d(\"\", str.length));\n      };\n      if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\n      // Internal %ArrayIteratorPrototype% doesn't expose its constructor\n      delete StringIterator.prototype.constructor;\n\n      StringIterator.prototype = Object.create(Iterator.prototype, {\n        _next: d(function () {\n          if (!this.__list__) return undefined;\n          if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n          this._unBind();\n          return undefined;\n        }),\n        _resolve: d(function (i) {\n          var _char2 = this.__list__[i],code;\n          if (this.__nextIndex__ === this.__length__) return _char2;\n          code = _char2.charCodeAt(0);\n          if (code >= 0xd800 && code <= 0xdbff) return _char2 + this.__list__[this.__nextIndex__++];\n          return _char2;\n        }) });\n\n      defineProperty(StringIterator.prototype, Symbol.toStringTag, d(\"c\", \"String Iterator\"));\n\n    }, { \"./\": 63, \"d\": 16, \"es5-ext/object/set-prototype-of\": 51, \"es6-symbol\": 73 }], 66: [function (require, module, exports) {\n      \"use strict\";\n\n      var isIterable = require(\"./is-iterable\");\n\n      module.exports = function (value) {\n        if (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n        return value;\n      };\n\n    }, { \"./is-iterable\": 64 }], 67: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('./is-implemented')() ? Map : require('./polyfill');\n\n    }, { \"./is-implemented\": 68, \"./polyfill\": 72 }], 68: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = function () {\n        var map, iterator, result;\n        if (typeof Map !== 'function') return false;\n        try {\n          // WebKit doesn't support arguments and crashes\n          map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);\n        } catch (e) {\n          return false;\n        }\n        if (String(map) !== '[object Map]') return false;\n        if (map.size !== 3) return false;\n        if (typeof map.clear !== 'function') return false;\n        if (typeof map.delete !== 'function') return false;\n        if (typeof map.entries !== 'function') return false;\n        if (typeof map.forEach !== 'function') return false;\n        if (typeof map.get !== 'function') return false;\n        if (typeof map.has !== 'function') return false;\n        if (typeof map.keys !== 'function') return false;\n        if (typeof map.set !== 'function') return false;\n        if (typeof map.values !== 'function') return false;\n\n        iterator = map.entries();\n        result = iterator.next();\n        if (result.done !== false) return false;\n        if (!result.value) return false;\n        if (result.value[0] !== 'raz') return false;\n        if (result.value[1] !== 'one') return false;\n\n        return true;\n      };\n\n    }, {}], 69: [function (require, module, exports) {\n      // Exports true if environment provides native `Map` implementation,\n      // whatever that is.\n\n      'use strict';\n\n      module.exports = function () {\n        if (typeof Map === 'undefined') return false;\n        return Object.prototype.toString.call(new Map()) === '[object Map]';\n      }();\n\n    }, {}], 70: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('es5-ext/object/primitive-set')('key',\n      'value', 'key+value');\n\n    }, { \"es5-ext/object/primitive-set\": 50 }], 71: [function (require, module, exports) {\n      'use strict';\n\n      var setPrototypeOf = require('es5-ext/object/set-prototype-of'),\n      d = require('d'),\n      Iterator = require('es6-iterator'),\n      toStringTagSymbol = require('es6-symbol').toStringTag,\n      kinds = require('./iterator-kinds'),\n\n      defineProperties = Object.defineProperties,\n      unBind = Iterator.prototype._unBind,\n      MapIterator;\n\n      MapIterator = module.exports = function (map, kind) {\n        if (!(this instanceof MapIterator)) return new MapIterator(map, kind);\n        Iterator.call(this, map.__mapKeysData__, map);\n        if (!kind || !kinds[kind]) kind = 'key+value';\n        defineProperties(this, {\n          __kind__: d('', kind),\n          __values__: d('w', map.__mapValuesData__) });\n\n      };\n      if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);\n\n      MapIterator.prototype = Object.create(Iterator.prototype, {\n        constructor: d(MapIterator),\n        _resolve: d(function (i) {\n          if (this.__kind__ === 'value') return this.__values__[i];\n          if (this.__kind__ === 'key') return this.__list__[i];\n          return [this.__list__[i], this.__values__[i]];\n        }),\n        _unBind: d(function () {\n          this.__values__ = null;\n          unBind.call(this);\n        }),\n        toString: d(function () {return '[object Map Iterator]';}) });\n\n      Object.defineProperty(MapIterator.prototype, toStringTagSymbol,\n      d('c', 'Map Iterator'));\n\n    }, { \"./iterator-kinds\": 70, \"d\": 16, \"es5-ext/object/set-prototype-of\": 51, \"es6-iterator\": 63, \"es6-symbol\": 73 }], 72: [function (require, module, exports) {\n      'use strict';\n\n      var clear = require('es5-ext/array/#/clear'),\n      eIndexOf = require('es5-ext/array/#/e-index-of'),\n      setPrototypeOf = require('es5-ext/object/set-prototype-of'),\n      callable = require('es5-ext/object/valid-callable'),\n      validValue = require('es5-ext/object/valid-value'),\n      d = require('d'),\n      ee = require('event-emitter'),\n      Symbol = require('es6-symbol'),\n      iterator = require('es6-iterator/valid-iterable'),\n      forOf = require('es6-iterator/for-of'),\n      Iterator = require('./lib/iterator'),\n      isNative = require('./is-native-implemented'),\n\n      call = Function.prototype.call,\n      defineProperties = Object.defineProperties,getPrototypeOf = Object.getPrototypeOf,\n      _MapPoly;\n\n      module.exports = _MapPoly = function MapPoly() /*iterable*/{\n        var iterable = arguments[0],keys,values,self;\n        if (!(this instanceof _MapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n        if (isNative && setPrototypeOf && Map !== _MapPoly) {\n          self = setPrototypeOf(new Map(), getPrototypeOf(this));\n        } else {\n          self = this;\n        }\n        if (iterable != null) iterator(iterable);\n        defineProperties(self, {\n          __mapKeysData__: d('c', keys = []),\n          __mapValuesData__: d('c', values = []) });\n\n        if (!iterable) return self;\n        forOf(iterable, function (value) {\n          var key = validValue(value)[0];\n          value = value[1];\n          if (eIndexOf.call(keys, key) !== -1) return;\n          keys.push(key);\n          values.push(value);\n        }, self);\n        return self;\n      };\n\n      if (isNative) {\n        if (setPrototypeOf) setPrototypeOf(_MapPoly, Map);\n        _MapPoly.prototype = Object.create(Map.prototype, {\n          constructor: d(_MapPoly) });\n\n      }\n\n      ee(defineProperties(_MapPoly.prototype, {\n        clear: d(function () {\n          if (!this.__mapKeysData__.length) return;\n          clear.call(this.__mapKeysData__);\n          clear.call(this.__mapValuesData__);\n          this.emit('_clear');\n        }),\n        delete: d(function (key) {\n          var index = eIndexOf.call(this.__mapKeysData__, key);\n          if (index === -1) return false;\n          this.__mapKeysData__.splice(index, 1);\n          this.__mapValuesData__.splice(index, 1);\n          this.emit('_delete', index, key);\n          return true;\n        }),\n        entries: d(function () {return new Iterator(this, 'key+value');}),\n        forEach: d(function (cb /*, thisArg*/) {\n          var thisArg = arguments[1],iterator,result;\n          callable(cb);\n          iterator = this.entries();\n          result = iterator._next();\n          while (result !== undefined) {\n            call.call(cb, thisArg, this.__mapValuesData__[result],\n            this.__mapKeysData__[result], this);\n            result = iterator._next();\n          }\n        }),\n        get: d(function (key) {\n          var index = eIndexOf.call(this.__mapKeysData__, key);\n          if (index === -1) return;\n          return this.__mapValuesData__[index];\n        }),\n        has: d(function (key) {\n          return eIndexOf.call(this.__mapKeysData__, key) !== -1;\n        }),\n        keys: d(function () {return new Iterator(this, 'key');}),\n        set: d(function (key, value) {\n          var index = eIndexOf.call(this.__mapKeysData__, key),emit;\n          if (index === -1) {\n            index = this.__mapKeysData__.push(key) - 1;\n            emit = true;\n          }\n          this.__mapValuesData__[index] = value;\n          if (emit) this.emit('_add', index, key);\n          return this;\n        }),\n        size: d.gs(function () {return this.__mapKeysData__.length;}),\n        values: d(function () {return new Iterator(this, 'value');}),\n        toString: d(function () {return '[object Map]';}) }));\n\n      Object.defineProperty(_MapPoly.prototype, Symbol.iterator, d(function () {\n        return this.entries();\n      }));\n      Object.defineProperty(_MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));\n\n    }, { \"./is-native-implemented\": 69, \"./lib/iterator\": 71, \"d\": 16, \"es5-ext/array/#/clear\": 19, \"es5-ext/array/#/e-index-of\": 20, \"es5-ext/object/set-prototype-of\": 51, \"es5-ext/object/valid-callable\": 54, \"es5-ext/object/valid-value\": 55, \"es6-iterator/for-of\": 61, \"es6-iterator/valid-iterable\": 66, \"es6-symbol\": 73, \"event-emitter\": 78 }], 73: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('./is-implemented')() ? Symbol : require('./polyfill');\n\n    }, { \"./is-implemented\": 74, \"./polyfill\": 76 }], 74: [function (require, module, exports) {\n      'use strict';\n\n      var validTypes = { object: true, symbol: true };\n\n      module.exports = function () {\n        var symbol;\n        if (typeof Symbol !== 'function') return false;\n        symbol = Symbol('test symbol');\n        try {String(symbol);} catch (e) {return false;}\n\n        // Return 'true' also for polyfills\n        if (!validTypes[typeof Symbol.iterator]) return false;\n        if (!validTypes[typeof Symbol.toPrimitive]) return false;\n        if (!validTypes[typeof Symbol.toStringTag]) return false;\n\n        return true;\n      };\n\n    }, {}], 75: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = function (x) {\n        if (!x) return false;\n        if (typeof x === 'symbol') return true;\n        if (!x.constructor) return false;\n        if (x.constructor.name !== 'Symbol') return false;\n        return x[x.constructor.toStringTag] === 'Symbol';\n      };\n\n    }, {}], 76: [function (require, module, exports) {\n      // ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n      'use strict';\n\n      var d = require('d'),\n      validateSymbol = require('./validate-symbol'),\n\n      create = Object.create,defineProperties = Object.defineProperties,\n      defineProperty = Object.defineProperty,objPrototype = Object.prototype,\n      NativeSymbol,SymbolPolyfill,HiddenSymbol,globalSymbols = create(null),\n      isNativeSafe;\n\n      if (typeof Symbol === 'function') {\n        NativeSymbol = Symbol;\n        try {\n          String(NativeSymbol());\n          isNativeSafe = true;\n        } catch (ignore) {}\n      }\n\n      var generateName = function () {\n        var created = create(null);\n        return function (desc) {\n          var postfix = 0,name,ie11BugWorkaround;\n          while (created[desc + (postfix || '')]) {++postfix;}\n          desc += postfix || '';\n          created[desc] = true;\n          name = '@@' + desc;\n          defineProperty(objPrototype, name, d.gs(null, function (value) {\n            // For IE11 issue see:\n            // https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n            //    ie11-broken-getters-on-dom-objects\n            // https://github.com/medikoo/es6-symbol/issues/12\n            if (ie11BugWorkaround) return;\n            ie11BugWorkaround = true;\n            defineProperty(this, name, d(value));\n            ie11BugWorkaround = false;\n          }));\n          return name;\n        };\n      }();\n\n      // Internal constructor (not one exposed) for creating Symbol instances.\n      // This one is used to ensure that `someSymbol instanceof Symbol` always return false\n      HiddenSymbol = function Symbol(description) {\n        if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');\n        return SymbolPolyfill(description);\n      };\n\n      // Exposed `Symbol` constructor\n      // (returns instances of HiddenSymbol)\n      module.exports = SymbolPolyfill = function Symbol(description) {\n        var symbol;\n        if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');\n        if (isNativeSafe) return NativeSymbol(description);\n        symbol = create(HiddenSymbol.prototype);\n        description = description === undefined ? '' : String(description);\n        return defineProperties(symbol, {\n          __description__: d('', description),\n          __name__: d('', generateName(description)) });\n\n      };\n      defineProperties(SymbolPolyfill, {\n        for: d(function (key) {\n          if (globalSymbols[key]) return globalSymbols[key];\n          return globalSymbols[key] = SymbolPolyfill(String(key));\n        }),\n        keyFor: d(function (s) {\n          var key;\n          validateSymbol(s);\n          for (key in globalSymbols) {if (globalSymbols[key] === s) return key;}\n        }),\n\n        // To ensure proper interoperability with other native functions (e.g. Array.from)\n        // fallback to eventual native implementation of given symbol\n        hasInstance: d('', NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill('hasInstance')),\n        isConcatSpreadable: d('', NativeSymbol && NativeSymbol.isConcatSpreadable ||\n        SymbolPolyfill('isConcatSpreadable')),\n        iterator: d('', NativeSymbol && NativeSymbol.iterator || SymbolPolyfill('iterator')),\n        match: d('', NativeSymbol && NativeSymbol.match || SymbolPolyfill('match')),\n        replace: d('', NativeSymbol && NativeSymbol.replace || SymbolPolyfill('replace')),\n        search: d('', NativeSymbol && NativeSymbol.search || SymbolPolyfill('search')),\n        species: d('', NativeSymbol && NativeSymbol.species || SymbolPolyfill('species')),\n        split: d('', NativeSymbol && NativeSymbol.split || SymbolPolyfill('split')),\n        toPrimitive: d('', NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill('toPrimitive')),\n        toStringTag: d('', NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill('toStringTag')),\n        unscopables: d('', NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill('unscopables')) });\n\n\n      // Internal tweaks for real symbol producer\n      defineProperties(HiddenSymbol.prototype, {\n        constructor: d(SymbolPolyfill),\n        toString: d('', function () {return this.__name__;}) });\n\n\n      // Proper implementation of methods exposed on Symbol.prototype\n      // They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\n      defineProperties(SymbolPolyfill.prototype, {\n        toString: d(function () {return 'Symbol (' + validateSymbol(this).__description__ + ')';}),\n        valueOf: d(function () {return validateSymbol(this);}) });\n\n      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {\n        var symbol = validateSymbol(this);\n        if (typeof symbol === 'symbol') return symbol;\n        return symbol.toString();\n      }));\n      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));\n\n      // Proper implementaton of toPrimitive and toStringTag for returned symbol instances\n      defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n      d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));\n\n      // Note: It's important to define `toPrimitive` as last one, as some implementations\n      // implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n      // And that may invoke error in definition flow:\n      // See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\n      defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n      d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));\n\n    }, { \"./validate-symbol\": 77, \"d\": 16 }], 77: [function (require, module, exports) {\n      'use strict';\n\n      var isSymbol = require('./is-symbol');\n\n      module.exports = function (value) {\n        if (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n        return value;\n      };\n\n    }, { \"./is-symbol\": 75 }], 78: [function (require, module, exports) {\n      'use strict';\n\n      var d = require('d'),\n      callable = require('es5-ext/object/valid-callable'),\n\n      apply = Function.prototype.apply,call = Function.prototype.call,\n      create = Object.create,defineProperty = Object.defineProperty,\n      defineProperties = Object.defineProperties,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      descriptor = { configurable: true, enumerable: false, writable: true },\n\n      on,_once2,off,emit,methods,descriptors,base;\n\n      on = function on(type, listener) {\n        var data;\n\n        callable(listener);\n\n        if (!hasOwnProperty.call(this, '__ee__')) {\n          data = descriptor.value = create(null);\n          defineProperty(this, '__ee__', descriptor);\n          descriptor.value = null;\n        } else {\n          data = this.__ee__;\n        }\n        if (!data[type]) data[type] = listener;else\n        if (typeof data[type] === 'object') data[type].push(listener);else\n        data[type] = [data[type], listener];\n\n        return this;\n      };\n\n      _once2 = function once(type, listener) {\n        var _once, self;\n\n        callable(listener);\n        self = this;\n        on.call(this, type, _once = function once() {\n          off.call(self, type, _once);\n          apply.call(listener, this, arguments);\n        });\n\n        _once.__eeOnceListener__ = listener;\n        return this;\n      };\n\n      off = function off(type, listener) {\n        var data, listeners, candidate, i;\n\n        callable(listener);\n\n        if (!hasOwnProperty.call(this, '__ee__')) return this;\n        data = this.__ee__;\n        if (!data[type]) return this;\n        listeners = data[type];\n\n        if (typeof listeners === 'object') {\n          for (i = 0; candidate = listeners[i]; ++i) {\n            if (candidate === listener ||\n            candidate.__eeOnceListener__ === listener) {\n              if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];else\n              listeners.splice(i, 1);\n            }\n          }\n        } else {\n          if (listeners === listener ||\n          listeners.__eeOnceListener__ === listener) {\n            delete data[type];\n          }\n        }\n\n        return this;\n      };\n\n      emit = function emit(type) {\n        var i, l, listener, listeners, args;\n\n        if (!hasOwnProperty.call(this, '__ee__')) return;\n        listeners = this.__ee__[type];\n        if (!listeners) return;\n\n        if (typeof listeners === 'object') {\n          l = arguments.length;\n          args = new Array(l - 1);\n          for (i = 1; i < l; ++i) {args[i - 1] = arguments[i];}\n\n          listeners = listeners.slice();\n          for (i = 0; listener = listeners[i]; ++i) {\n            apply.call(listener, this, args);\n          }\n        } else {\n          switch (arguments.length) {\n            case 1:\n              call.call(listeners, this);\n              break;\n            case 2:\n              call.call(listeners, this, arguments[1]);\n              break;\n            case 3:\n              call.call(listeners, this, arguments[1], arguments[2]);\n              break;\n            default:\n              l = arguments.length;\n              args = new Array(l - 1);\n              for (i = 1; i < l; ++i) {\n                args[i - 1] = arguments[i];\n              }\n              apply.call(listeners, this, args);}\n\n        }\n      };\n\n      methods = {\n        on: on,\n        once: _once2,\n        off: off,\n        emit: emit };\n\n\n      descriptors = {\n        on: d(on),\n        once: d(_once2),\n        off: d(off),\n        emit: d(emit) };\n\n\n      base = defineProperties({}, descriptors);\n\n      module.exports = exports = function exports(o) {\n        return o == null ? create(base) : defineProperties(Object(o), descriptors);\n      };\n      exports.methods = methods;\n\n    }, { \"d\": 16, \"es5-ext/object/valid-callable\": 54 }], 79: [function (require, module, exports) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n\n        i += d;\n\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n\n    }, {}], 80: [function (require, module, exports) {\n      if (typeof Object.create === 'function') {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n          ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n              value: ctor,\n              enumerable: false,\n              writable: true,\n              configurable: true } });\n\n\n        };\n      } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n          var TempCtor = function TempCtor() {};\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        };\n      }\n\n    }, {}], 81: [function (require, module, exports) {\n      /*!\n                                                       * Determine if an object is a Buffer\n                                                       *\n                                                       * @author   Feross Aboukhadijeh <https://feross.org>\n                                                       * @license  MIT\n                                                       */\n\n      // The _isBuffer check is for Safari 5-7 support, because it's missing\n      // Object.prototype.constructor. Remove this eventually\n      module.exports = function (obj) {\n        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n      };\n\n      function isBuffer(obj) {\n        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n      }\n\n      // For Node v0.10 support. Remove this eventually.\n      function isSlowBuffer(obj) {\n        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n      }\n\n    }, {}], 82: [function (require, module, exports) {\n      'use strict';\n\n      var Buffer = require('safe-buffer').Buffer;\n\n      /* Protocol - protocol constants */\n      var protocol = module.exports;\n\n      /* Command code => mnemonic */\n      protocol.types = {\n        0: 'reserved',\n        1: 'connect',\n        2: 'connack',\n        3: 'publish',\n        4: 'puback',\n        5: 'pubrec',\n        6: 'pubrel',\n        7: 'pubcomp',\n        8: 'subscribe',\n        9: 'suback',\n        10: 'unsubscribe',\n        11: 'unsuback',\n        12: 'pingreq',\n        13: 'pingresp',\n        14: 'disconnect',\n        15: 'auth' };\n\n\n      /* Mnemonic => Command code */\n      protocol.codes = {};\n      for (var k in protocol.types) {\n        var v = protocol.types[k];\n        protocol.codes[v] = k;\n      }\n\n      /* Header */\n      protocol.CMD_SHIFT = 4;\n      protocol.CMD_MASK = 0xF0;\n      protocol.DUP_MASK = 0x08;\n      protocol.QOS_MASK = 0x03;\n      protocol.QOS_SHIFT = 1;\n      protocol.RETAIN_MASK = 0x01;\n\n      /* Length */\n      protocol.LENGTH_MASK = 0x7F;\n      protocol.LENGTH_FIN_MASK = 0x80;\n\n      /* Connack */\n      protocol.SESSIONPRESENT_MASK = 0x01;\n      protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK]);\n      protocol.CONNACK_HEADER = Buffer.from([protocol.codes['connack'] << protocol.CMD_SHIFT]);\n\n      /* Connect */\n      protocol.USERNAME_MASK = 0x80;\n      protocol.PASSWORD_MASK = 0x40;\n      protocol.WILL_RETAIN_MASK = 0x20;\n      protocol.WILL_QOS_MASK = 0x18;\n      protocol.WILL_QOS_SHIFT = 3;\n      protocol.WILL_FLAG_MASK = 0x04;\n      protocol.CLEAN_SESSION_MASK = 0x02;\n      protocol.CONNECT_HEADER = Buffer.from([protocol.codes['connect'] << protocol.CMD_SHIFT]);\n\n      /* Properties */\n      protocol.properties = {\n        sessionExpiryInterval: 17,\n        willDelayInterval: 24,\n        receiveMaximum: 33,\n        maximumPacketSize: 39,\n        topicAliasMaximum: 34,\n        requestResponseInformation: 25,\n        requestProblemInformation: 23,\n        userProperties: 38,\n        authenticationMethod: 21,\n        authenticationData: 22,\n        payloadFormatIndicator: 1,\n        messageExpiryInterval: 2,\n        contentType: 3,\n        responseTopic: 8,\n        correlationData: 9,\n        maximumQoS: 36,\n        retainAvailable: 37,\n        assignedClientIdentifier: 18,\n        reasonString: 31,\n        wildcardSubscriptionAvailable: 40,\n        subscriptionIdentifiersAvailable: 41,\n        sharedSubscriptionAvailable: 42,\n        serverKeepAlive: 19,\n        responseInformation: 26,\n        serverReference: 28,\n        topicAlias: 35,\n        subscriptionIdentifier: 11 };\n\n      protocol.propertiesCodes = {};\n      for (var prop in protocol.properties) {\n        var id = protocol.properties[prop];\n        protocol.propertiesCodes[id] = prop;\n      }\n      protocol.propertiesTypes = {\n        sessionExpiryInterval: 'int32',\n        willDelayInterval: 'int32',\n        receiveMaximum: 'int16',\n        maximumPacketSize: 'int32',\n        topicAliasMaximum: 'int16',\n        requestResponseInformation: 'byte',\n        requestProblemInformation: 'byte',\n        userProperties: 'pair',\n        authenticationMethod: 'string',\n        authenticationData: 'binary',\n        payloadFormatIndicator: 'byte',\n        messageExpiryInterval: 'int32',\n        contentType: 'string',\n        responseTopic: 'string',\n        correlationData: 'binary',\n        maximumQoS: 'int8',\n        retainAvailable: 'byte',\n        assignedClientIdentifier: 'string',\n        reasonString: 'string',\n        wildcardSubscriptionAvailable: 'byte',\n        subscriptionIdentifiersAvailable: 'byte',\n        sharedSubscriptionAvailable: 'byte',\n        serverKeepAlive: 'int32',\n        responseInformation: 'string',\n        serverReference: 'string',\n        topicAlias: 'int16',\n        subscriptionIdentifier: 'var' };\n\n\n      function genHeader(type) {\n        return [0, 1, 2].map(function (qos) {\n          return [0, 1].map(function (dup) {\n            return [0, 1].map(function (retain) {\n              var buf = new Buffer(1);\n              buf.writeUInt8(\n              protocol.codes[type] << protocol.CMD_SHIFT | (\n              dup ? protocol.DUP_MASK : 0) |\n              qos << protocol.QOS_SHIFT | retain, 0, true);\n              return buf;\n            });\n          });\n        });\n      }\n\n      /* Publish */\n      protocol.PUBLISH_HEADER = genHeader('publish');\n\n      /* Subscribe */\n      protocol.SUBSCRIBE_HEADER = genHeader('subscribe');\n      protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03;\n      protocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01;\n      protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;\n      protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01;\n      protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;\n      protocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03;\n      protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;\n      protocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20];\n      protocol.SUBSCRIBE_OPTIONS_NL = 0x04;\n      protocol.SUBSCRIBE_OPTIONS_RAP = 0x08;\n      protocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02];\n\n      /* Unsubscribe */\n      protocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe');\n\n      /* Confirmations */\n      protocol.ACKS = {\n        unsuback: genHeader('unsuback'),\n        puback: genHeader('puback'),\n        pubcomp: genHeader('pubcomp'),\n        pubrel: genHeader('pubrel'),\n        pubrec: genHeader('pubrec') };\n\n\n      protocol.SUBACK_HEADER = Buffer.from([protocol.codes['suback'] << protocol.CMD_SHIFT]);\n\n      /* Protocol versions */\n      protocol.VERSION3 = Buffer.from([3]);\n      protocol.VERSION4 = Buffer.from([4]);\n      protocol.VERSION5 = Buffer.from([5]);\n\n      /* QoS */\n      protocol.QOS = [0, 1, 2].map(function (qos) {\n        return Buffer.from([qos]);\n      });\n\n      /* Empty packets */\n      protocol.EMPTY = {\n        pingreq: Buffer.from([protocol.codes['pingreq'] << 4, 0]),\n        pingresp: Buffer.from([protocol.codes['pingresp'] << 4, 0]),\n        disconnect: Buffer.from([protocol.codes['disconnect'] << 4, 0]) };\n\n\n    }, { \"safe-buffer\": 110 }], 83: [function (require, module, exports) {\n      'use strict';\n\n      var Buffer = require('safe-buffer').Buffer;\n      var writeToStream = require('./writeToStream');\n      var EE = require('events').EventEmitter;\n      var inherits = require('inherits');\n\n      function generate(packet, opts) {\n        var stream = new Accumulator();\n        writeToStream(packet, stream, opts);\n        return stream.concat();\n      }\n\n      function Accumulator() {\n        this._array = new Array(20);\n        this._i = 0;\n      }\n\n      inherits(Accumulator, EE);\n\n      Accumulator.prototype.write = function (chunk) {\n        this._array[this._i++] = chunk;\n        return true;\n      };\n\n      Accumulator.prototype.concat = function () {\n        var length = 0;\n        var lengths = new Array(this._array.length);\n        var list = this._array;\n        var pos = 0;\n        var i;\n        var result;\n\n        for (i = 0; i < list.length && list[i] !== undefined; i++) {\n          if (typeof list[i] !== 'string') lengths[i] = list[i].length;else\n          lengths[i] = Buffer.byteLength(list[i]);\n\n          length += lengths[i];\n        }\n\n        result = Buffer.allocUnsafe(length);\n\n        for (i = 0; i < list.length && list[i] !== undefined; i++) {\n          if (typeof list[i] !== 'string') {\n            list[i].copy(result, pos);\n            pos += lengths[i];\n          } else {\n            result.write(list[i], pos);\n            pos += lengths[i];\n          }\n        }\n\n        return result;\n      };\n\n      module.exports = generate;\n\n    }, { \"./writeToStream\": 89, \"events\": 13, \"inherits\": 80, \"safe-buffer\": 110 }], 84: [function (require, module, exports) {\n      'use strict';\n\n      exports.parser = require('./parser');\n      exports.generate = require('./generate');\n      exports.writeToStream = require('./writeToStream');\n\n    }, { \"./generate\": 83, \"./parser\": 88, \"./writeToStream\": 89 }], 85: [function (require, module, exports) {\n      var DuplexStream = require('readable-stream/duplex'),\n      util = require('util'),\n      Buffer = require('safe-buffer').Buffer;\n\n\n      function BufferList(callback) {\n        if (!(this instanceof BufferList))\n        return new BufferList(callback);\n\n        this._bufs = [];\n        this.length = 0;\n\n        if (typeof callback == 'function') {\n          this._callback = callback;\n\n          var piper = function piper(err) {\n            if (this._callback) {\n              this._callback(err);\n              this._callback = null;\n            }\n          }.bind(this);\n\n          this.on('pipe', function onPipe(src) {\n            src.on('error', piper);\n          });\n          this.on('unpipe', function onUnpipe(src) {\n            src.removeListener('error', piper);\n          });\n        } else {\n          this.append(callback);\n        }\n\n        DuplexStream.call(this);\n      }\n\n\n      util.inherits(BufferList, DuplexStream);\n\n\n      BufferList.prototype._offset = function _offset(offset) {\n        var tot = 0,i = 0,_t;\n        if (offset === 0) return [0, 0];\n        for (; i < this._bufs.length; i++) {\n          _t = tot + this._bufs[i].length;\n          if (offset < _t || i == this._bufs.length - 1)\n          return [i, offset - tot];\n          tot = _t;\n        }\n      };\n\n\n      BufferList.prototype.append = function append(buf) {\n        var i = 0;\n\n        if (Buffer.isBuffer(buf)) {\n          this._appendBuffer(buf);\n        } else if (Array.isArray(buf)) {\n          for (; i < buf.length; i++) {\n            this.append(buf[i]);}\n        } else if (buf instanceof BufferList) {\n          // unwrap argument into individual BufferLists\n          for (; i < buf._bufs.length; i++) {\n            this.append(buf._bufs[i]);}\n        } else if (buf != null) {\n          // coerce number arguments to strings, since Buffer(number) does\n          // uninitialized memory allocation\n          if (typeof buf == 'number')\n          buf = buf.toString();\n\n          this._appendBuffer(Buffer.from(buf));\n        }\n\n        return this;\n      };\n\n\n      BufferList.prototype._appendBuffer = function appendBuffer(buf) {\n        this._bufs.push(buf);\n        this.length += buf.length;\n      };\n\n\n      BufferList.prototype._write = function _write(buf, encoding, callback) {\n        this._appendBuffer(buf);\n\n        if (typeof callback == 'function')\n        callback();\n      };\n\n\n      BufferList.prototype._read = function _read(size) {\n        if (!this.length)\n        return this.push(null);\n\n        size = Math.min(size, this.length);\n        this.push(this.slice(0, size));\n        this.consume(size);\n      };\n\n\n      BufferList.prototype.end = function end(chunk) {\n        DuplexStream.prototype.end.call(this, chunk);\n\n        if (this._callback) {\n          this._callback(null, this.slice());\n          this._callback = null;\n        }\n      };\n\n\n      BufferList.prototype.get = function get(index) {\n        return this.slice(index, index + 1)[0];\n      };\n\n\n      BufferList.prototype.slice = function slice(start, end) {\n        if (typeof start == 'number' && start < 0)\n        start += this.length;\n        if (typeof end == 'number' && end < 0)\n        end += this.length;\n        return this.copy(null, 0, start, end);\n      };\n\n\n      BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {\n        if (typeof srcStart != 'number' || srcStart < 0)\n        srcStart = 0;\n        if (typeof srcEnd != 'number' || srcEnd > this.length)\n        srcEnd = this.length;\n        if (srcStart >= this.length)\n        return dst || Buffer.alloc(0);\n        if (srcEnd <= 0)\n        return dst || Buffer.alloc(0);\n\n        var copy = !!dst,\n        off = this._offset(srcStart),\n        len = srcEnd - srcStart,\n        bytes = len,\n        bufoff = copy && dstStart || 0,\n        start = off[1],\n        l,\n        i;\n\n        // copy/slice everything\n        if (srcStart === 0 && srcEnd == this.length) {\n          if (!copy) {// slice, but full concat if multiple buffers\n            return this._bufs.length === 1 ?\n            this._bufs[0] :\n            Buffer.concat(this._bufs, this.length);\n          }\n\n          // copy, need to copy individual buffers\n          for (i = 0; i < this._bufs.length; i++) {\n            this._bufs[i].copy(dst, bufoff);\n            bufoff += this._bufs[i].length;\n          }\n\n          return dst;\n        }\n\n        // easy, cheap case where it's a subset of one of the buffers\n        if (bytes <= this._bufs[off[0]].length - start) {\n          return copy ?\n          this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) :\n          this._bufs[off[0]].slice(start, start + bytes);\n        }\n\n        if (!copy) // a slice, we need something to copy in to\n          dst = Buffer.allocUnsafe(len);\n\n        for (i = off[0]; i < this._bufs.length; i++) {\n          l = this._bufs[i].length - start;\n\n          if (bytes > l) {\n            this._bufs[i].copy(dst, bufoff, start);\n          } else {\n            this._bufs[i].copy(dst, bufoff, start, start + bytes);\n            break;\n          }\n\n          bufoff += l;\n          bytes -= l;\n\n          if (start)\n          start = 0;\n        }\n\n        return dst;\n      };\n\n      BufferList.prototype.shallowSlice = function shallowSlice(start, end) {\n        start = start || 0;\n        end = end || this.length;\n\n        if (start < 0)\n        start += this.length;\n        if (end < 0)\n        end += this.length;\n\n        var startOffset = this._offset(start),\n        endOffset = this._offset(end),\n        buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);\n\n        if (endOffset[1] == 0)\n        buffers.pop();else\n\n        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);\n\n        if (startOffset[1] != 0)\n        buffers[0] = buffers[0].slice(startOffset[1]);\n\n        return new BufferList(buffers);\n      };\n\n      BufferList.prototype.toString = function toString(encoding, start, end) {\n        return this.slice(start, end).toString(encoding);\n      };\n\n      BufferList.prototype.consume = function consume(bytes) {\n        while (this._bufs.length) {\n          if (bytes >= this._bufs[0].length) {\n            bytes -= this._bufs[0].length;\n            this.length -= this._bufs[0].length;\n            this._bufs.shift();\n          } else {\n            this._bufs[0] = this._bufs[0].slice(bytes);\n            this.length -= bytes;\n            break;\n          }\n        }\n        return this;\n      };\n\n\n      BufferList.prototype.duplicate = function duplicate() {\n        var i = 0,\n        copy = new BufferList();\n\n        for (; i < this._bufs.length; i++) {\n          copy.append(this._bufs[i]);}\n\n        return copy;\n      };\n\n\n      BufferList.prototype.destroy = function destroy() {\n        this._bufs.length = 0;\n        this.length = 0;\n        this.push(null);\n      };\n\n\n      (function () {\n        var methods = {\n          'readDoubleBE': 8,\n          'readDoubleLE': 8,\n          'readFloatBE': 4,\n          'readFloatLE': 4,\n          'readInt32BE': 4,\n          'readInt32LE': 4,\n          'readUInt32BE': 4,\n          'readUInt32LE': 4,\n          'readInt16BE': 2,\n          'readInt16LE': 2,\n          'readUInt16BE': 2,\n          'readUInt16LE': 2,\n          'readInt8': 1,\n          'readUInt8': 1 };\n\n\n        for (var m in methods) {\n          (function (m) {\n            BufferList.prototype[m] = function (offset) {\n              return this.slice(offset, offset + methods[m])[m](0);\n            };\n          })(m);\n        }\n      })();\n\n\n      module.exports = BufferList;\n\n    }, { \"readable-stream/duplex\": 97, \"safe-buffer\": 110, \"util\": 117 }], 86: [function (require, module, exports) {\n      'use strict';\n\n      var Buffer = require('safe-buffer').Buffer;\n      var max = 65536;\n      var cache = {};\n\n      function generateBuffer(i) {\n        var buffer = Buffer.allocUnsafe(2);\n        buffer.writeUInt8(i >> 8, 0);\n        buffer.writeUInt8(i & 0x00FF, 0 + 1);\n\n        return buffer;\n      }\n\n      function generateCache() {\n        for (var i = 0; i < max; i++) {\n          cache[i] = generateBuffer(i);\n        }\n      }\n\n      /**\n         * calcVariableByteIntLength - calculate the variable byte integer\n         * length field\n         *\n         * @api private\n         */\n      function calcVariableByteIntLength(length) {\n        if (length >= 0 && length < 128) return 1;else\n        if (length >= 128 && length < 16384) return 2;else\n        if (length >= 16384 && length < 2097152) return 3;else\n        if (length >= 2097152 && length < 268435456) return 4;else\n        return 0;\n      }\n\n      function genBufVariableByteInt(num) {\n        var digit = 0;\n        var pos = 0;\n        var length = calcVariableByteIntLength(num);\n        var buffer = Buffer.allocUnsafe(length);\n\n        do {\n          digit = num % 128 | 0;\n          num = num / 128 | 0;\n          if (num > 0) digit = digit | 0x80;\n\n          buffer.writeUInt8(digit, pos++);\n        } while (num > 0);\n\n        return {\n          data: buffer,\n          length: length };\n\n      }\n\n      function generate4ByteBuffer(num) {\n        var buffer = Buffer.allocUnsafe(4);\n        buffer.writeUInt32BE(num, 0);\n        return buffer;\n      }\n\n      module.exports = {\n        cache: cache,\n        generateCache: generateCache,\n        generateNumber: generateBuffer,\n        genBufVariableByteInt: genBufVariableByteInt,\n        generate4ByteBuffer: generate4ByteBuffer };\n\n\n    }, { \"safe-buffer\": 110 }], 87: [function (require, module, exports) {\n\n      function Packet() {\n        this.cmd = null;\n        this.retain = false;\n        this.qos = 0;\n        this.dup = false;\n        this.length = -1;\n        this.topic = null;\n        this.payload = null;\n      }\n\n      module.exports = Packet;\n\n    }, {}], 88: [function (require, module, exports) {\n      'use strict';\n\n      var bl = require('bl');\n      var inherits = require('inherits');\n      var EE = require('events').EventEmitter;\n      var Packet = require('./packet');\n      var constants = require('./constants');\n\n      function Parser(opt) {\n        if (!(this instanceof Parser)) return new Parser(opt);\n\n        this.settings = opt || {};\n\n        this._states = [\n        '_parseHeader',\n        '_parseLength',\n        '_parsePayload',\n        '_newPacket'];\n\n\n        this._resetState();\n      }\n\n      inherits(Parser, EE);\n\n      Parser.prototype._resetState = function () {\n        this.packet = new Packet();\n        this.error = null;\n        this._list = bl();\n        this._stateCounter = 0;\n      };\n\n      Parser.prototype.parse = function (buf) {\n        if (this.error) this._resetState();\n\n        this._list.append(buf);\n\n        while ((this.packet.length !== -1 || this._list.length > 0) &&\n        this[this._states[this._stateCounter]]() &&\n        !this.error) {\n          this._stateCounter++;\n\n          if (this._stateCounter >= this._states.length) this._stateCounter = 0;\n        }\n\n        return this._list.length;\n      };\n\n      Parser.prototype._parseHeader = function () {\n        // There is at least one byte in the buffer\n        var zero = this._list.readUInt8(0);\n        this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT];\n        this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;\n        this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;\n        this.packet.dup = (zero & constants.DUP_MASK) !== 0;\n\n        this._list.consume(1);\n\n        return true;\n      };\n\n      Parser.prototype._parseLength = function () {\n        // There is at least one byte in the list\n        var result = this._parseVarByteNum(true);\n\n        if (result) {\n          this.packet.length = result.value;\n          this._list.consume(result.bytes);\n        }\n\n        return !!result;\n      };\n\n      Parser.prototype._parsePayload = function () {\n        var result = false;\n\n        // Do we have a payload? Do we have enough data to complete the payload?\n        // PINGs have no payload\n        if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n          this._pos = 0;\n\n          switch (this.packet.cmd) {\n            case 'connect':\n              this._parseConnect();\n              break;\n            case 'connack':\n              this._parseConnack();\n              break;\n            case 'publish':\n              this._parsePublish();\n              break;\n            case 'puback':\n            case 'pubrec':\n            case 'pubrel':\n            case 'pubcomp':\n              this._parseConfirmation();\n              break;\n            case 'subscribe':\n              this._parseSubscribe();\n              break;\n            case 'suback':\n              this._parseSuback();\n              break;\n            case 'unsubscribe':\n              this._parseUnsubscribe();\n              break;\n            case 'unsuback':\n              this._parseUnsuback();\n              break;\n            case 'pingreq':\n            case 'pingresp':\n              // These are empty, nothing to do\n              break;\n            case 'disconnect':\n              this._parseDisconnect();\n              break;\n            case 'auth':\n              this._parseAuth();\n              break;\n            default:\n              this._emitError(new Error('Not supported'));}\n\n\n          result = true;\n        }\n\n        return result;\n      };\n\n      Parser.prototype._parseConnect = function () {\n        var protocolId; // Protocol ID\n        var clientId; // Client ID\n        var topic; // Will topic\n        var payload; // Will payload\n        var password; // Password\n        var username; // Username\n        var flags = {};\n        var packet = this.packet;\n\n        // Parse protocolId\n        protocolId = this._parseString();\n\n        if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'));\n        if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n          return this._emitError(new Error('Invalid protocolId'));\n        }\n\n        packet.protocolId = protocolId;\n\n        // Parse constants version number\n        if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'));\n\n        packet.protocolVersion = this._list.readUInt8(this._pos);\n\n        if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n          return this._emitError(new Error('Invalid protocol version'));\n        }\n\n        this._pos++;\n\n        if (this._pos >= this._list.length) {\n          return this._emitError(new Error('Packet too short'));\n        }\n\n        // Parse connect flags\n        flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;\n        flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;\n        flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;\n\n        if (flags.will) {\n          packet.will = {};\n          packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0;\n          packet.will.qos = (this._list.readUInt8(this._pos) &\n          constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;\n        }\n\n        packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;\n        this._pos++;\n\n        // Parse keepalive\n        packet.keepalive = this._parseNum();\n        if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'));\n\n        // parse properties\n        if (packet.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n        // Parse clientId\n        clientId = this._parseString();\n        if (clientId === null) return this._emitError(new Error('Packet too short'));\n        packet.clientId = clientId;\n\n        if (flags.will) {\n          if (packet.protocolVersion === 5) {\n            var willProperties = this._parseProperties();\n            if (Object.getOwnPropertyNames(willProperties).length) {\n              packet.will.properties = willProperties;\n            }\n          }\n          // Parse will topic\n          topic = this._parseString();\n          if (topic === null) return this._emitError(new Error('Cannot parse will topic'));\n          packet.will.topic = topic;\n\n          // Parse will payload\n          payload = this._parseBuffer();\n          if (payload === null) return this._emitError(new Error('Cannot parse will payload'));\n          packet.will.payload = payload;\n        }\n\n        // Parse username\n        if (flags.username) {\n          username = this._parseString();\n          if (username === null) return this._emitError(new Error('Cannot parse username'));\n          packet.username = username;\n        }\n\n        // Parse password\n        if (flags.password) {\n          password = this._parseBuffer();\n          if (password === null) return this._emitError(new Error('Cannot parse password'));\n          packet.password = password;\n        }\n        // need for right parse auth packet and self set up\n        this.settings = packet;\n\n        return packet;\n      };\n\n      Parser.prototype._parseConnack = function () {\n        var packet = this.packet;\n\n        if (this._list.length < 2) return null;\n\n        packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK);\n        if (this.settings.protocolVersion === 5) {\n          packet.reasonCode = this._list.readUInt8(this._pos++);\n        } else {\n          packet.returnCode = this._list.readUInt8(this._pos++);\n        }\n\n        if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'));\n        // mqtt 5 properties\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n      };\n\n      Parser.prototype._parsePublish = function () {\n        var packet = this.packet;\n        packet.topic = this._parseString();\n\n        if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n        // Parse messageId\n        if (packet.qos > 0) if (!this._parseMessageId()) {return;}\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        packet.payload = this._list.slice(this._pos, packet.length);\n      };\n\n      Parser.prototype._parseSubscribe = function () {\n        var packet = this.packet;\n        var topic;\n        var options;\n        var qos;\n        var rh;\n        var rap;\n        var nl;\n        var subscription;\n\n        if (packet.qos !== 1) {\n          return this._emitError(new Error('Wrong subscribe header'));\n        }\n\n        packet.subscriptions = [];\n\n        if (!this._parseMessageId()) {return;}\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        while (this._pos < packet.length) {\n          // Parse topic\n          topic = this._parseString();\n          if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n          options = this._parseByte();\n          qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;\n          nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;\n          rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;\n          rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;\n\n          subscription = { topic: topic, qos: qos };\n\n          // mqtt 5 options\n          if (this.settings.protocolVersion === 5) {\n            subscription.nl = nl;\n            subscription.rap = rap;\n            subscription.rh = rh;\n          }\n\n          // Push pair to subscriptions\n          packet.subscriptions.push(subscription);\n        }\n      };\n\n      Parser.prototype._parseSuback = function () {\n        var packet = this.packet;\n        this.packet.granted = [];\n\n        if (!this._parseMessageId()) {return;}\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        // Parse granted QoSes\n        while (this._pos < this.packet.length) {\n          this.packet.granted.push(this._list.readUInt8(this._pos++));\n        }\n      };\n\n      Parser.prototype._parseUnsubscribe = function () {\n        var packet = this.packet;\n\n        packet.unsubscriptions = [];\n\n        // Parse messageId\n        if (!this._parseMessageId()) {return;}\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        while (this._pos < packet.length) {\n          var topic;\n\n          // Parse topic\n          topic = this._parseString();\n          if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n          // Push topic to unsubscriptions\n          packet.unsubscriptions.push(topic);\n        }\n      };\n\n      Parser.prototype._parseUnsuback = function () {\n        var packet = this.packet;\n        if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'));\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n          // Parse granted QoSes\n          packet.granted = [];\n          while (this._pos < this.packet.length) {\n            this.packet.granted.push(this._list.readUInt8(this._pos++));\n          }\n        }\n      };\n\n      // parse packets like puback, pubrec, pubrel, pubcomp\n      Parser.prototype._parseConfirmation = function () {\n        var packet = this.packet;\n\n        this._parseMessageId();\n\n        if (this.settings.protocolVersion === 5) {\n          if (packet.length > 2) {\n            // response code\n            packet.reasonCode = this._parseByte();\n            // properies mqtt 5\n            var properties = this._parseProperties();\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n        }\n\n        return true;\n      };\n\n      // parse disconnect packet\n      Parser.prototype._parseDisconnect = function () {\n        var packet = this.packet;\n\n        if (this.settings.protocolVersion === 5) {\n          // response code\n          packet.reasonCode = this._parseByte();\n          // properies mqtt 5\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        return true;\n      };\n\n      // parse auth packet\n      Parser.prototype._parseAuth = function () {\n        var packet = this.packet;\n\n        if (this.settings.protocolVersion !== 5) {\n          return this._emitError(new Error('Not supported auth packet for this version MQTT'));\n        }\n\n        // response code\n        packet.reasonCode = this._parseByte();\n        // properies mqtt 5\n        var properties = this._parseProperties();\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties;\n        }\n\n        return true;\n      };\n\n      Parser.prototype._parseMessageId = function () {\n        var packet = this.packet;\n\n        packet.messageId = this._parseNum();\n\n        if (packet.messageId === null) {\n          this._emitError(new Error('Cannot parse messageId'));\n          return false;\n        }\n\n        return true;\n      };\n\n      Parser.prototype._parseString = function (maybeBuffer) {\n        var length = this._parseNum();\n        var result;\n        var end = length + this._pos;\n\n        if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n        result = this._list.toString('utf8', this._pos, end);\n        this._pos += length;\n\n        return result;\n      };\n\n      Parser.prototype._parseStringPair = function () {\n        return {\n          name: this._parseString(),\n          value: this._parseString() };\n\n      };\n\n      Parser.prototype._parseBuffer = function () {\n        var length = this._parseNum();\n        var result;\n        var end = length + this._pos;\n\n        if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n        result = this._list.slice(this._pos, end);\n\n        this._pos += length;\n\n        return result;\n      };\n\n      Parser.prototype._parseNum = function () {\n        if (this._list.length - this._pos < 2) return -1;\n\n        var result = this._list.readUInt16BE(this._pos);\n        this._pos += 2;\n\n        return result;\n      };\n\n      Parser.prototype._parse4ByteNum = function () {\n        if (this._list.length - this._pos < 4) return -1;\n\n        var result = this._list.readUInt32BE(this._pos);\n        this._pos += 4;\n\n        return result;\n      };\n\n      Parser.prototype._parseVarByteNum = function (fullInfoFlag) {\n        var bytes = 0;\n        var mul = 1;\n        var length = 0;\n        var result = true;\n        var current;\n        var padding = this._pos ? this._pos : 0;\n\n        while (bytes < 5) {\n          current = this._list.readUInt8(padding + bytes++);\n          length += mul * (current & constants.LENGTH_MASK);\n          mul *= 0x80;\n\n          if ((current & constants.LENGTH_FIN_MASK) === 0) break;\n          if (this._list.length <= bytes) {\n            result = false;\n            break;\n          }\n        }\n\n        if (padding) {\n          this._pos += bytes;\n        }\n\n        result = result ?\n        fullInfoFlag ? {\n          bytes: bytes,\n          value: length } :\n        length :\n        false;\n\n        return result;\n      };\n\n      Parser.prototype._parseByte = function () {\n        var result = this._list.readUInt8(this._pos);\n        this._pos++;\n        return result;\n      };\n\n      Parser.prototype._parseByType = function (type) {\n        switch (type) {\n          case 'byte':{\n              return this._parseByte() !== 0;\n            }\n          case 'int8':{\n              return this._parseByte();\n            }\n          case 'int16':{\n              return this._parseNum();\n            }\n          case 'int32':{\n              return this._parse4ByteNum();\n            }\n          case 'var':{\n              return this._parseVarByteNum();\n            }\n          case 'string':{\n              return this._parseString();\n            }\n          case 'pair':{\n              return this._parseStringPair();\n            }\n          case 'binary':{\n              return this._parseBuffer();\n            }}\n\n      };\n\n      Parser.prototype._parseProperties = function () {\n        var length = this._parseVarByteNum();\n        var start = this._pos;\n        var end = start + length;\n        var result = {};\n        while (this._pos < end) {\n          var type = this._parseByte();\n          var name = constants.propertiesCodes[type];\n          if (!name) {\n            this._emitError(new Error('Unknown property'));\n            return false;\n          }\n          // user properties process\n          if (name === 'userProperties') {\n            if (!result[name]) {\n              result[name] = {};\n            }\n            var currentUserProperty = this._parseByType(constants.propertiesTypes[name]);\n            result[name][currentUserProperty.name] = currentUserProperty.value;\n            continue;\n          }\n          result[name] = this._parseByType(constants.propertiesTypes[name]);\n        }\n        return result;\n      };\n\n      Parser.prototype._newPacket = function () {\n        if (this.packet) {\n          this._list.consume(this.packet.length);\n          this.emit('packet', this.packet);\n        }\n\n        this.packet = new Packet();\n\n        this._pos = 0;\n\n        return true;\n      };\n\n      Parser.prototype._emitError = function (err) {\n        this.error = err;\n        this.emit('error', err);\n      };\n\n      module.exports = Parser;\n\n    }, { \"./constants\": 82, \"./packet\": 87, \"bl\": 85, \"events\": 13, \"inherits\": 80 }], 89: [function (require, module, exports) {\n      'use strict';\n\n      var protocol = require('./constants');\n      var Buffer = require('safe-buffer').Buffer;\n      var empty = Buffer.allocUnsafe(0);\n      var zeroBuf = Buffer.from([0]);\n      var numbers = require('./numbers');\n      var nextTick = require('process-nextick-args').nextTick;\n\n      var numCache = numbers.cache;\n      var generateNumber = numbers.generateNumber;\n      var generateCache = numbers.generateCache;\n      var genBufVariableByteInt = numbers.genBufVariableByteInt;\n      var generate4ByteBuffer = numbers.generate4ByteBuffer;\n      var writeNumber = writeNumberCached;\n      var toGenerate = true;\n\n      function generate(packet, stream, opts) {\n        if (stream.cork) {\n          stream.cork();\n          nextTick(uncork, stream);\n        }\n\n        if (toGenerate) {\n          toGenerate = false;\n          generateCache();\n        }\n\n        switch (packet.cmd) {\n          case 'connect':\n            return connect(packet, stream, opts);\n          case 'connack':\n            return connack(packet, stream, opts);\n          case 'publish':\n            return publish(packet, stream, opts);\n          case 'puback':\n          case 'pubrec':\n          case 'pubrel':\n          case 'pubcomp':\n            return confirmation(packet, stream, opts);\n          case 'subscribe':\n            return subscribe(packet, stream, opts);\n          case 'suback':\n            return suback(packet, stream, opts);\n          case 'unsubscribe':\n            return unsubscribe(packet, stream, opts);\n          case 'unsuback':\n            return unsuback(packet, stream, opts);\n          case 'pingreq':\n          case 'pingresp':\n            return emptyPacket(packet, stream, opts);\n          case 'disconnect':\n            return disconnect(packet, stream, opts);\n          case 'auth':\n            return auth(packet, stream, opts);\n          default:\n            stream.emit('error', new Error('Unknown command'));\n            return false;}\n\n      }\n      /**\n         * Controls numbers cache.\n         * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n         */\n      Object.defineProperty(generate, 'cacheNumbers', {\n        get: function get() {\n          return writeNumber === writeNumberCached;\n        },\n        set: function set(value) {\n          if (value) {\n            if (!numCache || Object.keys(numCache).length === 0) toGenerate = true;\n            writeNumber = writeNumberCached;\n          } else {\n            toGenerate = false;\n            writeNumber = writeNumberGenerated;\n          }\n        } });\n\n\n      function uncork(stream) {\n        stream.uncork();\n      }\n\n      function connect(packet, stream, opts) {\n        var settings = packet || {};\n        var protocolId = settings.protocolId || 'MQTT';\n        var protocolVersion = settings.protocolVersion || 4;\n        var will = settings.will;\n        var clean = settings.clean;\n        var keepalive = settings.keepalive || 0;\n        var clientId = settings.clientId || '';\n        var username = settings.username;\n        var password = settings.password;\n        /* mqtt5 new oprions */\n        var properties = settings.properties;\n\n        if (clean === undefined) clean = true;\n\n        var length = 0;\n\n        // Must be a string and non-falsy\n        if (!protocolId ||\n        typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId)) {\n          stream.emit('error', new Error('Invalid protocolId'));\n          return false;\n        } else length += protocolId.length + 2;\n\n        // Must be 3 or 4 or 5\n        if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n          stream.emit('error', new Error('Invalid protocol version'));\n          return false;\n        } else length += 1;\n\n        // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1\n        if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) && (\n        clientId || protocolVersion === 4) && (clientId || clean)) {\n          length += clientId.length + 2;\n        } else {\n          if (protocolVersion < 4) {\n            stream.emit('error', new Error('clientId must be supplied before 3.1.1'));\n            return false;\n          }\n          if (clean * 1 === 0) {\n            stream.emit('error', new Error('clientId must be given if cleanSession set to 0'));\n            return false;\n          }\n        }\n\n        // Must be a two byte number\n        if (typeof keepalive !== 'number' ||\n        keepalive < 0 ||\n        keepalive > 65535 ||\n        keepalive % 1 !== 0) {\n          stream.emit('error', new Error('Invalid keepalive'));\n          return false;\n        } else length += 2;\n\n        // Connect flags\n        length += 1;\n\n        // Properties\n        if (protocolVersion === 5) {\n          var propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // If will exists...\n        if (will) {\n          // It must be an object\n          if (typeof will !== 'object') {\n            stream.emit('error', new Error('Invalid will'));\n            return false;\n          }\n          // It must have topic typeof string\n          if (!will.topic || typeof will.topic !== 'string') {\n            stream.emit('error', new Error('Invalid will topic'));\n            return false;\n          } else {\n            length += Buffer.byteLength(will.topic) + 2;\n          }\n\n          // Payload\n          if (will.payload) {\n            if (will.payload.length >= 0) {\n              if (typeof will.payload === 'string') {\n                length += Buffer.byteLength(will.payload) + 2;\n              } else {\n                length += will.payload.length + 2;\n              }\n            } else {\n              stream.emit('error', new Error('Invalid will payload'));\n              return false;\n            }\n\n            // will properties\n            var willProperties = {};\n            if (protocolVersion === 5) {\n              willProperties = getProperties(stream, will.properties);\n              length += willProperties.length;\n            }\n          }\n        }\n\n        // Username\n        var providedUsername = false;\n        if (username != null) {\n          if (isStringOrBuffer(username)) {\n            providedUsername = true;\n            length += Buffer.byteLength(username) + 2;\n          } else {\n            stream.emit('error', new Error('Invalid username'));\n            return false;\n          }\n        }\n\n        // Password\n        if (password != null) {\n          if (!providedUsername) {\n            stream.emit('error', new Error('Username is required to use password'));\n            return false;\n          }\n\n          if (isStringOrBuffer(password)) {\n            length += byteLength(password) + 2;\n          } else {\n            stream.emit('error', new Error('Invalid password'));\n            return false;\n          }\n        }\n\n        // Generate header\n        stream.write(protocol.CONNECT_HEADER);\n\n        // Generate length\n        writeVarByteInt(stream, length);\n\n        // Generate protocol ID\n        writeStringOrBuffer(stream, protocolId);\n        stream.write(\n        protocolVersion === 4 ?\n        protocol.VERSION4 :\n        protocolVersion === 5 ?\n        protocol.VERSION5 :\n        protocol.VERSION3);\n\n\n        // Connect flags\n        var flags = 0;\n        flags |= username != null ? protocol.USERNAME_MASK : 0;\n        flags |= password != null ? protocol.PASSWORD_MASK : 0;\n        flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;\n        flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;\n        flags |= will ? protocol.WILL_FLAG_MASK : 0;\n        flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;\n\n        stream.write(Buffer.from([flags]));\n\n        // Keepalive\n        writeNumber(stream, keepalive);\n\n        // Properties\n        if (protocolVersion === 5) {\n          propertiesData.write();\n        }\n\n        // Client ID\n        writeStringOrBuffer(stream, clientId);\n\n        // Will\n        if (will) {\n          if (protocolVersion === 5) {\n            willProperties.write();\n          }\n          writeString(stream, will.topic);\n          writeStringOrBuffer(stream, will.payload);\n        }\n\n        // Username and password\n        if (username != null) {\n          writeStringOrBuffer(stream, username);\n        }\n        if (password != null) {\n          writeStringOrBuffer(stream, password);\n        }\n        // This is a small packet that happens only once on a stream\n        // We assume the stream is always free to receive more data after this\n        return true;\n      }\n\n      function connack(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var rc = version === 5 ? settings.reasonCode : settings.returnCode;\n        var properties = settings.properties;\n        var length = 2; // length of rc and sessionHeader\n\n        // Check return code\n        if (typeof rc !== 'number') {\n          stream.emit('error', new Error('Invalid return code'));\n          return false;\n        }\n        // mqtt5 properties\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        stream.write(protocol.CONNACK_HEADER);\n        // length\n        writeVarByteInt(stream, length);\n        stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);\n\n        stream.write(Buffer.from([rc]));\n        if (propertiesData != null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n\n      function publish(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var qos = settings.qos || 0;\n        var retain = settings.retain ? protocol.RETAIN_MASK : 0;\n        var topic = settings.topic;\n        var payload = settings.payload || empty;\n        var id = settings.messageId;\n        var properties = settings.properties;\n\n        var length = 0;\n\n        // Topic must be a non-empty string or Buffer\n        if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2;else\n        if (Buffer.isBuffer(topic)) length += topic.length + 2;else\n        {\n          stream.emit('error', new Error('Invalid topic'));\n          return false;\n        }\n\n        // Get the payload length\n        if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload);else\n        length += payload.length;\n\n        // Message ID must a number if qos > 0\n        if (qos && typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else if (qos) length += 2;\n\n        // mqtt5 properties\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]);\n\n        // Remaining length\n        writeVarByteInt(stream, length);\n\n        // Topic\n        writeNumber(stream, byteLength(topic));\n        stream.write(topic);\n\n        // Message ID\n        if (qos > 0) writeNumber(stream, id);\n\n        // Properties\n        if (propertiesData != null) {\n          propertiesData.write();\n        }\n\n        // Payload\n        return stream.write(payload);\n      }\n\n      /* Puback, pubrec, pubrel and pubcomp */\n      function confirmation(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var type = settings.cmd || 'puback';\n        var id = settings.messageId;\n        var dup = settings.dup && type === 'pubrel' ? protocol.DUP_MASK : 0;\n        var qos = 0;\n        var reasonCode = settings.reasonCode;\n        var properties = settings.properties;\n        var length = version === 5 ? 3 : 2;\n\n        if (type === 'pubrel') qos = 1;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        }\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {return false;}\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.ACKS[type][qos][dup][0]);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // reason code in header\n        if (version === 5) {\n          stream.write(Buffer.from([reasonCode]));\n        }\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n\n      function subscribe(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var dup = settings.dup ? protocol.DUP_MASK : 0;\n        var id = settings.messageId;\n        var subs = settings.subscriptions;\n        var properties = settings.properties;\n\n        var length = 0;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else length += 2;\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // Check subscriptions\n        if (typeof subs === 'object' && subs.length) {\n          for (var i = 0; i < subs.length; i += 1) {\n            var itopic = subs[i].topic;\n            var iqos = subs[i].qos;\n\n            if (typeof itopic !== 'string') {\n              stream.emit('error', new Error('Invalid subscriptions - invalid topic'));\n              return false;\n            }\n            if (typeof iqos !== 'number') {\n              stream.emit('error', new Error('Invalid subscriptions - invalid qos'));\n              return false;\n            }\n\n            if (version === 5) {\n              var nl = subs[i].nl || false;\n              if (typeof nl !== 'boolean') {\n                stream.emit('error', new Error('Invalid subscriptions - invalid No Local'));\n                return false;\n              }\n              var rap = subs[i].rap || false;\n              if (typeof rap !== 'boolean') {\n                stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'));\n                return false;\n              }\n              var rh = subs[i].rh || 0;\n              if (typeof rh !== 'number' || rh > 2) {\n                stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'));\n                return false;\n              }\n            }\n\n            length += Buffer.byteLength(itopic) + 2 + 1;\n          }\n        } else {\n          stream.emit('error', new Error('Invalid subscriptions'));\n          return false;\n        }\n\n        // Generate header\n        stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);\n\n        // Generate length\n        writeVarByteInt(stream, length);\n\n        // Generate message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        var result = true;\n\n        // Generate subs\n        for (var j = 0; j < subs.length; j++) {\n          var sub = subs[j];\n          var jtopic = sub.topic;\n          var jqos = sub.qos;\n          var jnl = +sub.nl;\n          var jrap = +sub.rap;\n          var jrh = sub.rh;\n          var joptions;\n\n          // Write topic string\n          writeString(stream, jtopic);\n\n          // options process\n          joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];\n          if (version === 5) {\n            joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;\n            joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;\n            joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;\n          }\n          // Write options\n          result = stream.write(Buffer.from([joptions]));\n        }\n\n        return result;\n      }\n\n      function suback(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var id = settings.messageId;\n        var granted = settings.granted;\n        var properties = settings.properties;\n        var length = 0;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else length += 2;\n\n        // Check granted qos vector\n        if (typeof granted === 'object' && granted.length) {\n          for (var i = 0; i < granted.length; i += 1) {\n            if (typeof granted[i] !== 'number') {\n              stream.emit('error', new Error('Invalid qos vector'));\n              return false;\n            }\n            length += 1;\n          }\n        } else {\n          stream.emit('error', new Error('Invalid qos vector'));\n          return false;\n        }\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {return false;}\n          length += propertiesData.length;\n        }\n\n        // header\n        stream.write(protocol.SUBACK_HEADER);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        return stream.write(Buffer.from(granted));\n      }\n\n      function unsubscribe(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var id = settings.messageId;\n        var dup = settings.dup ? protocol.DUP_MASK : 0;\n        var unsubs = settings.unsubscriptions;\n        var properties = settings.properties;\n\n        var length = 0;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else {\n          length += 2;\n        }\n        // Check unsubs\n        if (typeof unsubs === 'object' && unsubs.length) {\n          for (var i = 0; i < unsubs.length; i += 1) {\n            if (typeof unsubs[i] !== 'string') {\n              stream.emit('error', new Error('Invalid unsubscriptions'));\n              return false;\n            }\n            length += Buffer.byteLength(unsubs[i]) + 2;\n          }\n        } else {\n          stream.emit('error', new Error('Invalid unsubscriptions'));\n          return false;\n        }\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        // Unsubs\n        var result = true;\n        for (var j = 0; j < unsubs.length; j++) {\n          result = writeString(stream, unsubs[j]);\n        }\n\n        return result;\n      }\n\n      function unsuback(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var id = settings.messageId;\n        var dup = settings.dup ? protocol.DUP_MASK : 0;\n        var granted = settings.granted;\n        var properties = settings.properties;\n        var type = settings.cmd;\n        var qos = 0;\n\n        var length = 2;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        }\n\n        // Check granted\n        if (version === 5) {\n          if (typeof granted === 'object' && granted.length) {\n            for (var i = 0; i < granted.length; i += 1) {\n              if (typeof granted[i] !== 'number') {\n                stream.emit('error', new Error('Invalid qos vector'));\n                return false;\n              }\n              length += 1;\n            }\n          } else {\n            stream.emit('error', new Error('Invalid qos vector'));\n            return false;\n          }\n        }\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {return false;}\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.ACKS[type][qos][dup][0]);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        // payload\n        if (version === 5) {\n          stream.write(Buffer.from(granted));\n        }\n        return true;\n      }\n\n      function emptyPacket(packet, stream, opts) {\n        return stream.write(protocol.EMPTY[packet.cmd]);\n      }\n\n      function disconnect(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var reasonCode = settings.reasonCode;\n        var properties = settings.properties;\n        var length = version === 5 ? 1 : 0;\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {return false;}\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(Buffer.from([protocol.codes['disconnect'] << 4]));\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // reason code in header\n        if (version === 5) {\n          stream.write(Buffer.from([reasonCode]));\n        }\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        return true;\n      }\n\n      function auth(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var reasonCode = settings.reasonCode;\n        var properties = settings.properties;\n        var length = version === 5 ? 1 : 0;\n\n        if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'));\n\n        // properies mqtt 5\n        var propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n        if (!propertiesData) {return false;}\n        length += propertiesData.length;\n\n        // Header\n        stream.write(Buffer.from([protocol.codes['auth'] << 4]));\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // reason code in header\n        stream.write(Buffer.from([reasonCode]));\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n\n      /**\n         * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n         *\n         * @param <Buffer> buffer - destination\n         * @param <Number> pos - offset\n         * @param <Number> length - length (>0)\n         * @returns <Number> number of bytes written\n         *\n         * @api private\n         */\n\n      var varByteIntCache = {};\n      function writeVarByteInt(stream, num) {\n        var buffer = varByteIntCache[num];\n\n        if (!buffer) {\n          buffer = genBufVariableByteInt(num).data;\n          if (num < 16384) varByteIntCache[num] = buffer;\n        }\n\n        stream.write(buffer);\n      }\n\n      /**\n         * writeString - write a utf8 string to the buffer\n         *\n         * @param <Buffer> buffer - destination\n         * @param <Number> pos - offset\n         * @param <String> string - string to write\n         * @return <Number> number of bytes written\n         *\n         * @api private\n         */\n\n      function writeString(stream, string) {\n        var strlen = Buffer.byteLength(string);\n        writeNumber(stream, strlen);\n\n        stream.write(string, 'utf8');\n      }\n\n      /**\n         * writeStringPair - write a utf8 string pairs to the buffer\n         *\n         * @param <Buffer> buffer - destination\n         * @param <String> name - string name to write\n         * @param <String> value - string value to write\n         * @return <Number> number of bytes written\n         *\n         * @api private\n         */\n      function writeStringPair(stream, name, value) {\n        writeString(stream, name);\n        writeString(stream, value);\n      }\n\n      /**\n         * writeNumber - write a two byte number to the buffer\n         *\n         * @param <Buffer> buffer - destination\n         * @param <Number> pos - offset\n         * @param <String> number - number to write\n         * @return <Number> number of bytes written\n         *\n         * @api private\n         */\n      function writeNumberCached(stream, number) {\n        return stream.write(numCache[number]);\n      }\n      function writeNumberGenerated(stream, number) {\n        return stream.write(generateNumber(number));\n      }\n      function write4ByteNumber(stream, number) {\n        return stream.write(generate4ByteBuffer(number));\n      }\n      /**\n         * writeStringOrBuffer - write a String or Buffer with the its length prefix\n         *\n         * @param <Buffer> buffer - destination\n         * @param <Number> pos - offset\n         * @param <String> toWrite - String or Buffer\n         * @return <Number> number of bytes written\n         */\n      function writeStringOrBuffer(stream, toWrite) {\n        if (typeof toWrite === 'string') {\n          writeString(stream, toWrite);\n        } else if (toWrite) {\n          writeNumber(stream, toWrite.length);\n          stream.write(toWrite);\n        } else writeNumber(stream, 0);\n      }\n\n      function getProperties(stream, properties) {\n        /* connect properties */\n        if (typeof properties !== 'object' || properties.length != null) {\n          return {\n            length: 1,\n            write: function write() {\n              writeProperties(stream, {}, 0);\n            } };\n\n        }\n        var propertiesLength = 0;\n        function getLengthProperty(name) {\n          var type = protocol.propertiesTypes[name];\n          var value = properties[name];\n          var length = 0;\n          switch (type) {\n            case 'byte':{\n                if (typeof value !== 'boolean') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 1;\n                break;\n              }\n            case 'int8':{\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 1;\n                break;\n              }\n            case 'binary':{\n                if (value && value === null) {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + Buffer.byteLength(value) + 2;\n                break;\n              }\n            case 'int16':{\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 2;\n                break;\n              }\n            case 'int32':{\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 4;\n                break;\n              }\n            case 'var':{\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + genBufVariableByteInt(value).length;\n                break;\n              }\n            case 'string':{\n                if (typeof value !== 'string') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 2 + Buffer.byteLength(value.toString());\n                break;\n              }\n            case 'pair':{\n                if (typeof value !== 'object') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += Object.getOwnPropertyNames(value).reduce(function (result, name) {\n                  result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString());\n                  return result;\n                }, 0);\n                break;\n              }\n            default:{\n                stream.emit('error', new Error('Invalid property ' + name));\n                return false;\n              }}\n\n          return length;\n        }\n        if (properties) {\n          for (var propName in properties) {\n            var propLength = getLengthProperty(propName);\n            if (!propLength) return false;\n            propertiesLength += propLength;\n          }\n        }\n        var propertiesLengthLength = genBufVariableByteInt(propertiesLength).length;\n\n        return {\n          length: propertiesLengthLength + propertiesLength,\n          write: function write() {\n            writeProperties(stream, properties, propertiesLength);\n          } };\n\n      }\n\n      function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {\n        var mayEmptyProps = ['reasonString', 'userProperties'];\n        var maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;\n\n        var propertiesData = getProperties(stream, properties);\n        if (maximumPacketSize) {\n          while (length + propertiesData.length > maximumPacketSize) {\n            var currentMayEmptyProp = mayEmptyProps.shift();\n            if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n              delete properties[currentMayEmptyProp];\n              propertiesData = getProperties(stream, properties);\n            } else {\n              return false;\n            }\n          }\n        }\n        return propertiesData;\n      }\n\n      function writeProperties(stream, properties, propertiesLength) {\n        /* write properties to stream */\n        writeVarByteInt(stream, propertiesLength);\n        for (var propName in properties) {\n          if (properties.hasOwnProperty(propName) && properties[propName] !== null) {\n            var value = properties[propName];\n            var type = protocol.propertiesTypes[propName];\n            switch (type) {\n              case 'byte':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([+value]));\n                  break;\n                }\n              case 'int8':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([value]));\n                  break;\n                }\n              case 'binary':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeStringOrBuffer(stream, value);\n                  break;\n                }\n              case 'int16':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeNumber(stream, value);\n                  break;\n                }\n              case 'int32':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  write4ByteNumber(stream, value);\n                  break;\n                }\n              case 'var':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeVarByteInt(stream, value);\n                  break;\n                }\n              case 'string':{\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeString(stream, value);\n                  break;\n                }\n              case 'pair':{\n                  Object.getOwnPropertyNames(value).forEach(function (name) {\n                    stream.write(Buffer.from([protocol.properties[propName]]));\n                    writeStringPair(stream, name.toString(), value[name].toString());\n                  });\n                  break;\n                }\n              default:{\n                  stream.emit('error', new Error('Invalid property ' + propName));\n                  return false;\n                }}\n\n          }\n        }\n      }\n\n      function byteLength(bufOrString) {\n        if (!bufOrString) return 0;else\n        if (bufOrString instanceof Buffer) return bufOrString.length;else\n        return Buffer.byteLength(bufOrString);\n      }\n\n      function isStringOrBuffer(field) {\n        return typeof field === 'string' || field instanceof Buffer;\n      }\n\n      module.exports = generate;\n\n    }, { \"./constants\": 82, \"./numbers\": 86, \"process-nextick-args\": 91, \"safe-buffer\": 110 }], 90: [function (require, module, exports) {\n      var wrappy = require('wrappy');\n      module.exports = wrappy(once);\n      module.exports.strict = wrappy(onceStrict);\n\n      once.proto = once(function () {\n        Object.defineProperty(Function.prototype, 'once', {\n          value: function value() {\n            return once(this);\n          },\n          configurable: true });\n\n\n        Object.defineProperty(Function.prototype, 'onceStrict', {\n          value: function value() {\n            return onceStrict(this);\n          },\n          configurable: true });\n\n      });\n\n      function once(fn) {\n        var f = function f() {\n          if (f.called) return f.value;\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n        f.called = false;\n        return f;\n      }\n\n      function onceStrict(fn) {\n        var f = function f() {\n          if (f.called)\n          throw new Error(f.onceError);\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n        var name = fn.name || 'Function wrapped with `once`';\n        f.onceError = name + \" shouldn't be called more than once\";\n        f.called = false;\n        return f;\n      }\n\n    }, { \"wrappy\": 120 }], 91: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        if (!process.version ||\n        process.version.indexOf('v0.') === 0 ||\n        process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n          module.exports = { nextTick: nextTick };\n        } else {\n          module.exports = process;\n        }\n\n        function nextTick(fn, arg1, arg2, arg3) {\n          if (typeof fn !== 'function') {\n            throw new TypeError('\"callback\" argument must be a function');\n          }\n          var len = arguments.length;\n          var args, i;\n          switch (len) {\n            case 0:\n            case 1:\n              return process.nextTick(fn);\n            case 2:\n              return process.nextTick(function afterTickOne() {\n                fn.call(null, arg1);\n              });\n            case 3:\n              return process.nextTick(function afterTickTwo() {\n                fn.call(null, arg1, arg2);\n              });\n            case 4:\n              return process.nextTick(function afterTickThree() {\n                fn.call(null, arg1, arg2, arg3);\n              });\n            default:\n              args = new Array(len - 1);\n              i = 0;\n              while (i < args.length) {\n                args[i++] = arguments[i];\n              }\n              return process.nextTick(function afterTick() {\n                fn.apply(null, args);\n              });}\n\n        }\n\n\n      }).call(this, require('_process'));\n    }, { \"_process\": 92 }], 92: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {};\n\n      // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        }\n        // if setTimeout wasn't available but was latter defined\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n\n\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        }\n        // if clearTimeout wasn't available but was latter defined\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n\n\n\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n\n      // v8 likes predictible objects\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {return [];};\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {return '/';};\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n      process.umask = function () {return 0;};\n\n    }, {}], 93: [function (require, module, exports) {\n      (function (global) {\n        /*! https://mths.be/punycode v1.4.1 by @mathias */\n        ;(function (root) {\n\n          /** Detect free variables */\n          var freeExports = typeof exports == 'object' && exports &&\n          !exports.nodeType && exports;\n          var freeModule = typeof module == 'object' && module &&\n          !module.nodeType && module;\n          var freeGlobal = typeof global == 'object' && global;\n          if (\n          freeGlobal.global === freeGlobal ||\n          freeGlobal.window === freeGlobal ||\n          freeGlobal.self === freeGlobal)\n          {\n            root = freeGlobal;\n          }\n\n          /**\n             * The `punycode` object.\n             * @name punycode\n             * @type Object\n             */\n          var punycode,\n\n          /** Highest positive signed 32-bit float value */\n          maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n          /** Bootstring parameters */\n          base = 36,\n          tMin = 1,\n          tMax = 26,\n          skew = 38,\n          damp = 700,\n          initialBias = 72,\n          initialN = 128, // 0x80\n          delimiter = '-', // '\\x2D'\n\n          /** Regular expressions */\n          regexPunycode = /^xn--/,\n          regexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n          regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n          /** Error messages */\n          errors = {\n            'overflow': 'Overflow: input needs wider integers to process',\n            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n            'invalid-input': 'Invalid input' },\n\n\n          /** Convenience shortcuts */\n          baseMinusTMin = base - tMin,\n          floor = Math.floor,\n          stringFromCharCode = String.fromCharCode,\n\n          /** Temporary variable */\n          key;\n\n          /*--------------------------------------------------------------------------*/\n\n          /**\n                                                                                          * A generic error utility function.\n                                                                                          * @private\n                                                                                          * @param {String} type The error type.\n                                                                                          * @returns {Error} Throws a `RangeError` with the applicable error message.\n                                                                                          */\n          function error(type) {\n            throw new RangeError(errors[type]);\n          }\n\n          /**\n             * A generic `Array#map` utility function.\n             * @private\n             * @param {Array} array The array to iterate over.\n             * @param {Function} callback The function that gets called for every array\n             * item.\n             * @returns {Array} A new array of values returned by the callback function.\n             */\n          function map(array, fn) {\n            var length = array.length;\n            var result = [];\n            while (length--) {\n              result[length] = fn(array[length]);\n            }\n            return result;\n          }\n\n          /**\n             * A simple `Array#map`-like wrapper to work with domain name strings or email\n             * addresses.\n             * @private\n             * @param {String} domain The domain name or email address.\n             * @param {Function} callback The function that gets called for every\n             * character.\n             * @returns {Array} A new string of characters returned by the callback\n             * function.\n             */\n          function mapDomain(string, fn) {\n            var parts = string.split('@');\n            var result = '';\n            if (parts.length > 1) {\n              // In email addresses, only the domain name should be punycoded. Leave\n              // the local part (i.e. everything up to `@`) intact.\n              result = parts[0] + '@';\n              string = parts[1];\n            }\n            // Avoid `split(regex)` for IE8 compatibility. See #17.\n            string = string.replace(regexSeparators, '\\x2E');\n            var labels = string.split('.');\n            var encoded = map(labels, fn).join('.');\n            return result + encoded;\n          }\n\n          /**\n             * Creates an array containing the numeric code points of each Unicode\n             * character in the string. While JavaScript uses UCS-2 internally,\n             * this function will convert a pair of surrogate halves (each of which\n             * UCS-2 exposes as separate characters) into a single code point,\n             * matching UTF-16.\n             * @see `punycode.ucs2.encode`\n             * @see <https://mathiasbynens.be/notes/javascript-encoding>\n             * @memberOf punycode.ucs2\n             * @name decode\n             * @param {String} string The Unicode input string (UCS-2).\n             * @returns {Array} The new array of code points.\n             */\n          function ucs2decode(string) {\n            var output = [],\n            counter = 0,\n            length = string.length,\n            value,\n            extra;\n            while (counter < length) {\n              value = string.charCodeAt(counter++);\n              if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // high surrogate, and there is a next character\n                extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {// low surrogate\n                  output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                  // unmatched surrogate; only append this code unit, in case the next\n                  // code unit is the high surrogate of a surrogate pair\n                  output.push(value);\n                  counter--;\n                }\n              } else {\n                output.push(value);\n              }\n            }\n            return output;\n          }\n\n          /**\n             * Creates a string based on an array of numeric code points.\n             * @see `punycode.ucs2.decode`\n             * @memberOf punycode.ucs2\n             * @name encode\n             * @param {Array} codePoints The array of numeric code points.\n             * @returns {String} The new Unicode string (UCS-2).\n             */\n          function ucs2encode(array) {\n            return map(array, function (value) {\n              var output = '';\n              if (value > 0xFFFF) {\n                value -= 0x10000;\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                value = 0xDC00 | value & 0x3FF;\n              }\n              output += stringFromCharCode(value);\n              return output;\n            }).join('');\n          }\n\n          /**\n             * Converts a basic code point into a digit/integer.\n             * @see `digitToBasic()`\n             * @private\n             * @param {Number} codePoint The basic numeric code point value.\n             * @returns {Number} The numeric value of a basic code point (for use in\n             * representing integers) in the range `0` to `base - 1`, or `base` if\n             * the code point does not represent a value.\n             */\n          function basicToDigit(codePoint) {\n            if (codePoint - 48 < 10) {\n              return codePoint - 22;\n            }\n            if (codePoint - 65 < 26) {\n              return codePoint - 65;\n            }\n            if (codePoint - 97 < 26) {\n              return codePoint - 97;\n            }\n            return base;\n          }\n\n          /**\n             * Converts a digit/integer into a basic code point.\n             * @see `basicToDigit()`\n             * @private\n             * @param {Number} digit The numeric value of a basic code point.\n             * @returns {Number} The basic code point whose value (when used for\n             * representing integers) is `digit`, which needs to be in the range\n             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n             * used; else, the lowercase form is used. The behavior is undefined\n             * if `flag` is non-zero and `digit` has no uppercase form.\n             */\n          function digitToBasic(digit, flag) {\n            //  0..25 map to ASCII a..z or A..Z\n            // 26..35 map to ASCII 0..9\n            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n          }\n\n          /**\n             * Bias adaptation function as per section 3.4 of RFC 3492.\n             * https://tools.ietf.org/html/rfc3492#section-3.4\n             * @private\n             */\n          function adapt(delta, numPoints, firstTime) {\n            var k = 0;\n            delta = firstTime ? floor(delta / damp) : delta >> 1;\n            delta += floor(delta / numPoints);\n            for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n              delta = floor(delta / baseMinusTMin);\n            }\n            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n          }\n\n          /**\n             * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n             * symbols.\n             * @memberOf punycode\n             * @param {String} input The Punycode string of ASCII-only symbols.\n             * @returns {String} The resulting string of Unicode symbols.\n             */\n          function decode(input) {\n            // Don't use UCS-2\n            var output = [],\n            inputLength = input.length,\n            out,\n            i = 0,\n            n = initialN,\n            bias = initialBias,\n            basic,\n            j,\n            index,\n            oldi,\n            w,\n            k,\n            digit,\n            t,\n            /** Cached calculation results */\n            baseMinusT;\n\n            // Handle the basic code points: let `basic` be the number of input code\n            // points before the last delimiter, or `0` if there is none, then copy\n            // the first basic code points to the output.\n\n            basic = input.lastIndexOf(delimiter);\n            if (basic < 0) {\n              basic = 0;\n            }\n\n            for (j = 0; j < basic; ++j) {\n              // if it's not a basic code point\n              if (input.charCodeAt(j) >= 0x80) {\n                error('not-basic');\n              }\n              output.push(input.charCodeAt(j));\n            }\n\n            // Main decoding loop: start just after the last delimiter if any basic code\n            // points were copied; start at the beginning otherwise.\n\n            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n              // `index` is the index of the next character to be consumed.\n              // Decode a generalized variable-length integer into `delta`,\n              // which gets added to `i`. The overflow checking is easier\n              // if we increase `i` as we go, then subtract off its starting\n              // value at the end to obtain `delta`.\n              for (oldi = i, w = 1, k = base;; /* no condition */k += base) {\n\n                if (index >= inputLength) {\n                  error('invalid-input');\n                }\n\n                digit = basicToDigit(input.charCodeAt(index++));\n\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                  error('overflow');\n                }\n\n                i += digit * w;\n                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                if (digit < t) {\n                  break;\n                }\n\n                baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                  error('overflow');\n                }\n\n                w *= baseMinusT;\n\n              }\n\n              out = output.length + 1;\n              bias = adapt(i - oldi, out, oldi == 0);\n\n              // `i` was supposed to wrap around from `out` to `0`,\n              // incrementing `n` each time, so we'll fix that now:\n              if (floor(i / out) > maxInt - n) {\n                error('overflow');\n              }\n\n              n += floor(i / out);\n              i %= out;\n\n              // Insert `n` at position `i` of the output\n              output.splice(i++, 0, n);\n\n            }\n\n            return ucs2encode(output);\n          }\n\n          /**\n             * Converts a string of Unicode symbols (e.g. a domain name label) to a\n             * Punycode string of ASCII-only symbols.\n             * @memberOf punycode\n             * @param {String} input The string of Unicode symbols.\n             * @returns {String} The resulting Punycode string of ASCII-only symbols.\n             */\n          function encode(input) {\n            var n,\n            delta,\n            handledCPCount,\n            basicLength,\n            bias,\n            j,\n            m,\n            q,\n            k,\n            t,\n            currentValue,\n            output = [],\n            /** `inputLength` will hold the number of code points in `input`. */\n            inputLength,\n            /** Cached calculation results */\n            handledCPCountPlusOne,\n            baseMinusT,\n            qMinusT;\n\n            // Convert the input in UCS-2 to Unicode\n            input = ucs2decode(input);\n\n            // Cache the length\n            inputLength = input.length;\n\n            // Initialize the state\n            n = initialN;\n            delta = 0;\n            bias = initialBias;\n\n            // Handle the basic code points\n            for (j = 0; j < inputLength; ++j) {\n              currentValue = input[j];\n              if (currentValue < 0x80) {\n                output.push(stringFromCharCode(currentValue));\n              }\n            }\n\n            handledCPCount = basicLength = output.length;\n\n            // `handledCPCount` is the number of code points that have been handled;\n            // `basicLength` is the number of basic code points.\n\n            // Finish the basic string - if it is not empty - with a delimiter\n            if (basicLength) {\n              output.push(delimiter);\n            }\n\n            // Main encoding loop:\n            while (handledCPCount < inputLength) {\n\n              // All non-basic code points < n have been handled already. Find the next\n              // larger one:\n              for (m = maxInt, j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n                if (currentValue >= n && currentValue < m) {\n                  m = currentValue;\n                }\n              }\n\n              // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n              // but guard against overflow\n              handledCPCountPlusOne = handledCPCount + 1;\n              if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error('overflow');\n              }\n\n              delta += (m - n) * handledCPCountPlusOne;\n              n = m;\n\n              for (j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n\n                if (currentValue < n && ++delta > maxInt) {\n                  error('overflow');\n                }\n\n                if (currentValue == n) {\n                  // Represent delta as a generalized variable-length integer\n                  for (q = delta, k = base;; /* no condition */k += base) {\n                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                      break;\n                    }\n                    qMinusT = q - t;\n                    baseMinusT = base - t;\n                    output.push(\n                    stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\n                    q = floor(qMinusT / baseMinusT);\n                  }\n\n                  output.push(stringFromCharCode(digitToBasic(q, 0)));\n                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                  delta = 0;\n                  ++handledCPCount;\n                }\n              }\n\n              ++delta;\n              ++n;\n\n            }\n            return output.join('');\n          }\n\n          /**\n             * Converts a Punycode string representing a domain name or an email address\n             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n             * it doesn't matter if you call it on a string that has already been\n             * converted to Unicode.\n             * @memberOf punycode\n             * @param {String} input The Punycoded domain name or email address to\n             * convert to Unicode.\n             * @returns {String} The Unicode representation of the given Punycode\n             * string.\n             */\n          function toUnicode(input) {\n            return mapDomain(input, function (string) {\n              return regexPunycode.test(string) ?\n              decode(string.slice(4).toLowerCase()) :\n              string;\n            });\n          }\n\n          /**\n             * Converts a Unicode string representing a domain name or an email address to\n             * Punycode. Only the non-ASCII parts of the domain name will be converted,\n             * i.e. it doesn't matter if you call it with a domain that's already in\n             * ASCII.\n             * @memberOf punycode\n             * @param {String} input The domain name or email address to convert, as a\n             * Unicode string.\n             * @returns {String} The Punycode representation of the given domain name or\n             * email address.\n             */\n          function toASCII(input) {\n            return mapDomain(input, function (string) {\n              return regexNonASCII.test(string) ?\n              'xn--' + encode(string) :\n              string;\n            });\n          }\n\n          /*--------------------------------------------------------------------------*/\n\n          /** Define the public API */\n          punycode = {\n            /**\n                        * A string representing the current Punycode.js version number.\n                        * @memberOf punycode\n                        * @type String\n                        */\n            'version': '1.4.1',\n            /**\n                                 * An object of methods to convert from JavaScript's internal character\n                                 * representation (UCS-2) to Unicode code points, and back.\n                                 * @see <https://mathiasbynens.be/notes/javascript-encoding>\n                                 * @memberOf punycode\n                                 * @type Object\n                                 */\n            'ucs2': {\n              'decode': ucs2decode,\n              'encode': ucs2encode },\n\n            'decode': decode,\n            'encode': encode,\n            'toASCII': toASCII,\n            'toUnicode': toUnicode };\n\n\n          /** Expose `punycode` */\n          // Some AMD build optimizers, like r.js, check for specific condition patterns\n          // like the following:\n          if (\n          typeof define == 'function' &&\n          typeof define.amd == 'object' &&\n          define.amd)\n          {\n            define('punycode', function () {\n              return punycode;\n            });\n          } else if (freeExports && freeModule) {\n            if (module.exports == freeExports) {\n              // in Node.js, io.js, or RingoJS v0.8.0+\n              freeModule.exports = punycode;\n            } else {\n              // in Narwhal or RingoJS v0.7.0-\n              for (key in punycode) {\n                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n              }\n            }\n          } else {\n            // in Rhino or a web browser\n            root.punycode = punycode;\n          }\n\n        })(this);\n\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}], 94: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      // If obj.hasOwnProperty has been overridden, then calling\n      // obj.hasOwnProperty(prop) will break.\n      // See: https://github.com/joyent/node/issues/1707\n      function hasOwnProperty(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n      }\n\n      module.exports = function (qs, sep, eq, options) {\n        sep = sep || '&';\n        eq = eq || '=';\n        var obj = {};\n\n        if (typeof qs !== 'string' || qs.length === 0) {\n          return obj;\n        }\n\n        var regexp = /\\+/g;\n        qs = qs.split(sep);\n\n        var maxKeys = 1000;\n        if (options && typeof options.maxKeys === 'number') {\n          maxKeys = options.maxKeys;\n        }\n\n        var len = qs.length;\n        // maxKeys <= 0 means that we should not limit keys count\n        if (maxKeys > 0 && len > maxKeys) {\n          len = maxKeys;\n        }\n\n        for (var i = 0; i < len; ++i) {\n          var x = qs[i].replace(regexp, '%20'),\n          idx = x.indexOf(eq),\n          kstr,vstr,k,v;\n\n          if (idx >= 0) {\n            kstr = x.substr(0, idx);\n            vstr = x.substr(idx + 1);\n          } else {\n            kstr = x;\n            vstr = '';\n          }\n\n          k = decodeURIComponent(kstr);\n          v = decodeURIComponent(vstr);\n\n          if (!hasOwnProperty(obj, k)) {\n            obj[k] = v;\n          } else if (isArray(obj[k])) {\n            obj[k].push(v);\n          } else {\n            obj[k] = [obj[k], v];\n          }\n        }\n\n        return obj;\n      };\n\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n\n    }, {}], 95: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      var stringifyPrimitive = function stringifyPrimitive(v) {\n        switch (typeof v) {\n          case 'string':\n            return v;\n\n          case 'boolean':\n            return v ? 'true' : 'false';\n\n          case 'number':\n            return isFinite(v) ? v : '';\n\n          default:\n            return '';}\n\n      };\n\n      module.exports = function (obj, sep, eq, name) {\n        sep = sep || '&';\n        eq = eq || '=';\n        if (obj === null) {\n          obj = undefined;\n        }\n\n        if (typeof obj === 'object') {\n          return map(objectKeys(obj), function (k) {\n            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n            if (isArray(obj[k])) {\n              return map(obj[k], function (v) {\n                return ks + encodeURIComponent(stringifyPrimitive(v));\n              }).join(sep);\n            } else {\n              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n            }\n          }).join(sep);\n\n        }\n\n        if (!name) return '';\n        return encodeURIComponent(stringifyPrimitive(name)) + eq +\n        encodeURIComponent(stringifyPrimitive(obj));\n      };\n\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n\n      function map(xs, f) {\n        if (xs.map) return xs.map(f);\n        var res = [];\n        for (var i = 0; i < xs.length; i++) {\n          res.push(f(xs[i], i));\n        }\n        return res;\n      }\n\n      var objectKeys = Object.keys || function (obj) {\n        var res = [];\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n        }\n        return res;\n      };\n\n    }, {}], 96: [function (require, module, exports) {\n      'use strict';\n\n      exports.decode = exports.parse = require('./decode');\n      exports.encode = exports.stringify = require('./encode');\n\n    }, { \"./decode\": 94, \"./encode\": 95 }], 97: [function (require, module, exports) {\n      module.exports = require('./lib/_stream_duplex.js');\n\n    }, { \"./lib/_stream_duplex.js\": 98 }], 98: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      // a duplex stream is just a stream that is both readable and writable.\n      // Since JS doesn't have multiple prototypal inheritance, this class\n      // prototypally inherits from Readable, and then parasitically from\n      // Writable.\n\n      'use strict';\n\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n      /*<replacement>*/\n      var objectKeys = Object.keys || function (obj) {\n        var keys = [];\n        for (var key in obj) {\n          keys.push(key);\n        }return keys;\n      };\n      /*</replacement>*/\n\n      module.exports = Duplex;\n\n      /*<replacement>*/\n      var util = require('core-util-is');\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      var Readable = require('./_stream_readable');\n      var Writable = require('./_stream_writable');\n\n      util.inherits(Duplex, Readable);\n\n      {\n        // avoid scope creep, the keys array can then be collected\n        var keys = objectKeys(Writable.prototype);\n        for (var v = 0; v < keys.length; v++) {\n          var method = keys[v];\n          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n        }\n      }\n\n      function Duplex(options) {\n        if (!(this instanceof Duplex)) return new Duplex(options);\n\n        Readable.call(this, options);\n        Writable.call(this, options);\n\n        if (options && options.readable === false) this.readable = false;\n\n        if (options && options.writable === false) this.writable = false;\n\n        this.allowHalfOpen = true;\n        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n        this.once('end', onend);\n      }\n\n      Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n        // making it explicit this property is not enumerable\n        // because otherwise some prototype manipulation in\n        // userland will fail\n        enumerable: false,\n        get: function get() {\n          return this._writableState.highWaterMark;\n        } });\n\n\n      // the no-half-open enforcer\n      function onend() {\n        // if we allow half-open state, or if the writable side ended,\n        // then we're ok.\n        if (this.allowHalfOpen || this._writableState.ended) return;\n\n        // no more data can be written.\n        // But allow more writes to happen in this tick.\n        pna.nextTick(onEndNT, this);\n      }\n\n      function onEndNT(self) {\n        self.end();\n      }\n\n      Object.defineProperty(Duplex.prototype, 'destroyed', {\n        get: function get() {\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return false;\n          }\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set: function set(value) {\n          // we ignore the value if the stream\n          // has not been initialized yet\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return;\n          }\n\n          // backward compatibility, the user is explicitly\n          // managing destroyed\n          this._readableState.destroyed = value;\n          this._writableState.destroyed = value;\n        } });\n\n\n      Duplex.prototype._destroy = function (err, cb) {\n        this.push(null);\n        this.end();\n\n        pna.nextTick(cb, err);\n      };\n    }, { \"./_stream_readable\": 100, \"./_stream_writable\": 102, \"core-util-is\": 14, \"inherits\": 80, \"process-nextick-args\": 91 }], 99: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      // a passthrough stream.\n      // basically just the most minimal sort of Transform stream.\n      // Every written chunk gets output as-is.\n\n      'use strict';\n\n      module.exports = PassThrough;\n\n      var Transform = require('./_stream_transform');\n\n      /*<replacement>*/\n      var util = require('core-util-is');\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(PassThrough, Transform);\n\n      function PassThrough(options) {\n        if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n        Transform.call(this, options);\n      }\n\n      PassThrough.prototype._transform = function (chunk, encoding, cb) {\n        cb(null, chunk);\n      };\n    }, { \"./_stream_transform\": 101, \"core-util-is\": 14, \"inherits\": 80 }], 100: [function (require, module, exports) {\n      (function (process, global) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        'use strict';\n\n        /*<replacement>*/\n\n        var pna = require('process-nextick-args');\n        /*</replacement>*/\n\n        module.exports = Readable;\n\n        /*<replacement>*/\n        var isArray = require('isarray');\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Duplex;\n        /*</replacement>*/\n\n        Readable.ReadableState = ReadableState;\n\n        /*<replacement>*/\n        var EE = require('events').EventEmitter;\n\n        var EElistenerCount = function EElistenerCount(emitter, type) {\n          return emitter.listeners(type).length;\n        };\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Stream = require('./internal/streams/stream');\n        /*</replacement>*/\n\n        /*<replacement>*/\n\n        var Buffer = require('safe-buffer').Buffer;\n        var OurUint8Array = global.Uint8Array || function () {};\n        function _uint8ArrayToBuffer(chunk) {\n          return Buffer.from(chunk);\n        }\n        function _isUint8Array(obj) {\n          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n        }\n\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var util = require('core-util-is');\n        util.inherits = require('inherits');\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var debugUtil = require('util');\n        var debug = void 0;\n        if (debugUtil && debugUtil.debuglog) {\n          debug = debugUtil.debuglog('stream');\n        } else {\n          debug = function debug() {};\n        }\n        /*</replacement>*/\n\n        var BufferList = require('./internal/streams/BufferList');\n        var destroyImpl = require('./internal/streams/destroy');\n        var StringDecoder;\n\n        util.inherits(Readable, Stream);\n\n        var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\n        function prependListener(emitter, event, fn) {\n          // Sadly this is not cacheable as some libraries bundle their own\n          // event emitter implementation with them.\n          if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n          // This is a hack to make sure that our error handler is attached before any\n          // userland ones.  NEVER DO THIS. This is here only because this code needs\n          // to continue to work with older versions of Node.js that do not include\n          // the prependListener() method. The goal is to eventually remove this hack.\n          if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n        }\n\n        function ReadableState(options, stream) {\n          Duplex = Duplex || require('./_stream_duplex');\n\n          options = options || {};\n\n          // Duplex streams are both readable and writable, but share\n          // the same options object.\n          // However, some cases require setting options to different\n          // values for the readable and the writable sides of the duplex stream.\n          // These options can be provided separately as readableXXX and writableXXX.\n          var isDuplex = stream instanceof Duplex;\n\n          // object stream flag. Used to make read(n) ignore n and to\n          // make all the buffer merging and length checks go away\n          this.objectMode = !!options.objectMode;\n\n          if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n          // the point at which it stops calling _read() to fill the buffer\n          // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n          var hwm = options.highWaterMark;\n          var readableHwm = options.readableHighWaterMark;\n          var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n          if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n          // cast to ints.\n          this.highWaterMark = Math.floor(this.highWaterMark);\n\n          // A linked list is used to store data chunks instead of an array because the\n          // linked list can remove elements from the beginning faster than\n          // array.shift()\n          this.buffer = new BufferList();\n          this.length = 0;\n          this.pipes = null;\n          this.pipesCount = 0;\n          this.flowing = null;\n          this.ended = false;\n          this.endEmitted = false;\n          this.reading = false;\n\n          // a flag to be able to tell if the event 'readable'/'data' is emitted\n          // immediately, or on a later tick.  We set this to true at first, because\n          // any actions that shouldn't happen until \"later\" should generally also\n          // not happen before the first read call.\n          this.sync = true;\n\n          // whenever we return null, then we set a flag to say\n          // that we're awaiting a 'readable' event emission.\n          this.needReadable = false;\n          this.emittedReadable = false;\n          this.readableListening = false;\n          this.resumeScheduled = false;\n\n          // has it been destroyed\n          this.destroyed = false;\n\n          // Crypto is kind of old and crusty.  Historically, its default string\n          // encoding is 'binary' so we have to make this configurable.\n          // Everything else in the universe uses 'utf8', though.\n          this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n          // the number of writers that are awaiting a drain event in .pipe()s\n          this.awaitDrain = 0;\n\n          // if true, a maybeReadMore has been scheduled\n          this.readingMore = false;\n\n          this.decoder = null;\n          this.encoding = null;\n          if (options.encoding) {\n            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n            this.decoder = new StringDecoder(options.encoding);\n            this.encoding = options.encoding;\n          }\n        }\n\n        function Readable(options) {\n          Duplex = Duplex || require('./_stream_duplex');\n\n          if (!(this instanceof Readable)) return new Readable(options);\n\n          this._readableState = new ReadableState(options, this);\n\n          // legacy\n          this.readable = true;\n\n          if (options) {\n            if (typeof options.read === 'function') this._read = options.read;\n\n            if (typeof options.destroy === 'function') this._destroy = options.destroy;\n          }\n\n          Stream.call(this);\n        }\n\n        Object.defineProperty(Readable.prototype, 'destroyed', {\n          get: function get() {\n            if (this._readableState === undefined) {\n              return false;\n            }\n            return this._readableState.destroyed;\n          },\n          set: function set(value) {\n            // we ignore the value if the stream\n            // has not been initialized yet\n            if (!this._readableState) {\n              return;\n            }\n\n            // backward compatibility, the user is explicitly\n            // managing destroyed\n            this._readableState.destroyed = value;\n          } });\n\n\n        Readable.prototype.destroy = destroyImpl.destroy;\n        Readable.prototype._undestroy = destroyImpl.undestroy;\n        Readable.prototype._destroy = function (err, cb) {\n          this.push(null);\n          cb(err);\n        };\n\n        // Manually shove something into the read() buffer.\n        // This returns true if the highWaterMark has not been hit yet,\n        // similar to how Writable.write() returns true if you should\n        // write() some more.\n        Readable.prototype.push = function (chunk, encoding) {\n          var state = this._readableState;\n          var skipChunkCheck;\n\n          if (!state.objectMode) {\n            if (typeof chunk === 'string') {\n              encoding = encoding || state.defaultEncoding;\n              if (encoding !== state.encoding) {\n                chunk = Buffer.from(chunk, encoding);\n                encoding = '';\n              }\n              skipChunkCheck = true;\n            }\n          } else {\n            skipChunkCheck = true;\n          }\n\n          return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n        };\n\n        // Unshift should *always* be something directly out of read()\n        Readable.prototype.unshift = function (chunk) {\n          return readableAddChunk(this, chunk, null, true, false);\n        };\n\n        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n          var state = stream._readableState;\n          if (chunk === null) {\n            state.reading = false;\n            onEofChunk(stream, state);\n          } else {\n            var er;\n            if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n            if (er) {\n              stream.emit('error', er);\n            } else if (state.objectMode || chunk && chunk.length > 0) {\n              if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                chunk = _uint8ArrayToBuffer(chunk);\n              }\n\n              if (addToFront) {\n                if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n              } else if (state.ended) {\n                stream.emit('error', new Error('stream.push() after EOF'));\n              } else {\n                state.reading = false;\n                if (state.decoder && !encoding) {\n                  chunk = state.decoder.write(chunk);\n                  if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n                } else {\n                  addChunk(stream, state, chunk, false);\n                }\n              }\n            } else if (!addToFront) {\n              state.reading = false;\n            }\n          }\n\n          return needMoreData(state);\n        }\n\n        function addChunk(stream, state, chunk, addToFront) {\n          if (state.flowing && state.length === 0 && !state.sync) {\n            stream.emit('data', chunk);\n            stream.read(0);\n          } else {\n            // update the buffer info.\n            state.length += state.objectMode ? 1 : chunk.length;\n            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n            if (state.needReadable) emitReadable(stream);\n          }\n          maybeReadMore(stream, state);\n        }\n\n        function chunkInvalid(state, chunk) {\n          var er;\n          if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n            er = new TypeError('Invalid non-string/buffer chunk');\n          }\n          return er;\n        }\n\n        // if it's past the high water mark, we can push in some more.\n        // Also, if we have no data yet, we can stand some\n        // more bytes.  This is to work around cases where hwm=0,\n        // such as the repl.  Also, if the push() triggered a\n        // readable event, and the user called read(largeNumber) such that\n        // needReadable was set, then we ought to push more, so that another\n        // 'readable' event will be triggered.\n        function needMoreData(state) {\n          return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n        }\n\n        Readable.prototype.isPaused = function () {\n          return this._readableState.flowing === false;\n        };\n\n        // backwards compatibility.\n        Readable.prototype.setEncoding = function (enc) {\n          if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n          this._readableState.decoder = new StringDecoder(enc);\n          this._readableState.encoding = enc;\n          return this;\n        };\n\n        // Don't raise the hwm > 8MB\n        var MAX_HWM = 0x800000;\n        function computeNewHighWaterMark(n) {\n          if (n >= MAX_HWM) {\n            n = MAX_HWM;\n          } else {\n            // Get the next highest power of 2 to prevent increasing hwm excessively in\n            // tiny amounts\n            n--;\n            n |= n >>> 1;\n            n |= n >>> 2;\n            n |= n >>> 4;\n            n |= n >>> 8;\n            n |= n >>> 16;\n            n++;\n          }\n          return n;\n        }\n\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function howMuchToRead(n, state) {\n          if (n <= 0 || state.length === 0 && state.ended) return 0;\n          if (state.objectMode) return 1;\n          if (n !== n) {\n            // Only flow one buffer at a time\n            if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n          }\n          // If we're asking for more than the current hwm, then raise the hwm.\n          if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n          if (n <= state.length) return n;\n          // Don't have enough\n          if (!state.ended) {\n            state.needReadable = true;\n            return 0;\n          }\n          return state.length;\n        }\n\n        // you can override either this method, or the async _read(n) below.\n        Readable.prototype.read = function (n) {\n          debug('read', n);\n          n = parseInt(n, 10);\n          var state = this._readableState;\n          var nOrig = n;\n\n          if (n !== 0) state.emittedReadable = false;\n\n          // if we're doing read(0) to trigger a readable event, but we\n          // already have a bunch of data in the buffer, then just trigger\n          // the 'readable' event and move on.\n          if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n            debug('read: emitReadable', state.length, state.ended);\n            if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n            return null;\n          }\n\n          n = howMuchToRead(n, state);\n\n          // if we've ended, and we're now clear, then finish it up.\n          if (n === 0 && state.ended) {\n            if (state.length === 0) endReadable(this);\n            return null;\n          }\n\n          // All the actual chunk generation logic needs to be\n          // *below* the call to _read.  The reason is that in certain\n          // synthetic stream cases, such as passthrough streams, _read\n          // may be a completely synchronous operation which may change\n          // the state of the read buffer, providing enough data when\n          // before there was *not* enough.\n          //\n          // So, the steps are:\n          // 1. Figure out what the state of things will be after we do\n          // a read from the buffer.\n          //\n          // 2. If that resulting state will trigger a _read, then call _read.\n          // Note that this may be asynchronous, or synchronous.  Yes, it is\n          // deeply ugly to write APIs this way, but that still doesn't mean\n          // that the Readable class should behave improperly, as streams are\n          // designed to be sync/async agnostic.\n          // Take note if the _read call is sync or async (ie, if the read call\n          // has returned yet), so that we know whether or not it's safe to emit\n          // 'readable' etc.\n          //\n          // 3. Actually pull the requested chunks out of the buffer and return.\n\n          // if we need a readable event, then we need to do some reading.\n          var doRead = state.needReadable;\n          debug('need readable', doRead);\n\n          // if we currently have less than the highWaterMark, then also read some\n          if (state.length === 0 || state.length - n < state.highWaterMark) {\n            doRead = true;\n            debug('length less than watermark', doRead);\n          }\n\n          // however, if we've ended, then there's no point, and if we're already\n          // reading, then it's unnecessary.\n          if (state.ended || state.reading) {\n            doRead = false;\n            debug('reading or ended', doRead);\n          } else if (doRead) {\n            debug('do read');\n            state.reading = true;\n            state.sync = true;\n            // if the length is currently zero, then we *need* a readable event.\n            if (state.length === 0) state.needReadable = true;\n            // call internal read method\n            this._read(state.highWaterMark);\n            state.sync = false;\n            // If _read pushed data synchronously, then `reading` will be false,\n            // and we need to re-evaluate how much data we can return to the user.\n            if (!state.reading) n = howMuchToRead(nOrig, state);\n          }\n\n          var ret;\n          if (n > 0) ret = fromList(n, state);else ret = null;\n\n          if (ret === null) {\n            state.needReadable = true;\n            n = 0;\n          } else {\n            state.length -= n;\n          }\n\n          if (state.length === 0) {\n            // If we have nothing in the buffer, then we want to know\n            // as soon as we *do* get something into the buffer.\n            if (!state.ended) state.needReadable = true;\n\n            // If we tried to read() past the EOF, then emit end on the next tick.\n            if (nOrig !== n && state.ended) endReadable(this);\n          }\n\n          if (ret !== null) this.emit('data', ret);\n\n          return ret;\n        };\n\n        function onEofChunk(stream, state) {\n          if (state.ended) return;\n          if (state.decoder) {\n            var chunk = state.decoder.end();\n            if (chunk && chunk.length) {\n              state.buffer.push(chunk);\n              state.length += state.objectMode ? 1 : chunk.length;\n            }\n          }\n          state.ended = true;\n\n          // emit 'readable' now to make sure it gets picked up.\n          emitReadable(stream);\n        }\n\n        // Don't emit readable right away in sync mode, because this can trigger\n        // another read() call => stack overflow.  This way, it might trigger\n        // a nextTick recursion warning, but that's not so bad.\n        function emitReadable(stream) {\n          var state = stream._readableState;\n          state.needReadable = false;\n          if (!state.emittedReadable) {\n            debug('emitReadable', state.flowing);\n            state.emittedReadable = true;\n            if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n          }\n        }\n\n        function emitReadable_(stream) {\n          debug('emit readable');\n          stream.emit('readable');\n          flow(stream);\n        }\n\n        // at this point, the user has presumably seen the 'readable' event,\n        // and called read() to consume some data.  that may have triggered\n        // in turn another _read(n) call, in which case reading = true if\n        // it's in progress.\n        // However, if we're not ended, or reading, and the length < hwm,\n        // then go ahead and try to read some more preemptively.\n        function maybeReadMore(stream, state) {\n          if (!state.readingMore) {\n            state.readingMore = true;\n            pna.nextTick(maybeReadMore_, stream, state);\n          }\n        }\n\n        function maybeReadMore_(stream, state) {\n          var len = state.length;\n          while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n            debug('maybeReadMore read 0');\n            stream.read(0);\n            if (len === state.length)\n              // didn't get any data, stop spinning.\n              break;else len = state.length;\n          }\n          state.readingMore = false;\n        }\n\n        // abstract method.  to be overridden in specific implementation classes.\n        // call cb(er, data) where data is <= n in length.\n        // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n        // arbitrary, and perhaps not very meaningful.\n        Readable.prototype._read = function (n) {\n          this.emit('error', new Error('_read() is not implemented'));\n        };\n\n        Readable.prototype.pipe = function (dest, pipeOpts) {\n          var src = this;\n          var state = this._readableState;\n\n          switch (state.pipesCount) {\n            case 0:\n              state.pipes = dest;\n              break;\n            case 1:\n              state.pipes = [state.pipes, dest];\n              break;\n            default:\n              state.pipes.push(dest);\n              break;}\n\n          state.pipesCount += 1;\n          debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n          var endFn = doEnd ? onend : unpipe;\n          if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n          dest.on('unpipe', onunpipe);\n          function onunpipe(readable, unpipeInfo) {\n            debug('onunpipe');\n            if (readable === src) {\n              if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                unpipeInfo.hasUnpiped = true;\n                cleanup();\n              }\n            }\n          }\n\n          function onend() {\n            debug('onend');\n            dest.end();\n          }\n\n          // when the dest drains, it reduces the awaitDrain counter\n          // on the source.  This would be more elegant with a .once()\n          // handler in flow(), but adding and removing repeatedly is\n          // too slow.\n          var ondrain = pipeOnDrain(src);\n          dest.on('drain', ondrain);\n\n          var cleanedUp = false;\n          function cleanup() {\n            debug('cleanup');\n            // cleanup event handlers once the pipe is broken\n            dest.removeListener('close', onclose);\n            dest.removeListener('finish', onfinish);\n            dest.removeListener('drain', ondrain);\n            dest.removeListener('error', onerror);\n            dest.removeListener('unpipe', onunpipe);\n            src.removeListener('end', onend);\n            src.removeListener('end', unpipe);\n            src.removeListener('data', ondata);\n\n            cleanedUp = true;\n\n            // if the reader is waiting for a drain event from this\n            // specific writer, then it would cause it to never start\n            // flowing again.\n            // So, if this is awaiting a drain, then we just call it now.\n            // If we don't know, then assume that we are waiting for one.\n            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n          }\n\n          // If the user pushes more data while we're writing to dest then we'll end up\n          // in ondata again. However, we only want to increase awaitDrain once because\n          // dest will only emit one 'drain' event for the multiple writes.\n          // => Introduce a guard on increasing awaitDrain.\n          var increasedAwaitDrain = false;\n          src.on('data', ondata);\n          function ondata(chunk) {\n            debug('ondata');\n            increasedAwaitDrain = false;\n            var ret = dest.write(chunk);\n            if (false === ret && !increasedAwaitDrain) {\n              // If the user unpiped during `dest.write()`, it is possible\n              // to get stuck in a permanently paused state if that write\n              // also returned false.\n              // => Check whether `dest` is still a piping destination.\n              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n                debug('false write response, pause', src._readableState.awaitDrain);\n                src._readableState.awaitDrain++;\n                increasedAwaitDrain = true;\n              }\n              src.pause();\n            }\n          }\n\n          // if the dest has an error, then stop piping into it.\n          // however, don't suppress the throwing behavior for this.\n          function onerror(er) {\n            debug('onerror', er);\n            unpipe();\n            dest.removeListener('error', onerror);\n            if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n          }\n\n          // Make sure our error handler is attached before userland ones.\n          prependListener(dest, 'error', onerror);\n\n          // Both close and finish should trigger unpipe, but only once.\n          function onclose() {\n            dest.removeListener('finish', onfinish);\n            unpipe();\n          }\n          dest.once('close', onclose);\n          function onfinish() {\n            debug('onfinish');\n            dest.removeListener('close', onclose);\n            unpipe();\n          }\n          dest.once('finish', onfinish);\n\n          function unpipe() {\n            debug('unpipe');\n            src.unpipe(dest);\n          }\n\n          // tell the dest that it's being piped to\n          dest.emit('pipe', src);\n\n          // start the flow if it hasn't been started already.\n          if (!state.flowing) {\n            debug('pipe resume');\n            src.resume();\n          }\n\n          return dest;\n        };\n\n        function pipeOnDrain(src) {\n          return function () {\n            var state = src._readableState;\n            debug('pipeOnDrain', state.awaitDrain);\n            if (state.awaitDrain) state.awaitDrain--;\n            if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n              state.flowing = true;\n              flow(src);\n            }\n          };\n        }\n\n        Readable.prototype.unpipe = function (dest) {\n          var state = this._readableState;\n          var unpipeInfo = { hasUnpiped: false };\n\n          // if we're not piping anywhere, then do nothing.\n          if (state.pipesCount === 0) return this;\n\n          // just one destination.  most common case.\n          if (state.pipesCount === 1) {\n            // passed in one, but it's not the right one.\n            if (dest && dest !== state.pipes) return this;\n\n            if (!dest) dest = state.pipes;\n\n            // got a match.\n            state.pipes = null;\n            state.pipesCount = 0;\n            state.flowing = false;\n            if (dest) dest.emit('unpipe', this, unpipeInfo);\n            return this;\n          }\n\n          // slow case. multiple pipe destinations.\n\n          if (!dest) {\n            // remove all.\n            var dests = state.pipes;\n            var len = state.pipesCount;\n            state.pipes = null;\n            state.pipesCount = 0;\n            state.flowing = false;\n\n            for (var i = 0; i < len; i++) {\n              dests[i].emit('unpipe', this, unpipeInfo);\n            }return this;\n          }\n\n          // try to find the right one.\n          var index = indexOf(state.pipes, dest);\n          if (index === -1) return this;\n\n          state.pipes.splice(index, 1);\n          state.pipesCount -= 1;\n          if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n          dest.emit('unpipe', this, unpipeInfo);\n\n          return this;\n        };\n\n        // set up data events if they are asked for\n        // Ensure readable listeners eventually get something\n        Readable.prototype.on = function (ev, fn) {\n          var res = Stream.prototype.on.call(this, ev, fn);\n\n          if (ev === 'data') {\n            // Start flowing on next tick if stream isn't explicitly paused\n            if (this._readableState.flowing !== false) this.resume();\n          } else if (ev === 'readable') {\n            var state = this._readableState;\n            if (!state.endEmitted && !state.readableListening) {\n              state.readableListening = state.needReadable = true;\n              state.emittedReadable = false;\n              if (!state.reading) {\n                pna.nextTick(nReadingNextTick, this);\n              } else if (state.length) {\n                emitReadable(this);\n              }\n            }\n          }\n\n          return res;\n        };\n        Readable.prototype.addListener = Readable.prototype.on;\n\n        function nReadingNextTick(self) {\n          debug('readable nexttick read 0');\n          self.read(0);\n        }\n\n        // pause() and resume() are remnants of the legacy readable stream API\n        // If the user uses them, then switch into old mode.\n        Readable.prototype.resume = function () {\n          var state = this._readableState;\n          if (!state.flowing) {\n            debug('resume');\n            state.flowing = true;\n            resume(this, state);\n          }\n          return this;\n        };\n\n        function resume(stream, state) {\n          if (!state.resumeScheduled) {\n            state.resumeScheduled = true;\n            pna.nextTick(resume_, stream, state);\n          }\n        }\n\n        function resume_(stream, state) {\n          if (!state.reading) {\n            debug('resume read 0');\n            stream.read(0);\n          }\n\n          state.resumeScheduled = false;\n          state.awaitDrain = 0;\n          stream.emit('resume');\n          flow(stream);\n          if (state.flowing && !state.reading) stream.read(0);\n        }\n\n        Readable.prototype.pause = function () {\n          debug('call pause flowing=%j', this._readableState.flowing);\n          if (false !== this._readableState.flowing) {\n            debug('pause');\n            this._readableState.flowing = false;\n            this.emit('pause');\n          }\n          return this;\n        };\n\n        function flow(stream) {\n          var state = stream._readableState;\n          debug('flow', state.flowing);\n          while (state.flowing && stream.read() !== null) {}\n        }\n\n        // wrap an old-style stream as the async data source.\n        // This is *not* part of the readable stream interface.\n        // It is an ugly unfortunate mess of history.\n        Readable.prototype.wrap = function (stream) {\n          var _this = this;\n\n          var state = this._readableState;\n          var paused = false;\n\n          stream.on('end', function () {\n            debug('wrapped end');\n            if (state.decoder && !state.ended) {\n              var chunk = state.decoder.end();\n              if (chunk && chunk.length) _this.push(chunk);\n            }\n\n            _this.push(null);\n          });\n\n          stream.on('data', function (chunk) {\n            debug('wrapped data');\n            if (state.decoder) chunk = state.decoder.write(chunk);\n\n            // don't skip over falsy values in objectMode\n            if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n            var ret = _this.push(chunk);\n            if (!ret) {\n              paused = true;\n              stream.pause();\n            }\n          });\n\n          // proxy all the other methods.\n          // important when wrapping filters and duplexes.\n          for (var i in stream) {\n            if (this[i] === undefined && typeof stream[i] === 'function') {\n              this[i] = function (method) {\n                return function () {\n                  return stream[method].apply(stream, arguments);\n                };\n              }(i);\n            }\n          }\n\n          // proxy certain important events.\n          for (var n = 0; n < kProxyEvents.length; n++) {\n            stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n          }\n\n          // when we try to consume some more bytes, simply unpause the\n          // underlying stream.\n          this._read = function (n) {\n            debug('wrapped _read', n);\n            if (paused) {\n              paused = false;\n              stream.resume();\n            }\n          };\n\n          return this;\n        };\n\n        Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n          // making it explicit this property is not enumerable\n          // because otherwise some prototype manipulation in\n          // userland will fail\n          enumerable: false,\n          get: function get() {\n            return this._readableState.highWaterMark;\n          } });\n\n\n        // exposed for testing purposes only.\n        Readable._fromList = fromList;\n\n        // Pluck off n bytes from an array of buffers.\n        // Length is the combined lengths of all the buffers in the list.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function fromList(n, state) {\n          // nothing buffered\n          if (state.length === 0) return null;\n\n          var ret;\n          if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n            // read it all, truncate the list\n            if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n            state.buffer.clear();\n          } else {\n            // read part of list\n            ret = fromListPartial(n, state.buffer, state.decoder);\n          }\n\n          return ret;\n        }\n\n        // Extracts only enough buffered data to satisfy the amount requested.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function fromListPartial(n, list, hasStrings) {\n          var ret;\n          if (n < list.head.data.length) {\n            // slice is the same for buffers and strings\n            ret = list.head.data.slice(0, n);\n            list.head.data = list.head.data.slice(n);\n          } else if (n === list.head.data.length) {\n            // first chunk is a perfect match\n            ret = list.shift();\n          } else {\n            // result spans more than one buffer\n            ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n          }\n          return ret;\n        }\n\n        // Copies a specified amount of characters from the list of buffered data\n        // chunks.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function copyFromBufferString(n, list) {\n          var p = list.head;\n          var c = 1;\n          var ret = p.data;\n          n -= ret.length;\n          while (p = p.next) {\n            var str = p.data;\n            var nb = n > str.length ? str.length : n;\n            if (nb === str.length) ret += str;else ret += str.slice(0, n);\n            n -= nb;\n            if (n === 0) {\n              if (nb === str.length) {\n                ++c;\n                if (p.next) list.head = p.next;else list.head = list.tail = null;\n              } else {\n                list.head = p;\n                p.data = str.slice(nb);\n              }\n              break;\n            }\n            ++c;\n          }\n          list.length -= c;\n          return ret;\n        }\n\n        // Copies a specified amount of bytes from the list of buffered data chunks.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function copyFromBuffer(n, list) {\n          var ret = Buffer.allocUnsafe(n);\n          var p = list.head;\n          var c = 1;\n          p.data.copy(ret);\n          n -= p.data.length;\n          while (p = p.next) {\n            var buf = p.data;\n            var nb = n > buf.length ? buf.length : n;\n            buf.copy(ret, ret.length - n, 0, nb);\n            n -= nb;\n            if (n === 0) {\n              if (nb === buf.length) {\n                ++c;\n                if (p.next) list.head = p.next;else list.head = list.tail = null;\n              } else {\n                list.head = p;\n                p.data = buf.slice(nb);\n              }\n              break;\n            }\n            ++c;\n          }\n          list.length -= c;\n          return ret;\n        }\n\n        function endReadable(stream) {\n          var state = stream._readableState;\n\n          // If we get here before consuming all the bytes, then that is a\n          // bug in node.  Should never happen.\n          if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n          if (!state.endEmitted) {\n            state.ended = true;\n            pna.nextTick(endReadableNT, state, stream);\n          }\n        }\n\n        function endReadableNT(state, stream) {\n          // Check that we didn't get one last unshift.\n          if (!state.endEmitted && state.length === 0) {\n            state.endEmitted = true;\n            stream.readable = false;\n            stream.emit('end');\n          }\n        }\n\n        function indexOf(xs, x) {\n          for (var i = 0, l = xs.length; i < l; i++) {\n            if (xs[i] === x) return i;\n          }\n          return -1;\n        }\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, { \"./_stream_duplex\": 98, \"./internal/streams/BufferList\": 103, \"./internal/streams/destroy\": 104, \"./internal/streams/stream\": 105, \"_process\": 92, \"core-util-is\": 14, \"events\": 13, \"inherits\": 80, \"isarray\": 106, \"process-nextick-args\": 91, \"safe-buffer\": 110, \"string_decoder/\": 107, \"util\": 11 }], 101: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      // a transform stream is a readable/writable stream where you do\n      // something with the data.  Sometimes it's called a \"filter\",\n      // but that's not a great name for it, since that implies a thing where\n      // some bits pass through, and others are simply ignored.  (That would\n      // be a valid example of a transform, of course.)\n      //\n      // While the output is causally related to the input, it's not a\n      // necessarily symmetric or synchronous transformation.  For example,\n      // a zlib stream might take multiple plain-text writes(), and then\n      // emit a single compressed chunk some time in the future.\n      //\n      // Here's how this works:\n      //\n      // The Transform stream has all the aspects of the readable and writable\n      // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n      // internally, and returns false if there's a lot of pending writes\n      // buffered up.  When you call read(), that calls _read(n) until\n      // there's enough pending readable data buffered up.\n      //\n      // In a transform stream, the written data is placed in a buffer.  When\n      // _read(n) is called, it transforms the queued up data, calling the\n      // buffered _write cb's as it consumes chunks.  If consuming a single\n      // written chunk would result in multiple output chunks, then the first\n      // outputted bit calls the readcb, and subsequent chunks just go into\n      // the read buffer, and will cause it to emit 'readable' if necessary.\n      //\n      // This way, back-pressure is actually determined by the reading side,\n      // since _read has to be called to start processing a new chunk.  However,\n      // a pathological inflate type of transform can cause excessive buffering\n      // here.  For example, imagine a stream where every byte of input is\n      // interpreted as an integer from 0-255, and then results in that many\n      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n      // 1kb of data being output.  In this case, you could write a very small\n      // amount of input, and end up with a very large amount of output.  In\n      // such a pathological inflating mechanism, there'd be no way to tell\n      // the system to stop doing the transform.  A single 4MB write could\n      // cause the system to run out of memory.\n      //\n      // However, even in such a pathological case, only a single written chunk\n      // would be consumed, and then the rest would wait (un-transformed) until\n      // the results of the previous transformed chunk were consumed.\n\n      'use strict';\n\n      module.exports = Transform;\n\n      var Duplex = require('./_stream_duplex');\n\n      /*<replacement>*/\n      var util = require('core-util-is');\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(Transform, Duplex);\n\n      function afterTransform(er, data) {\n        var ts = this._transformState;\n        ts.transforming = false;\n\n        var cb = ts.writecb;\n\n        if (!cb) {\n          return this.emit('error', new Error('write callback called multiple times'));\n        }\n\n        ts.writechunk = null;\n        ts.writecb = null;\n\n        if (data != null) // single equals check for both `null` and `undefined`\n          this.push(data);\n\n        cb(er);\n\n        var rs = this._readableState;\n        rs.reading = false;\n        if (rs.needReadable || rs.length < rs.highWaterMark) {\n          this._read(rs.highWaterMark);\n        }\n      }\n\n      function Transform(options) {\n        if (!(this instanceof Transform)) return new Transform(options);\n\n        Duplex.call(this, options);\n\n        this._transformState = {\n          afterTransform: afterTransform.bind(this),\n          needTransform: false,\n          transforming: false,\n          writecb: null,\n          writechunk: null,\n          writeencoding: null };\n\n\n        // start out asking for a readable event once data is transformed.\n        this._readableState.needReadable = true;\n\n        // we have implemented the _read method, and done the other things\n        // that Readable wants before the first _read call, so unset the\n        // sync guard flag.\n        this._readableState.sync = false;\n\n        if (options) {\n          if (typeof options.transform === 'function') this._transform = options.transform;\n\n          if (typeof options.flush === 'function') this._flush = options.flush;\n        }\n\n        // When the writable side finishes, then flush out anything remaining.\n        this.on('prefinish', prefinish);\n      }\n\n      function prefinish() {\n        var _this = this;\n\n        if (typeof this._flush === 'function') {\n          this._flush(function (er, data) {\n            done(_this, er, data);\n          });\n        } else {\n          done(this, null, null);\n        }\n      }\n\n      Transform.prototype.push = function (chunk, encoding) {\n        this._transformState.needTransform = false;\n        return Duplex.prototype.push.call(this, chunk, encoding);\n      };\n\n      // This is the part where you do stuff!\n      // override this function in implementation classes.\n      // 'chunk' is an input chunk.\n      //\n      // Call `push(newChunk)` to pass along transformed output\n      // to the readable side.  You may call 'push' zero or more times.\n      //\n      // Call `cb(err)` when you are done with this chunk.  If you pass\n      // an error, then that'll put the hurt on the whole operation.  If you\n      // never call cb(), then you'll never get another chunk.\n      Transform.prototype._transform = function (chunk, encoding, cb) {\n        throw new Error('_transform() is not implemented');\n      };\n\n      Transform.prototype._write = function (chunk, encoding, cb) {\n        var ts = this._transformState;\n        ts.writecb = cb;\n        ts.writechunk = chunk;\n        ts.writeencoding = encoding;\n        if (!ts.transforming) {\n          var rs = this._readableState;\n          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n        }\n      };\n\n      // Doesn't matter what the args are here.\n      // _transform does all the work.\n      // That we got here means that the readable side wants more data.\n      Transform.prototype._read = function (n) {\n        var ts = this._transformState;\n\n        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n          ts.transforming = true;\n          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n        } else {\n          // mark that we need a transform, so that any data that comes in\n          // will get processed, now that we've asked for it.\n          ts.needTransform = true;\n        }\n      };\n\n      Transform.prototype._destroy = function (err, cb) {\n        var _this2 = this;\n\n        Duplex.prototype._destroy.call(this, err, function (err2) {\n          cb(err2);\n          _this2.emit('close');\n        });\n      };\n\n      function done(stream, er, data) {\n        if (er) return stream.emit('error', er);\n\n        if (data != null) // single equals check for both `null` and `undefined`\n          stream.push(data);\n\n        // if there's nothing in the write buffer, then that means\n        // that nothing more will ever be provided\n        if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n        if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n        return stream.push(null);\n      }\n    }, { \"./_stream_duplex\": 98, \"core-util-is\": 14, \"inherits\": 80 }], 102: [function (require, module, exports) {\n      (function (process, global, setImmediate) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        // A bit simpler than readable streams.\n        // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n        // the drain event emission and buffering.\n\n        'use strict';\n\n        /*<replacement>*/\n\n        var pna = require('process-nextick-args');\n        /*</replacement>*/\n\n        module.exports = Writable;\n\n        /* <replacement> */\n        function WriteReq(chunk, encoding, cb) {\n          this.chunk = chunk;\n          this.encoding = encoding;\n          this.callback = cb;\n          this.next = null;\n        }\n\n        // It seems a linked list but it is not\n        // there will be only 2 of these for each stream\n        function CorkedRequest(state) {\n          var _this = this;\n\n          this.next = null;\n          this.entry = null;\n          this.finish = function () {\n            onCorkedFinish(_this, state);\n          };\n        }\n        /* </replacement> */\n\n        /*<replacement>*/\n        var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Duplex;\n        /*</replacement>*/\n\n        Writable.WritableState = WritableState;\n\n        /*<replacement>*/\n        var util = require('core-util-is');\n        util.inherits = require('inherits');\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var internalUtil = {\n          deprecate: require('util-deprecate') };\n\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Stream = require('./internal/streams/stream');\n        /*</replacement>*/\n\n        /*<replacement>*/\n\n        var Buffer = require('safe-buffer').Buffer;\n        var OurUint8Array = global.Uint8Array || function () {};\n        function _uint8ArrayToBuffer(chunk) {\n          return Buffer.from(chunk);\n        }\n        function _isUint8Array(obj) {\n          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n        }\n\n        /*</replacement>*/\n\n        var destroyImpl = require('./internal/streams/destroy');\n\n        util.inherits(Writable, Stream);\n\n        function nop() {}\n\n        function WritableState(options, stream) {\n          Duplex = Duplex || require('./_stream_duplex');\n\n          options = options || {};\n\n          // Duplex streams are both readable and writable, but share\n          // the same options object.\n          // However, some cases require setting options to different\n          // values for the readable and the writable sides of the duplex stream.\n          // These options can be provided separately as readableXXX and writableXXX.\n          var isDuplex = stream instanceof Duplex;\n\n          // object stream flag to indicate whether or not this stream\n          // contains buffers or objects.\n          this.objectMode = !!options.objectMode;\n\n          if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n          // the point at which write() starts returning false\n          // Note: 0 is a valid value, means that we always return false if\n          // the entire buffer is not flushed immediately on write()\n          var hwm = options.highWaterMark;\n          var writableHwm = options.writableHighWaterMark;\n          var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n          if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n          // cast to ints.\n          this.highWaterMark = Math.floor(this.highWaterMark);\n\n          // if _final has been called\n          this.finalCalled = false;\n\n          // drain event flag.\n          this.needDrain = false;\n          // at the start of calling end()\n          this.ending = false;\n          // when end() has been called, and returned\n          this.ended = false;\n          // when 'finish' is emitted\n          this.finished = false;\n\n          // has it been destroyed\n          this.destroyed = false;\n\n          // should we decode strings into buffers before passing to _write?\n          // this is here so that some node-core streams can optimize string\n          // handling at a lower level.\n          var noDecode = options.decodeStrings === false;\n          this.decodeStrings = !noDecode;\n\n          // Crypto is kind of old and crusty.  Historically, its default string\n          // encoding is 'binary' so we have to make this configurable.\n          // Everything else in the universe uses 'utf8', though.\n          this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n          // not an actual buffer we keep track of, but a measurement\n          // of how much we're waiting to get pushed to some underlying\n          // socket or file.\n          this.length = 0;\n\n          // a flag to see when we're in the middle of a write.\n          this.writing = false;\n\n          // when true all writes will be buffered until .uncork() call\n          this.corked = 0;\n\n          // a flag to be able to tell if the onwrite cb is called immediately,\n          // or on a later tick.  We set this to true at first, because any\n          // actions that shouldn't happen until \"later\" should generally also\n          // not happen before the first write call.\n          this.sync = true;\n\n          // a flag to know if we're processing previously buffered items, which\n          // may call the _write() callback in the same tick, so that we don't\n          // end up in an overlapped onwrite situation.\n          this.bufferProcessing = false;\n\n          // the callback that's passed to _write(chunk,cb)\n          this.onwrite = function (er) {\n            onwrite(stream, er);\n          };\n\n          // the callback that the user supplies to write(chunk,encoding,cb)\n          this.writecb = null;\n\n          // the amount that is being written when _write is called.\n          this.writelen = 0;\n\n          this.bufferedRequest = null;\n          this.lastBufferedRequest = null;\n\n          // number of pending user-supplied write callbacks\n          // this must be 0 before 'finish' can be emitted\n          this.pendingcb = 0;\n\n          // emit prefinish if the only thing we're waiting for is _write cbs\n          // This is relevant for synchronous Transform streams\n          this.prefinished = false;\n\n          // True if the error was already emitted and should not be thrown again\n          this.errorEmitted = false;\n\n          // count buffered requests\n          this.bufferedRequestCount = 0;\n\n          // allocate the first CorkedRequest, there is always\n          // one allocated and free to use, and we maintain at most two\n          this.corkedRequestsFree = new CorkedRequest(this);\n        }\n\n        WritableState.prototype.getBuffer = function getBuffer() {\n          var current = this.bufferedRequest;\n          var out = [];\n          while (current) {\n            out.push(current);\n            current = current.next;\n          }\n          return out;\n        };\n\n        (function () {\n          try {\n            Object.defineProperty(WritableState.prototype, 'buffer', {\n              get: internalUtil.deprecate(function () {\n                return this.getBuffer();\n              }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003') });\n\n          } catch (_) {}\n        })();\n\n        // Test _writableState for inheritance to account for Duplex streams,\n        // whose prototype chain only points to Readable.\n        var realHasInstance;\n        if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n          realHasInstance = Function.prototype[Symbol.hasInstance];\n          Object.defineProperty(Writable, Symbol.hasInstance, {\n            value: function value(object) {\n              if (realHasInstance.call(this, object)) return true;\n              if (this !== Writable) return false;\n\n              return object && object._writableState instanceof WritableState;\n            } });\n\n        } else {\n          realHasInstance = function realHasInstance(object) {\n            return object instanceof this;\n          };\n        }\n\n        function Writable(options) {\n          Duplex = Duplex || require('./_stream_duplex');\n\n          // Writable ctor is applied to Duplexes, too.\n          // `realHasInstance` is necessary because using plain `instanceof`\n          // would return false, as no `_writableState` property is attached.\n\n          // Trying to use the custom `instanceof` for Writable here will also break the\n          // Node.js LazyTransform implementation, which has a non-trivial getter for\n          // `_writableState` that would lead to infinite recursion.\n          if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n            return new Writable(options);\n          }\n\n          this._writableState = new WritableState(options, this);\n\n          // legacy.\n          this.writable = true;\n\n          if (options) {\n            if (typeof options.write === 'function') this._write = options.write;\n\n            if (typeof options.writev === 'function') this._writev = options.writev;\n\n            if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n            if (typeof options.final === 'function') this._final = options.final;\n          }\n\n          Stream.call(this);\n        }\n\n        // Otherwise people can pipe Writable streams, which is just wrong.\n        Writable.prototype.pipe = function () {\n          this.emit('error', new Error('Cannot pipe, not readable'));\n        };\n\n        function writeAfterEnd(stream, cb) {\n          var er = new Error('write after end');\n          // TODO: defer error events consistently everywhere, not just the cb\n          stream.emit('error', er);\n          pna.nextTick(cb, er);\n        }\n\n        // Checks that a user-supplied chunk is valid, especially for the particular\n        // mode the stream is in. Currently this means that `null` is never accepted\n        // and undefined/non-string values are only allowed in object mode.\n        function validChunk(stream, state, chunk, cb) {\n          var valid = true;\n          var er = false;\n\n          if (chunk === null) {\n            er = new TypeError('May not write null values to stream');\n          } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n            er = new TypeError('Invalid non-string/buffer chunk');\n          }\n          if (er) {\n            stream.emit('error', er);\n            pna.nextTick(cb, er);\n            valid = false;\n          }\n          return valid;\n        }\n\n        Writable.prototype.write = function (chunk, encoding, cb) {\n          var state = this._writableState;\n          var ret = false;\n          var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n          if (isBuf && !Buffer.isBuffer(chunk)) {\n            chunk = _uint8ArrayToBuffer(chunk);\n          }\n\n          if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = null;\n          }\n\n          if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n          if (typeof cb !== 'function') cb = nop;\n\n          if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n            state.pendingcb++;\n            ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n          }\n\n          return ret;\n        };\n\n        Writable.prototype.cork = function () {\n          var state = this._writableState;\n\n          state.corked++;\n        };\n\n        Writable.prototype.uncork = function () {\n          var state = this._writableState;\n\n          if (state.corked) {\n            state.corked--;\n\n            if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n          }\n        };\n\n        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n          // node::ParseEncoding() requires lower case.\n          if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n          if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n          this._writableState.defaultEncoding = encoding;\n          return this;\n        };\n\n        function decodeChunk(state, chunk, encoding) {\n          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n          }\n          return chunk;\n        }\n\n        Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n          // making it explicit this property is not enumerable\n          // because otherwise some prototype manipulation in\n          // userland will fail\n          enumerable: false,\n          get: function get() {\n            return this._writableState.highWaterMark;\n          } });\n\n\n        // if we're already writing something, then just put this\n        // in the queue, and wait our turn.  Otherwise, call _write\n        // If we return false, then we need a drain event, so set that flag.\n        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n          if (!isBuf) {\n            var newChunk = decodeChunk(state, chunk, encoding);\n            if (chunk !== newChunk) {\n              isBuf = true;\n              encoding = 'buffer';\n              chunk = newChunk;\n            }\n          }\n          var len = state.objectMode ? 1 : chunk.length;\n\n          state.length += len;\n\n          var ret = state.length < state.highWaterMark;\n          // we must ensure that previous needDrain will not be reset to false.\n          if (!ret) state.needDrain = true;\n\n          if (state.writing || state.corked) {\n            var last = state.lastBufferedRequest;\n            state.lastBufferedRequest = {\n              chunk: chunk,\n              encoding: encoding,\n              isBuf: isBuf,\n              callback: cb,\n              next: null };\n\n            if (last) {\n              last.next = state.lastBufferedRequest;\n            } else {\n              state.bufferedRequest = state.lastBufferedRequest;\n            }\n            state.bufferedRequestCount += 1;\n          } else {\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n          }\n\n          return ret;\n        }\n\n        function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n          state.writelen = len;\n          state.writecb = cb;\n          state.writing = true;\n          state.sync = true;\n          if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n          state.sync = false;\n        }\n\n        function onwriteError(stream, state, sync, er, cb) {\n          --state.pendingcb;\n\n          if (sync) {\n            // defer the callback if we are being called synchronously\n            // to avoid piling up things on the stack\n            pna.nextTick(cb, er);\n            // this can emit finish, and it will always happen\n            // after error\n            pna.nextTick(finishMaybe, stream, state);\n            stream._writableState.errorEmitted = true;\n            stream.emit('error', er);\n          } else {\n            // the caller expect this to happen before if\n            // it is async\n            cb(er);\n            stream._writableState.errorEmitted = true;\n            stream.emit('error', er);\n            // this can emit finish, but finish must\n            // always follow error\n            finishMaybe(stream, state);\n          }\n        }\n\n        function onwriteStateUpdate(state) {\n          state.writing = false;\n          state.writecb = null;\n          state.length -= state.writelen;\n          state.writelen = 0;\n        }\n\n        function onwrite(stream, er) {\n          var state = stream._writableState;\n          var sync = state.sync;\n          var cb = state.writecb;\n\n          onwriteStateUpdate(state);\n\n          if (er) onwriteError(stream, state, sync, er, cb);else {\n            // Check if we're actually ready to finish, but don't emit yet\n            var finished = needFinish(state);\n\n            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n              clearBuffer(stream, state);\n            }\n\n            if (sync) {\n              /*<replacement>*/\n              asyncWrite(afterWrite, stream, state, finished, cb);\n              /*</replacement>*/\n            } else {\n              afterWrite(stream, state, finished, cb);\n            }\n          }\n        }\n\n        function afterWrite(stream, state, finished, cb) {\n          if (!finished) onwriteDrain(stream, state);\n          state.pendingcb--;\n          cb();\n          finishMaybe(stream, state);\n        }\n\n        // Must force callback to be called on nextTick, so that we don't\n        // emit 'drain' before the write() consumer gets the 'false' return\n        // value, and has a chance to attach a 'drain' listener.\n        function onwriteDrain(stream, state) {\n          if (state.length === 0 && state.needDrain) {\n            state.needDrain = false;\n            stream.emit('drain');\n          }\n        }\n\n        // if there's something in the buffer waiting, then process it\n        function clearBuffer(stream, state) {\n          state.bufferProcessing = true;\n          var entry = state.bufferedRequest;\n\n          if (stream._writev && entry && entry.next) {\n            // Fast case, write everything using _writev()\n            var l = state.bufferedRequestCount;\n            var buffer = new Array(l);\n            var holder = state.corkedRequestsFree;\n            holder.entry = entry;\n\n            var count = 0;\n            var allBuffers = true;\n            while (entry) {\n              buffer[count] = entry;\n              if (!entry.isBuf) allBuffers = false;\n              entry = entry.next;\n              count += 1;\n            }\n            buffer.allBuffers = allBuffers;\n\n            doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n            // doWrite is almost always async, defer these to save a bit of time\n            // as the hot path ends with doWrite\n            state.pendingcb++;\n            state.lastBufferedRequest = null;\n            if (holder.next) {\n              state.corkedRequestsFree = holder.next;\n              holder.next = null;\n            } else {\n              state.corkedRequestsFree = new CorkedRequest(state);\n            }\n            state.bufferedRequestCount = 0;\n          } else {\n            // Slow case, write chunks one-by-one\n            while (entry) {\n              var chunk = entry.chunk;\n              var encoding = entry.encoding;\n              var cb = entry.callback;\n              var len = state.objectMode ? 1 : chunk.length;\n\n              doWrite(stream, state, false, len, chunk, encoding, cb);\n              entry = entry.next;\n              state.bufferedRequestCount--;\n              // if we didn't call the onwrite immediately, then\n              // it means that we need to wait until it does.\n              // also, that means that the chunk and cb are currently\n              // being processed, so move the buffer counter past them.\n              if (state.writing) {\n                break;\n              }\n            }\n\n            if (entry === null) state.lastBufferedRequest = null;\n          }\n\n          state.bufferedRequest = entry;\n          state.bufferProcessing = false;\n        }\n\n        Writable.prototype._write = function (chunk, encoding, cb) {\n          cb(new Error('_write() is not implemented'));\n        };\n\n        Writable.prototype._writev = null;\n\n        Writable.prototype.end = function (chunk, encoding, cb) {\n          var state = this._writableState;\n\n          if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = null;\n            encoding = null;\n          } else if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = null;\n          }\n\n          if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n          // .end() fully uncorks\n          if (state.corked) {\n            state.corked = 1;\n            this.uncork();\n          }\n\n          // ignore unnecessary end() calls.\n          if (!state.ending && !state.finished) endWritable(this, state, cb);\n        };\n\n        function needFinish(state) {\n          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n        }\n        function callFinal(stream, state) {\n          stream._final(function (err) {\n            state.pendingcb--;\n            if (err) {\n              stream.emit('error', err);\n            }\n            state.prefinished = true;\n            stream.emit('prefinish');\n            finishMaybe(stream, state);\n          });\n        }\n        function prefinish(stream, state) {\n          if (!state.prefinished && !state.finalCalled) {\n            if (typeof stream._final === 'function') {\n              state.pendingcb++;\n              state.finalCalled = true;\n              pna.nextTick(callFinal, stream, state);\n            } else {\n              state.prefinished = true;\n              stream.emit('prefinish');\n            }\n          }\n        }\n\n        function finishMaybe(stream, state) {\n          var need = needFinish(state);\n          if (need) {\n            prefinish(stream, state);\n            if (state.pendingcb === 0) {\n              state.finished = true;\n              stream.emit('finish');\n            }\n          }\n          return need;\n        }\n\n        function endWritable(stream, state, cb) {\n          state.ending = true;\n          finishMaybe(stream, state);\n          if (cb) {\n            if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n          }\n          state.ended = true;\n          stream.writable = false;\n        }\n\n        function onCorkedFinish(corkReq, state, err) {\n          var entry = corkReq.entry;\n          corkReq.entry = null;\n          while (entry) {\n            var cb = entry.callback;\n            state.pendingcb--;\n            cb(err);\n            entry = entry.next;\n          }\n          if (state.corkedRequestsFree) {\n            state.corkedRequestsFree.next = corkReq;\n          } else {\n            state.corkedRequestsFree = corkReq;\n          }\n        }\n\n        Object.defineProperty(Writable.prototype, 'destroyed', {\n          get: function get() {\n            if (this._writableState === undefined) {\n              return false;\n            }\n            return this._writableState.destroyed;\n          },\n          set: function set(value) {\n            // we ignore the value if the stream\n            // has not been initialized yet\n            if (!this._writableState) {\n              return;\n            }\n\n            // backward compatibility, the user is explicitly\n            // managing destroyed\n            this._writableState.destroyed = value;\n          } });\n\n\n        Writable.prototype.destroy = destroyImpl.destroy;\n        Writable.prototype._undestroy = destroyImpl.undestroy;\n        Writable.prototype._destroy = function (err, cb) {\n          this.end();\n          cb(err);\n        };\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"timers\").setImmediate);\n    }, { \"./_stream_duplex\": 98, \"./internal/streams/destroy\": 104, \"./internal/streams/stream\": 105, \"_process\": 92, \"core-util-is\": 14, \"inherits\": 80, \"process-nextick-args\": 91, \"safe-buffer\": 110, \"timers\": 112, \"util-deprecate\": 115 }], 103: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n      var Buffer = require('safe-buffer').Buffer;\n      var util = require('util');\n\n      function copyBuffer(src, target, offset) {\n        src.copy(target, offset);\n      }\n\n      module.exports = function () {\n        function BufferList() {\n          _classCallCheck(this, BufferList);\n\n          this.head = null;\n          this.tail = null;\n          this.length = 0;\n        }\n\n        BufferList.prototype.push = function push(v) {\n          var entry = { data: v, next: null };\n          if (this.length > 0) this.tail.next = entry;else this.head = entry;\n          this.tail = entry;\n          ++this.length;\n        };\n\n        BufferList.prototype.unshift = function unshift(v) {\n          var entry = { data: v, next: this.head };\n          if (this.length === 0) this.tail = entry;\n          this.head = entry;\n          ++this.length;\n        };\n\n        BufferList.prototype.shift = function shift() {\n          if (this.length === 0) return;\n          var ret = this.head.data;\n          if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n          --this.length;\n          return ret;\n        };\n\n        BufferList.prototype.clear = function clear() {\n          this.head = this.tail = null;\n          this.length = 0;\n        };\n\n        BufferList.prototype.join = function join(s) {\n          if (this.length === 0) return '';\n          var p = this.head;\n          var ret = '' + p.data;\n          while (p = p.next) {\n            ret += s + p.data;\n          }return ret;\n        };\n\n        BufferList.prototype.concat = function concat(n) {\n          if (this.length === 0) return Buffer.alloc(0);\n          if (this.length === 1) return this.head.data;\n          var ret = Buffer.allocUnsafe(n >>> 0);\n          var p = this.head;\n          var i = 0;\n          while (p) {\n            copyBuffer(p.data, ret, i);\n            i += p.data.length;\n            p = p.next;\n          }\n          return ret;\n        };\n\n        return BufferList;\n      }();\n\n      if (util && util.inspect && util.inspect.custom) {\n        module.exports.prototype[util.inspect.custom] = function () {\n          var obj = util.inspect({ length: this.length });\n          return this.constructor.name + ' ' + obj;\n        };\n      }\n    }, { \"safe-buffer\": 110, \"util\": 11 }], 104: [function (require, module, exports) {\n      'use strict';\n\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n      // undocumented cb() API, needed for core, not for public API\n      function destroy(err, cb) {\n        var _this = this;\n\n        var readableDestroyed = this._readableState && this._readableState.destroyed;\n        var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n        if (readableDestroyed || writableDestroyed) {\n          if (cb) {\n            cb(err);\n          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n            pna.nextTick(emitErrorNT, this, err);\n          }\n          return this;\n        }\n\n        // we set destroyed to true before firing error callbacks in order\n        // to make it re-entrance safe in case destroy() is called within callbacks\n\n        if (this._readableState) {\n          this._readableState.destroyed = true;\n        }\n\n        // if this is a duplex stream mark the writable part as destroyed as well\n        if (this._writableState) {\n          this._writableState.destroyed = true;\n        }\n\n        this._destroy(err || null, function (err) {\n          if (!cb && err) {\n            pna.nextTick(emitErrorNT, _this, err);\n            if (_this._writableState) {\n              _this._writableState.errorEmitted = true;\n            }\n          } else if (cb) {\n            cb(err);\n          }\n        });\n\n        return this;\n      }\n\n      function undestroy() {\n        if (this._readableState) {\n          this._readableState.destroyed = false;\n          this._readableState.reading = false;\n          this._readableState.ended = false;\n          this._readableState.endEmitted = false;\n        }\n\n        if (this._writableState) {\n          this._writableState.destroyed = false;\n          this._writableState.ended = false;\n          this._writableState.ending = false;\n          this._writableState.finished = false;\n          this._writableState.errorEmitted = false;\n        }\n      }\n\n      function emitErrorNT(self, err) {\n        self.emit('error', err);\n      }\n\n      module.exports = {\n        destroy: destroy,\n        undestroy: undestroy };\n\n    }, { \"process-nextick-args\": 91 }], 105: [function (require, module, exports) {\n      module.exports = require('events').EventEmitter;\n\n    }, { \"events\": 13 }], 106: [function (require, module, exports) {\n      var toString = {}.toString;\n\n      module.exports = Array.isArray || function (arr) {\n        return toString.call(arr) == '[object Array]';\n      };\n\n    }, {}], 107: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      /*<replacement>*/\n\n      var Buffer = require('safe-buffer').Buffer;\n      /*</replacement>*/\n\n      var isEncoding = Buffer.isEncoding || function (encoding) {\n        encoding = '' + encoding;\n        switch (encoding && encoding.toLowerCase()) {\n          case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n            return true;\n          default:\n            return false;}\n\n      };\n\n      function _normalizeEncoding(enc) {\n        if (!enc) return 'utf8';\n        var retried;\n        while (true) {\n          switch (enc) {\n            case 'utf8':\n            case 'utf-8':\n              return 'utf8';\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return 'utf16le';\n            case 'latin1':\n            case 'binary':\n              return 'latin1';\n            case 'base64':\n            case 'ascii':\n            case 'hex':\n              return enc;\n            default:\n              if (retried) return; // undefined\n              enc = ('' + enc).toLowerCase();\n              retried = true;}\n\n        }\n      };\n\n      // Do not cache `Buffer.isEncoding` when checking encoding names as some\n      // modules monkey-patch it to support additional encodings\n      function normalizeEncoding(enc) {\n        var nenc = _normalizeEncoding(enc);\n        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n        return nenc || enc;\n      }\n\n      // StringDecoder provides an interface for efficiently splitting a series of\n      // buffers into a series of JS strings without breaking apart multi-byte\n      // characters.\n      exports.StringDecoder = StringDecoder;\n      function StringDecoder(encoding) {\n        this.encoding = normalizeEncoding(encoding);\n        var nb;\n        switch (this.encoding) {\n          case 'utf16le':\n            this.text = utf16Text;\n            this.end = utf16End;\n            nb = 4;\n            break;\n          case 'utf8':\n            this.fillLast = utf8FillLast;\n            nb = 4;\n            break;\n          case 'base64':\n            this.text = base64Text;\n            this.end = base64End;\n            nb = 3;\n            break;\n          default:\n            this.write = simpleWrite;\n            this.end = simpleEnd;\n            return;}\n\n        this.lastNeed = 0;\n        this.lastTotal = 0;\n        this.lastChar = Buffer.allocUnsafe(nb);\n      }\n\n      StringDecoder.prototype.write = function (buf) {\n        if (buf.length === 0) return '';\n        var r;\n        var i;\n        if (this.lastNeed) {\n          r = this.fillLast(buf);\n          if (r === undefined) return '';\n          i = this.lastNeed;\n          this.lastNeed = 0;\n        } else {\n          i = 0;\n        }\n        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n        return r || '';\n      };\n\n      StringDecoder.prototype.end = utf8End;\n\n      // Returns only complete characters in a Buffer\n      StringDecoder.prototype.text = utf8Text;\n\n      // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n      StringDecoder.prototype.fillLast = function (buf) {\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n        this.lastNeed -= buf.length;\n      };\n\n      // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n      // continuation byte. If an invalid byte is detected, -2 is returned.\n      function utf8CheckByte(_byte) {\n        if (_byte <= 0x7F) return 0;else if (_byte >> 5 === 0x06) return 2;else if (_byte >> 4 === 0x0E) return 3;else if (_byte >> 3 === 0x1E) return 4;\n        return _byte >> 6 === 0x02 ? -1 : -2;\n      }\n\n      // Checks at most 3 bytes at the end of a Buffer in order to detect an\n      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n      // needed to complete the UTF-8 character (if applicable) are returned.\n      function utf8CheckIncomplete(self, buf, i) {\n        var j = buf.length - 1;\n        if (j < i) return 0;\n        var nb = utf8CheckByte(buf[j]);\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 1;\n          return nb;\n        }\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 2;\n          return nb;\n        }\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n        if (nb >= 0) {\n          if (nb > 0) {\n            if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n          }\n          return nb;\n        }\n        return 0;\n      }\n\n      // Validates as many continuation bytes for a multi-byte UTF-8 character as\n      // needed or are available. If we see a non-continuation byte where we expect\n      // one, we \"replace\" the validated continuation bytes we've seen so far with\n      // a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n      // behavior. The continuation byte check is included three times in the case\n      // where all of the continuation bytes for a character exist in the same buffer.\n      // It is also done this way as a slight performance increase instead of using a\n      // loop.\n      function utf8CheckExtraBytes(self, buf, p) {\n        if ((buf[0] & 0xC0) !== 0x80) {\n          self.lastNeed = 0;\n          return \"\\uFFFD\";\n        }\n        if (self.lastNeed > 1 && buf.length > 1) {\n          if ((buf[1] & 0xC0) !== 0x80) {\n            self.lastNeed = 1;\n            return \"\\uFFFD\";\n          }\n          if (self.lastNeed > 2 && buf.length > 2) {\n            if ((buf[2] & 0xC0) !== 0x80) {\n              self.lastNeed = 2;\n              return \"\\uFFFD\";\n            }\n          }\n        }\n      }\n\n      // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n      function utf8FillLast(buf) {\n        var p = this.lastTotal - this.lastNeed;\n        var r = utf8CheckExtraBytes(this, buf, p);\n        if (r !== undefined) return r;\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, p, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n        buf.copy(this.lastChar, p, 0, buf.length);\n        this.lastNeed -= buf.length;\n      }\n\n      // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n      // partial character, the character's bytes are buffered until the required\n      // number of bytes are available.\n      function utf8Text(buf, i) {\n        var total = utf8CheckIncomplete(this, buf, i);\n        if (!this.lastNeed) return buf.toString('utf8', i);\n        this.lastTotal = total;\n        var end = buf.length - (total - this.lastNeed);\n        buf.copy(this.lastChar, 0, end);\n        return buf.toString('utf8', i, end);\n      }\n\n      // For UTF-8, a replacement character is added when ending on a partial\n      // character.\n      function utf8End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + \"\\uFFFD\";\n        return r;\n      }\n\n      // UTF-16LE typically needs two bytes per character, but even if we have an even\n      // number of bytes available, we need to check if we end on a leading/high\n      // surrogate. In that case, we need to wait for the next two bytes in order to\n      // decode the last character properly.\n      function utf16Text(buf, i) {\n        if ((buf.length - i) % 2 === 0) {\n          var r = buf.toString('utf16le', i);\n          if (r) {\n            var c = r.charCodeAt(r.length - 1);\n            if (c >= 0xD800 && c <= 0xDBFF) {\n              this.lastNeed = 2;\n              this.lastTotal = 4;\n              this.lastChar[0] = buf[buf.length - 2];\n              this.lastChar[1] = buf[buf.length - 1];\n              return r.slice(0, -1);\n            }\n          }\n          return r;\n        }\n        this.lastNeed = 1;\n        this.lastTotal = 2;\n        this.lastChar[0] = buf[buf.length - 1];\n        return buf.toString('utf16le', i, buf.length - 1);\n      }\n\n      // For UTF-16LE we do not explicitly append special replacement characters if we\n      // end on a partial character, we simply let v8 handle that.\n      function utf16End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) {\n          var end = this.lastTotal - this.lastNeed;\n          return r + this.lastChar.toString('utf16le', 0, end);\n        }\n        return r;\n      }\n\n      function base64Text(buf, i) {\n        var n = (buf.length - i) % 3;\n        if (n === 0) return buf.toString('base64', i);\n        this.lastNeed = 3 - n;\n        this.lastTotal = 3;\n        if (n === 1) {\n          this.lastChar[0] = buf[buf.length - 1];\n        } else {\n          this.lastChar[0] = buf[buf.length - 2];\n          this.lastChar[1] = buf[buf.length - 1];\n        }\n        return buf.toString('base64', i, buf.length - n);\n      }\n\n      function base64End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n        return r;\n      }\n\n      // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n      function simpleWrite(buf) {\n        return buf.toString(this.encoding);\n      }\n\n      function simpleEnd(buf) {\n        return buf && buf.length ? this.write(buf) : '';\n      }\n    }, { \"safe-buffer\": 110 }], 108: [function (require, module, exports) {\n      exports = module.exports = require('./lib/_stream_readable.js');\n      exports.Stream = exports;\n      exports.Readable = exports;\n      exports.Writable = require('./lib/_stream_writable.js');\n      exports.Duplex = require('./lib/_stream_duplex.js');\n      exports.Transform = require('./lib/_stream_transform.js');\n      exports.PassThrough = require('./lib/_stream_passthrough.js');\n\n    }, { \"./lib/_stream_duplex.js\": 98, \"./lib/_stream_passthrough.js\": 99, \"./lib/_stream_readable.js\": 100, \"./lib/_stream_transform.js\": 101, \"./lib/_stream_writable.js\": 102 }], 109: [function (require, module, exports) {\n      'use strict';\n\n      function ReInterval(callback, interval, args) {\n        var self = this;\n\n        this._callback = callback;\n        this._args = args;\n\n        this._interval = setInterval(callback, interval, this._args);\n\n        this.reschedule = function (interval) {\n          // if no interval entered, use the interval passed in on creation\n          if (!interval)\n          interval = self._interval;\n\n          if (self._interval)\n          clearInterval(self._interval);\n          self._interval = setInterval(self._callback, interval, self._args);\n        };\n\n        this.clear = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n            self._interval = undefined;\n          }\n        };\n\n        this.destroy = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n          }\n          self._callback = undefined;\n          self._interval = undefined;\n          self._args = undefined;\n        };\n      }\n\n      function reInterval() {\n        if (typeof arguments[0] !== 'function')\n        throw new Error('callback needed');\n        if (typeof arguments[1] !== 'number')\n        throw new Error('interval needed');\n\n        var args;\n\n        if (arguments.length > 0) {\n          args = new Array(arguments.length - 2);\n\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 2];\n          }\n        }\n\n        return new ReInterval(arguments[0], arguments[1], args);\n      }\n\n      module.exports = reInterval;\n\n    }, {}], 110: [function (require, module, exports) {\n      /* eslint-disable node/no-deprecated-api */\n      var buffer = require('buffer');\n      var Buffer = buffer.Buffer;\n\n      // alternative to using Object.keys for old browsers\n      function copyProps(src, dst) {\n        for (var key in src) {\n          dst[key] = src[key];\n        }\n      }\n      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n        module.exports = buffer;\n      } else {\n        // Copy properties from require('buffer')\n        copyProps(buffer, exports);\n        exports.Buffer = SafeBuffer;\n      }\n\n      function SafeBuffer(arg, encodingOrOffset, length) {\n        return Buffer(arg, encodingOrOffset, length);\n      }\n\n      // Copy static methods from Buffer\n      copyProps(Buffer, SafeBuffer);\n\n      SafeBuffer.from = function (arg, encodingOrOffset, length) {\n        if (typeof arg === 'number') {\n          throw new TypeError('Argument must not be a number');\n        }\n        return Buffer(arg, encodingOrOffset, length);\n      };\n\n      SafeBuffer.alloc = function (size, fill, encoding) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n        var buf = Buffer(size);\n        if (fill !== undefined) {\n          if (typeof encoding === 'string') {\n            buf.fill(fill, encoding);\n          } else {\n            buf.fill(fill);\n          }\n        } else {\n          buf.fill(0);\n        }\n        return buf;\n      };\n\n      SafeBuffer.allocUnsafe = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n        return Buffer(size);\n      };\n\n      SafeBuffer.allocUnsafeSlow = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n        return buffer.SlowBuffer(size);\n      };\n\n    }, { \"buffer\": 12 }], 111: [function (require, module, exports) {\n      module.exports = shift;\n\n      function shift(stream) {\n        var rs = stream._readableState;\n        if (!rs) return null;\n        return rs.objectMode ? stream.read() : stream.read(getStateLength(rs));\n      }\n\n      function getStateLength(state) {\n        if (state.buffer.length) {\n          // Since node 6.3.0 state.buffer is a BufferList not an array\n          if (state.buffer.head) {\n            return state.buffer.head.data.length;\n          }\n\n          return state.buffer[0].length;\n        }\n\n        return state.length;\n      }\n\n    }, {}], 112: [function (require, module, exports) {\n      (function (setImmediate, clearImmediate) {\n        var nextTick = require('process/browser.js').nextTick;\n        var apply = Function.prototype.apply;\n        var slice = Array.prototype.slice;\n        var immediateIds = {};\n        var nextImmediateId = 0;\n\n        // DOM APIs, for completeness\n\n        exports.setTimeout = function () {\n          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n        };\n        exports.setInterval = function () {\n          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n        };\n        exports.clearTimeout =\n        exports.clearInterval = function (timeout) {timeout.close();};\n\n        function Timeout(id, clearFn) {\n          this._id = id;\n          this._clearFn = clearFn;\n        }\n        Timeout.prototype.unref = Timeout.prototype.ref = function () {};\n        Timeout.prototype.close = function () {\n          this._clearFn.call(window, this._id);\n        };\n\n        // Does not start the time, just sets up the members needed.\n        exports.enroll = function (item, msecs) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = msecs;\n        };\n\n        exports.unenroll = function (item) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = -1;\n        };\n\n        exports._unrefActive = exports.active = function (item) {\n          clearTimeout(item._idleTimeoutId);\n\n          var msecs = item._idleTimeout;\n          if (msecs >= 0) {\n            item._idleTimeoutId = setTimeout(function onTimeout() {\n              if (item._onTimeout)\n              item._onTimeout();\n            }, msecs);\n          }\n        };\n\n        // That's not how node.js implements it but the exposed api is the same.\n        exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function (fn) {\n          var id = nextImmediateId++;\n          var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n          immediateIds[id] = true;\n\n          nextTick(function onNextTick() {\n            if (immediateIds[id]) {\n              // fn.call() is faster so we optimize for the common use-case\n              // @see http://jsperf.com/call-apply-segu\n              if (args) {\n                fn.apply(null, args);\n              } else {\n                fn.call(null);\n              }\n              // Prevent ids from leaking\n              exports.clearImmediate(id);\n            }\n          });\n\n          return id;\n        };\n\n        exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function (id) {\n          delete immediateIds[id];\n        };\n      }).call(this, require(\"timers\").setImmediate, require(\"timers\").clearImmediate);\n    }, { \"process/browser.js\": 92, \"timers\": 112 }], 113: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      var punycode = require('punycode');\n      var util = require('./util');\n\n      exports.parse = urlParse;\n      exports.resolve = urlResolve;\n      exports.resolveObject = urlResolveObject;\n      exports.format = urlFormat;\n\n      exports.Url = Url;\n\n      function Url() {\n        this.protocol = null;\n        this.slashes = null;\n        this.auth = null;\n        this.host = null;\n        this.port = null;\n        this.hostname = null;\n        this.hash = null;\n        this.search = null;\n        this.query = null;\n        this.pathname = null;\n        this.path = null;\n        this.href = null;\n      }\n\n      // Reference: RFC 3986, RFC 1808, RFC 2396\n\n      // define these here so at least they only have to be\n      // compiled once on the first module load.\n      var protocolPattern = /^([a-z0-9.+-]+:)/i,\n      portPattern = /:[0-9]*$/,\n\n      // Special case for a simple path URL\n      simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n      // RFC 2396: characters reserved for delimiting URLs.\n      // We actually just auto-escape these.\n      delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n      // RFC 2396: characters not allowed for various reasons.\n      unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n      autoEscape = ['\\''].concat(unwise),\n      // Characters that are never ever allowed in a hostname.\n      // Note that any invalid chars are also handled, but these\n      // are the ones that are *expected* to be seen, so we fast-path\n      // them.\n      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n      hostEndingChars = ['/', '?', '#'],\n      hostnameMaxLen = 255,\n      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n      // protocols that can allow \"unsafe\" and \"unwise\" chars.\n      unsafeProtocol = {\n        'javascript': true,\n        'javascript:': true },\n\n      // protocols that never have a hostname.\n      hostlessProtocol = {\n        'javascript': true,\n        'javascript:': true },\n\n      // protocols that always contain a // bit.\n      slashedProtocol = {\n        'http': true,\n        'https': true,\n        'ftp': true,\n        'gopher': true,\n        'file': true,\n        'http:': true,\n        'https:': true,\n        'ftp:': true,\n        'gopher:': true,\n        'file:': true },\n\n      querystring = require('querystring');\n\n      function urlParse(url, parseQueryString, slashesDenoteHost) {\n        if (url && util.isObject(url) && url instanceof Url) return url;\n\n        var u = new Url();\n        u.parse(url, parseQueryString, slashesDenoteHost);\n        return u;\n      }\n\n      Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n        if (!util.isString(url)) {\n          throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n        }\n\n        // Copy chrome, IE, opera backslash-handling behavior.\n        // Back slashes before the query string get converted to forward slashes\n        // See: https://code.google.com/p/chromium/issues/detail?id=25916\n        var queryIndex = url.indexOf('?'),\n        splitter =\n        queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n        uSplit = url.split(splitter),\n        slashRegex = /\\\\/g;\n        uSplit[0] = uSplit[0].replace(slashRegex, '/');\n        url = uSplit.join(splitter);\n\n        var rest = url;\n\n        // trim before proceeding.\n        // This is to support parse stuff like \"  http://foo.com  \\n\"\n        rest = rest.trim();\n\n        if (!slashesDenoteHost && url.split('#').length === 1) {\n          // Try fast path regexp\n          var simplePath = simplePathPattern.exec(rest);\n          if (simplePath) {\n            this.path = rest;\n            this.href = rest;\n            this.pathname = simplePath[1];\n            if (simplePath[2]) {\n              this.search = simplePath[2];\n              if (parseQueryString) {\n                this.query = querystring.parse(this.search.substr(1));\n              } else {\n                this.query = this.search.substr(1);\n              }\n            } else if (parseQueryString) {\n              this.search = '';\n              this.query = {};\n            }\n            return this;\n          }\n        }\n\n        var proto = protocolPattern.exec(rest);\n        if (proto) {\n          proto = proto[0];\n          var lowerProto = proto.toLowerCase();\n          this.protocol = lowerProto;\n          rest = rest.substr(proto.length);\n        }\n\n        // figure out if it's got a host\n        // user@server is *always* interpreted as a hostname, and url\n        // resolution will treat //foo/bar as host=foo,path=bar because that's\n        // how the browser resolves relative URLs.\n        if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n          var slashes = rest.substr(0, 2) === '//';\n          if (slashes && !(proto && hostlessProtocol[proto])) {\n            rest = rest.substr(2);\n            this.slashes = true;\n          }\n        }\n\n        if (!hostlessProtocol[proto] && (\n        slashes || proto && !slashedProtocol[proto])) {\n\n          // there's a hostname.\n          // the first instance of /, ?, ;, or # ends the host.\n          //\n          // If there is an @ in the hostname, then non-host chars *are* allowed\n          // to the left of the last @ sign, unless some host-ending character\n          // comes *before* the @-sign.\n          // URLs are obnoxious.\n          //\n          // ex:\n          // http://a@b@c/ => user:a@b host:c\n          // http://a@b?@c => user:a host:c path:/?@c\n\n          // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n          // Review our test case against browsers more comprehensively.\n\n          // find the first instance of any hostEndingChars\n          var hostEnd = -1;\n          for (var i = 0; i < hostEndingChars.length; i++) {\n            var hec = rest.indexOf(hostEndingChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n            hostEnd = hec;\n          }\n\n          // at this point, either we have an explicit point where the\n          // auth portion cannot go past, or the last @ char is the decider.\n          var auth, atSign;\n          if (hostEnd === -1) {\n            // atSign can be anywhere.\n            atSign = rest.lastIndexOf('@');\n          } else {\n            // atSign must be in auth portion.\n            // http://a@b/c@d => host:b auth:a path:/c@d\n            atSign = rest.lastIndexOf('@', hostEnd);\n          }\n\n          // Now we have a portion which is definitely the auth.\n          // Pull that off.\n          if (atSign !== -1) {\n            auth = rest.slice(0, atSign);\n            rest = rest.slice(atSign + 1);\n            this.auth = decodeURIComponent(auth);\n          }\n\n          // the host is the remaining to the left of the first non-host char\n          hostEnd = -1;\n          for (var i = 0; i < nonHostChars.length; i++) {\n            var hec = rest.indexOf(nonHostChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n            hostEnd = hec;\n          }\n          // if we still have not hit it, then the entire thing is a host.\n          if (hostEnd === -1)\n          hostEnd = rest.length;\n\n          this.host = rest.slice(0, hostEnd);\n          rest = rest.slice(hostEnd);\n\n          // pull out port.\n          this.parseHost();\n\n          // we've indicated that there is a hostname,\n          // so even if it's empty, it has to be present.\n          this.hostname = this.hostname || '';\n\n          // if hostname begins with [ and ends with ]\n          // assume that it's an IPv6 address.\n          var ipv6Hostname = this.hostname[0] === '[' &&\n          this.hostname[this.hostname.length - 1] === ']';\n\n          // validate a little.\n          if (!ipv6Hostname) {\n            var hostparts = this.hostname.split(/\\./);\n            for (var i = 0, l = hostparts.length; i < l; i++) {\n              var part = hostparts[i];\n              if (!part) continue;\n              if (!part.match(hostnamePartPattern)) {\n                var newpart = '';\n                for (var j = 0, k = part.length; j < k; j++) {\n                  if (part.charCodeAt(j) > 127) {\n                    // we replace non-ASCII char with a temporary placeholder\n                    // we need this to make sure size of hostname is not\n                    // broken by replacing non-ASCII by nothing\n                    newpart += 'x';\n                  } else {\n                    newpart += part[j];\n                  }\n                }\n                // we test again with ASCII char only\n                if (!newpart.match(hostnamePartPattern)) {\n                  var validParts = hostparts.slice(0, i);\n                  var notHost = hostparts.slice(i + 1);\n                  var bit = part.match(hostnamePartStart);\n                  if (bit) {\n                    validParts.push(bit[1]);\n                    notHost.unshift(bit[2]);\n                  }\n                  if (notHost.length) {\n                    rest = '/' + notHost.join('.') + rest;\n                  }\n                  this.hostname = validParts.join('.');\n                  break;\n                }\n              }\n            }\n          }\n\n          if (this.hostname.length > hostnameMaxLen) {\n            this.hostname = '';\n          } else {\n            // hostnames are always lower case.\n            this.hostname = this.hostname.toLowerCase();\n          }\n\n          if (!ipv6Hostname) {\n            // IDNA Support: Returns a punycoded representation of \"domain\".\n            // It only converts parts of the domain name that\n            // have non-ASCII characters, i.e. it doesn't matter if\n            // you call it with a domain that already is ASCII-only.\n            this.hostname = punycode.toASCII(this.hostname);\n          }\n\n          var p = this.port ? ':' + this.port : '';\n          var h = this.hostname || '';\n          this.host = h + p;\n          this.href += this.host;\n\n          // strip [ and ] from the hostname\n          // the host field still retains them, though\n          if (ipv6Hostname) {\n            this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n            if (rest[0] !== '/') {\n              rest = '/' + rest;\n            }\n          }\n        }\n\n        // now rest is set to the post-host stuff.\n        // chop off any delim chars.\n        if (!unsafeProtocol[lowerProto]) {\n\n          // First, make 100% sure that any \"autoEscape\" chars get\n          // escaped, even if encodeURIComponent doesn't think they\n          // need to be.\n          for (var i = 0, l = autoEscape.length; i < l; i++) {\n            var ae = autoEscape[i];\n            if (rest.indexOf(ae) === -1)\n            continue;\n            var esc = encodeURIComponent(ae);\n            if (esc === ae) {\n              esc = escape(ae);\n            }\n            rest = rest.split(ae).join(esc);\n          }\n        }\n\n\n        // chop off from the tail first.\n        var hash = rest.indexOf('#');\n        if (hash !== -1) {\n          // got a fragment string.\n          this.hash = rest.substr(hash);\n          rest = rest.slice(0, hash);\n        }\n        var qm = rest.indexOf('?');\n        if (qm !== -1) {\n          this.search = rest.substr(qm);\n          this.query = rest.substr(qm + 1);\n          if (parseQueryString) {\n            this.query = querystring.parse(this.query);\n          }\n          rest = rest.slice(0, qm);\n        } else if (parseQueryString) {\n          // no query string, but parseQueryString still requested\n          this.search = '';\n          this.query = {};\n        }\n        if (rest) this.pathname = rest;\n        if (slashedProtocol[lowerProto] &&\n        this.hostname && !this.pathname) {\n          this.pathname = '/';\n        }\n\n        //to support http.request\n        if (this.pathname || this.search) {\n          var p = this.pathname || '';\n          var s = this.search || '';\n          this.path = p + s;\n        }\n\n        // finally, reconstruct the href based on what has been validated.\n        this.href = this.format();\n        return this;\n      };\n\n      // format a parsed object into a url string\n      function urlFormat(obj) {\n        // ensure it's an object, and not a string url.\n        // If it's an obj, this is a no-op.\n        // this way, you can call url_format() on strings\n        // to clean up potentially wonky urls.\n        if (util.isString(obj)) obj = urlParse(obj);\n        if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n        return obj.format();\n      }\n\n      Url.prototype.format = function () {\n        var auth = this.auth || '';\n        if (auth) {\n          auth = encodeURIComponent(auth);\n          auth = auth.replace(/%3A/i, ':');\n          auth += '@';\n        }\n\n        var protocol = this.protocol || '',\n        pathname = this.pathname || '',\n        hash = this.hash || '',\n        host = false,\n        query = '';\n\n        if (this.host) {\n          host = auth + this.host;\n        } else if (this.hostname) {\n          host = auth + (this.hostname.indexOf(':') === -1 ?\n          this.hostname :\n          '[' + this.hostname + ']');\n          if (this.port) {\n            host += ':' + this.port;\n          }\n        }\n\n        if (this.query &&\n        util.isObject(this.query) &&\n        Object.keys(this.query).length) {\n          query = querystring.stringify(this.query);\n        }\n\n        var search = this.search || query && '?' + query || '';\n\n        if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n        // unless they had them to begin with.\n        if (this.slashes ||\n        (!protocol || slashedProtocol[protocol]) && host !== false) {\n          host = '//' + (host || '');\n          if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n        } else if (!host) {\n          host = '';\n        }\n\n        if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n        if (search && search.charAt(0) !== '?') search = '?' + search;\n\n        pathname = pathname.replace(/[?#]/g, function (match) {\n          return encodeURIComponent(match);\n        });\n        search = search.replace('#', '%23');\n\n        return protocol + host + pathname + search + hash;\n      };\n\n      function urlResolve(source, relative) {\n        return urlParse(source, false, true).resolve(relative);\n      }\n\n      Url.prototype.resolve = function (relative) {\n        return this.resolveObject(urlParse(relative, false, true)).format();\n      };\n\n      function urlResolveObject(source, relative) {\n        if (!source) return relative;\n        return urlParse(source, false, true).resolveObject(relative);\n      }\n\n      Url.prototype.resolveObject = function (relative) {\n        if (util.isString(relative)) {\n          var rel = new Url();\n          rel.parse(relative, false, true);\n          relative = rel;\n        }\n\n        var result = new Url();\n        var tkeys = Object.keys(this);\n        for (var tk = 0; tk < tkeys.length; tk++) {\n          var tkey = tkeys[tk];\n          result[tkey] = this[tkey];\n        }\n\n        // hash is always overridden, no matter what.\n        // even href=\"\" will remove it.\n        result.hash = relative.hash;\n\n        // if the relative url is empty, then there's nothing left to do here.\n        if (relative.href === '') {\n          result.href = result.format();\n          return result;\n        }\n\n        // hrefs like //foo/bar always cut to the protocol.\n        if (relative.slashes && !relative.protocol) {\n          // take everything except the protocol from relative\n          var rkeys = Object.keys(relative);\n          for (var rk = 0; rk < rkeys.length; rk++) {\n            var rkey = rkeys[rk];\n            if (rkey !== 'protocol')\n            result[rkey] = relative[rkey];\n          }\n\n          //urlParse appends trailing / to urls like http://www.example.com\n          if (slashedProtocol[result.protocol] &&\n          result.hostname && !result.pathname) {\n            result.path = result.pathname = '/';\n          }\n\n          result.href = result.format();\n          return result;\n        }\n\n        if (relative.protocol && relative.protocol !== result.protocol) {\n          // if it's a known url protocol, then changing\n          // the protocol does weird things\n          // first, if it's not file:, then we MUST have a host,\n          // and if there was a path\n          // to begin with, then we MUST have a path.\n          // if it is file:, then the host is dropped,\n          // because that's known to be hostless.\n          // anything else is assumed to be absolute.\n          if (!slashedProtocol[relative.protocol]) {\n            var keys = Object.keys(relative);\n            for (var v = 0; v < keys.length; v++) {\n              var k = keys[v];\n              result[k] = relative[k];\n            }\n            result.href = result.format();\n            return result;\n          }\n\n          result.protocol = relative.protocol;\n          if (!relative.host && !hostlessProtocol[relative.protocol]) {\n            var relPath = (relative.pathname || '').split('/');\n            while (relPath.length && !(relative.host = relPath.shift())) {;}\n            if (!relative.host) relative.host = '';\n            if (!relative.hostname) relative.hostname = '';\n            if (relPath[0] !== '') relPath.unshift('');\n            if (relPath.length < 2) relPath.unshift('');\n            result.pathname = relPath.join('/');\n          } else {\n            result.pathname = relative.pathname;\n          }\n          result.search = relative.search;\n          result.query = relative.query;\n          result.host = relative.host || '';\n          result.auth = relative.auth;\n          result.hostname = relative.hostname || relative.host;\n          result.port = relative.port;\n          // to support http.request\n          if (result.pathname || result.search) {\n            var p = result.pathname || '';\n            var s = result.search || '';\n            result.path = p + s;\n          }\n          result.slashes = result.slashes || relative.slashes;\n          result.href = result.format();\n          return result;\n        }\n\n        var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n        isRelAbs =\n        relative.host ||\n        relative.pathname && relative.pathname.charAt(0) === '/',\n\n        mustEndAbs = isRelAbs || isSourceAbs ||\n        result.host && relative.pathname,\n        removeAllDots = mustEndAbs,\n        srcPath = result.pathname && result.pathname.split('/') || [],\n        relPath = relative.pathname && relative.pathname.split('/') || [],\n        psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n        // if the url is a non-slashed url, then relative\n        // links like ../.. should be able\n        // to crawl up to the hostname, as well.  This is strange.\n        // result.protocol has already been set by now.\n        // Later on, put the first path part into the host field.\n        if (psychotic) {\n          result.hostname = '';\n          result.port = null;\n          if (result.host) {\n            if (srcPath[0] === '') srcPath[0] = result.host;else\n            srcPath.unshift(result.host);\n          }\n          result.host = '';\n          if (relative.protocol) {\n            relative.hostname = null;\n            relative.port = null;\n            if (relative.host) {\n              if (relPath[0] === '') relPath[0] = relative.host;else\n              relPath.unshift(relative.host);\n            }\n            relative.host = null;\n          }\n          mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n        }\n\n        if (isRelAbs) {\n          // it's absolute.\n          result.host = relative.host || relative.host === '' ?\n          relative.host : result.host;\n          result.hostname = relative.hostname || relative.hostname === '' ?\n          relative.hostname : result.hostname;\n          result.search = relative.search;\n          result.query = relative.query;\n          srcPath = relPath;\n          // fall through to the dot-handling below.\n        } else if (relPath.length) {\n          // it's relative\n          // throw away the existing file, and take the new path instead.\n          if (!srcPath) srcPath = [];\n          srcPath.pop();\n          srcPath = srcPath.concat(relPath);\n          result.search = relative.search;\n          result.query = relative.query;\n        } else if (!util.isNullOrUndefined(relative.search)) {\n          // just pull out the search.\n          // like href='?foo'.\n          // Put this after the other two cases because it simplifies the booleans\n          if (psychotic) {\n            result.hostname = result.host = srcPath.shift();\n            //occationaly the auth can get stuck only in host\n            //this especially happens in cases like\n            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n            var authInHost = result.host && result.host.indexOf('@') > 0 ?\n            result.host.split('@') : false;\n            if (authInHost) {\n              result.auth = authInHost.shift();\n              result.host = result.hostname = authInHost.shift();\n            }\n          }\n          result.search = relative.search;\n          result.query = relative.query;\n          //to support http.request\n          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n            result.path = (result.pathname ? result.pathname : '') + (\n            result.search ? result.search : '');\n          }\n          result.href = result.format();\n          return result;\n        }\n\n        if (!srcPath.length) {\n          // no path at all.  easy.\n          // we've already handled the other stuff above.\n          result.pathname = null;\n          //to support http.request\n          if (result.search) {\n            result.path = '/' + result.search;\n          } else {\n            result.path = null;\n          }\n          result.href = result.format();\n          return result;\n        }\n\n        // if a url ENDs in . or .., then it must get a trailing slash.\n        // however, if it ends in anything else non-slashy,\n        // then it must NOT get a trailing slash.\n        var last = srcPath.slice(-1)[0];\n        var hasTrailingSlash =\n        (result.host || relative.host || srcPath.length > 1) && (\n        last === '.' || last === '..') || last === '';\n\n        // strip single dots, resolve double dots to parent dir\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = srcPath.length; i >= 0; i--) {\n          last = srcPath[i];\n          if (last === '.') {\n            srcPath.splice(i, 1);\n          } else if (last === '..') {\n            srcPath.splice(i, 1);\n            up++;\n          } else if (up) {\n            srcPath.splice(i, 1);\n            up--;\n          }\n        }\n\n        // if the path is allowed to go above the root, restore leading ..s\n        if (!mustEndAbs && !removeAllDots) {\n          for (; up--; up) {\n            srcPath.unshift('..');\n          }\n        }\n\n        if (mustEndAbs && srcPath[0] !== '' && (\n        !srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n          srcPath.unshift('');\n        }\n\n        if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n          srcPath.push('');\n        }\n\n        var isAbsolute = srcPath[0] === '' ||\n        srcPath[0] && srcPath[0].charAt(0) === '/';\n\n        // put the host back\n        if (psychotic) {\n          result.hostname = result.host = isAbsolute ? '' :\n          srcPath.length ? srcPath.shift() : '';\n          //occationaly the auth can get stuck only in host\n          //this especially happens in cases like\n          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n          var authInHost = result.host && result.host.indexOf('@') > 0 ?\n          result.host.split('@') : false;\n          if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n          }\n        }\n\n        mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n        if (mustEndAbs && !isAbsolute) {\n          srcPath.unshift('');\n        }\n\n        if (!srcPath.length) {\n          result.pathname = null;\n          result.path = null;\n        } else {\n          result.pathname = srcPath.join('/');\n        }\n\n        //to support request.http\n        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n          result.path = (result.pathname ? result.pathname : '') + (\n          result.search ? result.search : '');\n        }\n        result.auth = relative.auth || result.auth;\n        result.slashes = result.slashes || relative.slashes;\n        result.href = result.format();\n        return result;\n      };\n\n      Url.prototype.parseHost = function () {\n        var host = this.host;\n        var port = portPattern.exec(host);\n        if (port) {\n          port = port[0];\n          if (port !== ':') {\n            this.port = port.substr(1);\n          }\n          host = host.substr(0, host.length - port.length);\n        }\n        if (host) this.hostname = host;\n      };\n\n    }, { \"./util\": 114, \"punycode\": 93, \"querystring\": 96 }], 114: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = {\n        isString: function isString(arg) {\n          return typeof arg === 'string';\n        },\n        isObject: function isObject(arg) {\n          return typeof arg === 'object' && arg !== null;\n        },\n        isNull: function isNull(arg) {\n          return arg === null;\n        },\n        isNullOrUndefined: function isNullOrUndefined(arg) {\n          return arg == null;\n        } };\n\n\n    }, {}], 115: [function (require, module, exports) {\n      (function (global) {\n\n        /**\n                           * Module exports.\n                           */\n\n        module.exports = deprecate;\n\n        /**\n                                     * Mark that a method should not be used.\n                                     * Returns a modified function which warns once by default.\n                                     *\n                                     * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n                                     *\n                                     * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n                                     * will throw an Error when invoked.\n                                     *\n                                     * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n                                     * will invoke `console.trace()` instead of `console.error()`.\n                                     *\n                                     * @param {Function} fn - the function to deprecate\n                                     * @param {String} msg - the string to print to the console when `fn` is invoked\n                                     * @returns {Function} a new \"deprecated\" version of `fn`\n                                     * @api public\n                                     */\n\n        function deprecate(fn, msg) {\n          if (config('noDeprecation')) {\n            return fn;\n          }\n\n          var warned = false;\n          function deprecated() {\n            if (!warned) {\n              if (config('throwDeprecation')) {\n                throw new Error(msg);\n              } else if (config('traceDeprecation')) {\n                console.trace(msg);\n              } else {\n                __f__(\"warn\", msg, \" at utils/mqttjs3/mqtt.js:13761\");\n              }\n              warned = true;\n            }\n            return fn.apply(this, arguments);\n          }\n\n          return deprecated;\n        }\n\n        /**\n           * Checks `localStorage` for boolean values for the given `name`.\n           *\n           * @param {String} name\n           * @returns {Boolean}\n           * @api private\n           */\n\n        function config(name) {\n          // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n          try {\n            if (!global.localStorage) return false;\n          } catch (_) {\n            return false;\n          }\n          var val = global.localStorage[name];\n          if (null == val) return false;\n          return String(val).toLowerCase() === 'true';\n        }\n\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}], 116: [function (require, module, exports) {\n      module.exports = function isBuffer(arg) {\n        return arg && typeof arg === 'object' &&\n        typeof arg.copy === 'function' &&\n        typeof arg.fill === 'function' &&\n        typeof arg.readUInt8 === 'function';\n      };\n    }, {}], 117: [function (require, module, exports) {\n      (function (process, global) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        var formatRegExp = /%[sdj%]/g;\n        exports.format = function (f) {\n          if (!isString(f)) {\n            var objects = [];\n            for (var i = 0; i < arguments.length; i++) {\n              objects.push(inspect(arguments[i]));\n            }\n            return objects.join(' ');\n          }\n\n          var i = 1;\n          var args = arguments;\n          var len = args.length;\n          var str = String(f).replace(formatRegExp, function (x) {\n            if (x === '%%') return '%';\n            if (i >= len) return x;\n            switch (x) {\n              case '%s':return String(args[i++]);\n              case '%d':return Number(args[i++]);\n              case '%j':\n                try {\n                  return JSON.stringify(args[i++]);\n                } catch (_) {\n                  return '[Circular]';\n                }\n              default:\n                return x;}\n\n          });\n          for (var x = args[i]; i < len; x = args[++i]) {\n            if (isNull(x) || !isObject(x)) {\n              str += ' ' + x;\n            } else {\n              str += ' ' + inspect(x);\n            }\n          }\n          return str;\n        };\n\n\n        // Mark that a method should not be used.\n        // Returns a modified function which warns once by default.\n        // If --no-deprecation is set, then it is a no-op.\n        exports.deprecate = function (fn, msg) {\n          // Allow for deprecating things in the process of starting up.\n          if (isUndefined(global.process)) {\n            return function () {\n              return exports.deprecate(fn, msg).apply(this, arguments);\n            };\n          }\n\n          if (process.noDeprecation === true) {\n            return fn;\n          }\n\n          var warned = false;\n          function deprecated() {\n            if (!warned) {\n              if (process.throwDeprecation) {\n                throw new Error(msg);\n              } else if (process.traceDeprecation) {\n                console.trace(msg);\n              } else {\n                __f__(\"error\", msg, \" at utils/mqttjs3/mqtt.js:13885\");\n              }\n              warned = true;\n            }\n            return fn.apply(this, arguments);\n          }\n\n          return deprecated;\n        };\n\n\n        var debugs = {};\n        var debugEnviron;\n        exports.debuglog = function (set) {\n          if (isUndefined(debugEnviron))\n          debugEnviron = process.env.NODE_DEBUG || '';\n          set = set.toUpperCase();\n          if (!debugs[set]) {\n            if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n              var pid = process.pid;\n              debugs[set] = function () {\n                var msg = exports.format.apply(exports, arguments);\n                __f__(\"error\", '%s %d: %s', set, pid, msg, \" at utils/mqttjs3/mqtt.js:13907\");\n              };\n            } else {\n              debugs[set] = function () {};\n            }\n          }\n          return debugs[set];\n        };\n\n\n        /**\n            * Echos the value of a value. Trys to print the value out\n            * in the best way possible given the different types.\n            *\n            * @param {Object} obj The object to print out.\n            * @param {Object} opts Optional options object that alters the output.\n            */\n        /* legacy: obj, showHidden, depth, colors*/\n        function inspect(obj, opts) {\n          // default options\n          var ctx = {\n            seen: [],\n            stylize: stylizeNoColor };\n\n          // legacy...\n          if (arguments.length >= 3) ctx.depth = arguments[2];\n          if (arguments.length >= 4) ctx.colors = arguments[3];\n          if (isBoolean(opts)) {\n            // legacy...\n            ctx.showHidden = opts;\n          } else if (opts) {\n            // got an \"options\" object\n            exports._extend(ctx, opts);\n          }\n          // set default options\n          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n          if (isUndefined(ctx.depth)) ctx.depth = 2;\n          if (isUndefined(ctx.colors)) ctx.colors = false;\n          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n          if (ctx.colors) ctx.stylize = stylizeWithColor;\n          return formatValue(ctx, obj, ctx.depth);\n        }\n        exports.inspect = inspect;\n\n\n        // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n        inspect.colors = {\n          'bold': [1, 22],\n          'italic': [3, 23],\n          'underline': [4, 24],\n          'inverse': [7, 27],\n          'white': [37, 39],\n          'grey': [90, 39],\n          'black': [30, 39],\n          'blue': [34, 39],\n          'cyan': [36, 39],\n          'green': [32, 39],\n          'magenta': [35, 39],\n          'red': [31, 39],\n          'yellow': [33, 39] };\n\n\n        // Don't use 'blue' not visible on cmd.exe\n        inspect.styles = {\n          'special': 'cyan',\n          'number': 'yellow',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' };\n\n\n\n        function stylizeWithColor(str, styleType) {\n          var style = inspect.styles[styleType];\n\n          if (style) {\n            return \"\\x1B[\" + inspect.colors[style][0] + 'm' + str +\n            \"\\x1B[\" + inspect.colors[style][1] + 'm';\n          } else {\n            return str;\n          }\n        }\n\n\n        function stylizeNoColor(str, styleType) {\n          return str;\n        }\n\n\n        function arrayToHash(array) {\n          var hash = {};\n\n          array.forEach(function (val, idx) {\n            hash[val] = true;\n          });\n\n          return hash;\n        }\n\n\n        function formatValue(ctx, value, recurseTimes) {\n          // Provide a hook for user-specified inspect functions.\n          // Check that value is an object with an inspect function on it\n          if (ctx.customInspect &&\n          value &&\n          isFunction(value.inspect) &&\n          // Filter out the util module, it's inspect function is special\n          value.inspect !== exports.inspect &&\n          // Also filter out any prototype objects using the circular check.\n          !(value.constructor && value.constructor.prototype === value)) {\n            var ret = value.inspect(recurseTimes, ctx);\n            if (!isString(ret)) {\n              ret = formatValue(ctx, ret, recurseTimes);\n            }\n            return ret;\n          }\n\n          // Primitive types cannot have properties\n          var primitive = formatPrimitive(ctx, value);\n          if (primitive) {\n            return primitive;\n          }\n\n          // Look up the keys of the object.\n          var keys = Object.keys(value);\n          var visibleKeys = arrayToHash(keys);\n\n          if (ctx.showHidden) {\n            keys = Object.getOwnPropertyNames(value);\n          }\n\n          // IE doesn't make error fields non-enumerable\n          // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n          if (isError(value) && (\n          keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n            return formatError(value);\n          }\n\n          // Some type of object without properties can be shortcutted.\n          if (keys.length === 0) {\n            if (isFunction(value)) {\n              var name = value.name ? ': ' + value.name : '';\n              return ctx.stylize('[Function' + name + ']', 'special');\n            }\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            }\n            if (isDate(value)) {\n              return ctx.stylize(Date.prototype.toString.call(value), 'date');\n            }\n            if (isError(value)) {\n              return formatError(value);\n            }\n          }\n\n          var base = '',array = false,braces = ['{', '}'];\n\n          // Make Array say that they are Array\n          if (isArray(value)) {\n            array = true;\n            braces = ['[', ']'];\n          }\n\n          // Make functions say that they are functions\n          if (isFunction(value)) {\n            var n = value.name ? ': ' + value.name : '';\n            base = ' [Function' + n + ']';\n          }\n\n          // Make RegExps say that they are RegExps\n          if (isRegExp(value)) {\n            base = ' ' + RegExp.prototype.toString.call(value);\n          }\n\n          // Make dates with properties first say the date\n          if (isDate(value)) {\n            base = ' ' + Date.prototype.toUTCString.call(value);\n          }\n\n          // Make error with message first say the error\n          if (isError(value)) {\n            base = ' ' + formatError(value);\n          }\n\n          if (keys.length === 0 && (!array || value.length == 0)) {\n            return braces[0] + base + braces[1];\n          }\n\n          if (recurseTimes < 0) {\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            } else {\n              return ctx.stylize('[Object]', 'special');\n            }\n          }\n\n          ctx.seen.push(value);\n\n          var output;\n          if (array) {\n            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n          } else {\n            output = keys.map(function (key) {\n              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n            });\n          }\n\n          ctx.seen.pop();\n\n          return reduceToSingleString(output, base, braces);\n        }\n\n\n        function formatPrimitive(ctx, value) {\n          if (isUndefined(value))\n          return ctx.stylize('undefined', 'undefined');\n          if (isString(value)) {\n            var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').\n            replace(/'/g, \"\\\\'\").\n            replace(/\\\\\"/g, '\"') + '\\'';\n            return ctx.stylize(simple, 'string');\n          }\n          if (isNumber(value))\n          return ctx.stylize('' + value, 'number');\n          if (isBoolean(value))\n          return ctx.stylize('' + value, 'boolean');\n          // For some reason typeof null is \"object\", so special case here.\n          if (isNull(value))\n          return ctx.stylize('null', 'null');\n        }\n\n\n        function formatError(value) {\n          return '[' + Error.prototype.toString.call(value) + ']';\n        }\n\n\n        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n          var output = [];\n          for (var i = 0, l = value.length; i < l; ++i) {\n            if (hasOwnProperty(value, String(i))) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n              String(i), true));\n            } else {\n              output.push('');\n            }\n          }\n          keys.forEach(function (key) {\n            if (!key.match(/^\\d+$/)) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n              key, true));\n            }\n          });\n          return output;\n        }\n\n\n        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n          var name, str, desc;\n          desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n          if (desc.get) {\n            if (desc.set) {\n              str = ctx.stylize('[Getter/Setter]', 'special');\n            } else {\n              str = ctx.stylize('[Getter]', 'special');\n            }\n          } else {\n            if (desc.set) {\n              str = ctx.stylize('[Setter]', 'special');\n            }\n          }\n          if (!hasOwnProperty(visibleKeys, key)) {\n            name = '[' + key + ']';\n          }\n          if (!str) {\n            if (ctx.seen.indexOf(desc.value) < 0) {\n              if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n              } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n              }\n              if (str.indexOf('\\n') > -1) {\n                if (array) {\n                  str = str.split('\\n').map(function (line) {\n                    return '  ' + line;\n                  }).join('\\n').substr(2);\n                } else {\n                  str = '\\n' + str.split('\\n').map(function (line) {\n                    return '   ' + line;\n                  }).join('\\n');\n                }\n              }\n            } else {\n              str = ctx.stylize('[Circular]', 'special');\n            }\n          }\n          if (isUndefined(name)) {\n            if (array && key.match(/^\\d+$/)) {\n              return str;\n            }\n            name = JSON.stringify('' + key);\n            if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n              name = name.substr(1, name.length - 2);\n              name = ctx.stylize(name, 'name');\n            } else {\n              name = name.replace(/'/g, \"\\\\'\").\n              replace(/\\\\\"/g, '\"').\n              replace(/(^\"|\"$)/g, \"'\");\n              name = ctx.stylize(name, 'string');\n            }\n          }\n\n          return name + ': ' + str;\n        }\n\n\n        function reduceToSingleString(output, base, braces) {\n          var numLinesEst = 0;\n          var length = output.reduce(function (prev, cur) {\n            numLinesEst++;\n            if (cur.indexOf('\\n') >= 0) numLinesEst++;\n            return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n          }, 0);\n\n          if (length > 60) {\n            return braces[0] + (\n            base === '' ? '' : base + '\\n ') +\n            ' ' +\n            output.join(',\\n  ') +\n            ' ' +\n            braces[1];\n          }\n\n          return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n        }\n\n\n        // NOTE: These type checking functions intentionally don't use `instanceof`\n        // because it is fragile and can be easily faked with `Object.create()`.\n        function isArray(ar) {\n          return Array.isArray(ar);\n        }\n        exports.isArray = isArray;\n\n        function isBoolean(arg) {\n          return typeof arg === 'boolean';\n        }\n        exports.isBoolean = isBoolean;\n\n        function isNull(arg) {\n          return arg === null;\n        }\n        exports.isNull = isNull;\n\n        function isNullOrUndefined(arg) {\n          return arg == null;\n        }\n        exports.isNullOrUndefined = isNullOrUndefined;\n\n        function isNumber(arg) {\n          return typeof arg === 'number';\n        }\n        exports.isNumber = isNumber;\n\n        function isString(arg) {\n          return typeof arg === 'string';\n        }\n        exports.isString = isString;\n\n        function isSymbol(arg) {\n          return typeof arg === 'symbol';\n        }\n        exports.isSymbol = isSymbol;\n\n        function isUndefined(arg) {\n          return arg === void 0;\n        }\n        exports.isUndefined = isUndefined;\n\n        function isRegExp(re) {\n          return isObject(re) && objectToString(re) === '[object RegExp]';\n        }\n        exports.isRegExp = isRegExp;\n\n        function isObject(arg) {\n          return typeof arg === 'object' && arg !== null;\n        }\n        exports.isObject = isObject;\n\n        function isDate(d) {\n          return isObject(d) && objectToString(d) === '[object Date]';\n        }\n        exports.isDate = isDate;\n\n        function isError(e) {\n          return isObject(e) && (\n          objectToString(e) === '[object Error]' || e instanceof Error);\n        }\n        exports.isError = isError;\n\n        function isFunction(arg) {\n          return typeof arg === 'function';\n        }\n        exports.isFunction = isFunction;\n\n        function isPrimitive(arg) {\n          return arg === null ||\n          typeof arg === 'boolean' ||\n          typeof arg === 'number' ||\n          typeof arg === 'string' ||\n          typeof arg === 'symbol' || // ES6 symbol\n          typeof arg === 'undefined';\n        }\n        exports.isPrimitive = isPrimitive;\n\n        exports.isBuffer = require('./support/isBuffer');\n\n        function objectToString(o) {\n          return Object.prototype.toString.call(o);\n        }\n\n\n        function pad(n) {\n          return n < 10 ? '0' + n.toString(10) : n.toString(10);\n        }\n\n\n        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n        'Oct', 'Nov', 'Dec'];\n\n        // 26 Feb 16:19:34\n        function timestamp() {\n          var d = new Date();\n          var time = [pad(d.getHours()),\n          pad(d.getMinutes()),\n          pad(d.getSeconds())].join(':');\n          return [d.getDate(), months[d.getMonth()], time].join(' ');\n        }\n\n\n        // log is just a thin wrapper to console.log that prepends a timestamp\n        exports.log = function () {\n          __f__(\"log\", '%s - %s', timestamp(), exports.format.apply(exports, arguments), \" at utils/mqttjs3/mqtt.js:14353\");\n        };\n\n\n        /**\n            * Inherit the prototype methods from one constructor into another.\n            *\n            * The Function.prototype.inherits from lang.js rewritten as a standalone\n            * function (not on Function.prototype). NOTE: If this file is to be loaded\n            * during bootstrapping this function needs to be rewritten using some native\n            * functions as prototype setup using normal JavaScript does not work as\n            * expected during bootstrapping (see mirror.js in r114903).\n            *\n            * @param {function} ctor Constructor function which needs to inherit the\n            *     prototype.\n            * @param {function} superCtor Constructor function to inherit prototype from.\n            */\n        exports.inherits = require('inherits');\n\n        exports._extend = function (origin, add) {\n          // Don't do anything if add isn't an object\n          if (!add || !isObject(add)) return origin;\n\n          var keys = Object.keys(add);\n          var i = keys.length;\n          while (i--) {\n            origin[keys[i]] = add[keys[i]];\n          }\n          return origin;\n        };\n\n        function hasOwnProperty(obj, prop) {\n          return Object.prototype.hasOwnProperty.call(obj, prop);\n        }\n\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, { \"./support/isBuffer\": 116, \"_process\": 92, \"inherits\": 80 }], 118: [function (require, module, exports) {\n      (function (process, global) {\n        'use strict';\n\n        var Transform = require('readable-stream').Transform;\n        var duplexify = require('duplexify');\n        var WS = require('ws');\n        var Buffer = require('safe-buffer').Buffer;\n\n        module.exports = WebSocketStream;\n\n        function buildProxy(options, socketWrite, socketEnd) {\n          var proxy = new Transform({\n            objectMode: options.objectMode });\n\n\n          proxy._write = socketWrite;\n          proxy._flush = socketEnd;\n\n          return proxy;\n        }\n\n        function WebSocketStream(target, protocols, options) {\n          var stream, socket;\n\n          var isBrowser = process.title === 'browser';\n          var isNative = !!global.WebSocket;\n          var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode;\n\n          if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n            // accept the \"options\" Object as the 2nd argument\n            options = protocols;\n            protocols = null;\n\n            if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n              protocols = options.protocol;\n            }\n          }\n\n          if (!options) options = {};\n\n          if (options.objectMode === undefined) {\n            options.objectMode = !(options.binary === true || options.binary === undefined);\n          }\n\n          var proxy = buildProxy(options, socketWrite, socketEnd);\n\n          if (!options.objectMode) {\n            proxy._writev = writev;\n          }\n\n          // browser only: sets the maximum socket buffer size before throttling\n          var bufferSize = options.browserBufferSize || 1024 * 512;\n\n          // browser only: how long to wait when throttling\n          var bufferTimeout = options.browserBufferTimeout || 1000;\n\n          // use existing WebSocket object that was passed in\n          if (typeof target === 'object') {\n            socket = target;\n            // otherwise make a new one\n          } else {\n            // special constructor treatment for native websockets in browsers, see\n            // https://github.com/maxogden/websocket-stream/issues/82\n            if (isNative && isBrowser) {\n              socket = new WS(target, protocols);\n            } else {\n              socket = new WS(target, protocols, options);\n            }\n\n            socket.binaryType = 'arraybuffer';\n          }\n\n          // was already open when passed in\n          if (socket.readyState === socket.OPEN) {\n            stream = proxy;\n          } else {\n            stream = duplexify.obj();\n            socket.onopen = onopen;\n          }\n\n          stream.socket = socket;\n\n          socket.onclose = onclose;\n          socket.onerror = onerror;\n          socket.onmessage = onmessage;\n\n          proxy.on('close', destroy);\n\n          var coerceToBuffer = !options.objectMode;\n\n          function socketWriteNode(chunk, enc, next) {\n            // avoid errors, this never happens unless\n            // destroy() is called\n            if (socket.readyState !== socket.OPEN) {\n              next();\n              return;\n            }\n\n            if (coerceToBuffer && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, 'utf8');\n            }\n            socket.send(chunk, next);\n          }\n\n          function socketWriteBrowser(chunk, enc, next) {\n            if (socket.bufferedAmount > bufferSize) {\n              setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);\n              return;\n            }\n\n            if (coerceToBuffer && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, 'utf8');\n            }\n\n            try {\n              socket.send(chunk);\n            } catch (err) {\n              return next(err);\n            }\n\n            next();\n          }\n\n          function socketEnd(done) {\n            socket.close();\n            done();\n          }\n\n          function onopen() {\n            stream.setReadable(proxy);\n            stream.setWritable(proxy);\n            stream.emit('connect');\n          }\n\n          function onclose() {\n            stream.end();\n            stream.destroy();\n          }\n\n          function onerror(err) {\n            stream.destroy(err);\n          }\n\n          function onmessage(event) {\n            var data = event.data;\n            if (data instanceof ArrayBuffer) data = Buffer.from(data);else\n            data = Buffer.from(data, 'utf8');\n            proxy.push(data);\n          }\n\n          function destroy() {\n            socket.close();\n          }\n\n          // this is to be enabled only if objectMode is false\n          function writev(chunks, cb) {\n            var buffers = new Array(chunks.length);\n            for (var i = 0; i < chunks.length; i++) {\n              if (typeof chunks[i].chunk === 'string') {\n                buffers[i] = Buffer.from(chunks[i], 'utf8');\n              } else {\n                buffers[i] = chunks[i].chunk;\n              }\n            }\n\n            this._write(Buffer.concat(buffers), 'binary', cb);\n          }\n\n          return stream;\n        }\n\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, { \"_process\": 92, \"duplexify\": 17, \"readable-stream\": 108, \"safe-buffer\": 110, \"ws\": 119 }], 119: [function (require, module, exports) {\n\n      var ws = null;\n\n      if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n      } else if (typeof MozWebSocket !== 'undefined') {\n        ws = MozWebSocket;\n      } else if (typeof window !== 'undefined') {\n        ws = window.WebSocket || window.MozWebSocket;\n      }\n\n      module.exports = ws;\n\n    }, {}], 120: [function (require, module, exports) {\n      // Returns a wrapper function that returns a wrapped callback\n      // The wrapper function should do some stuff, and return a\n      // presumably different callback function.\n      // This makes sure that own properties are retained, so that\n      // decorations and such are not lost along the way.\n      module.exports = wrappy;\n      function wrappy(fn, cb) {\n        if (fn && cb) return wrappy(fn)(cb);\n\n        if (typeof fn !== 'function')\n        throw new TypeError('need wrapper function');\n\n        Object.keys(fn).forEach(function (k) {\n          wrapper[k] = fn[k];\n        });\n\n        return wrapper;\n\n        function wrapper() {\n          var args = new Array(arguments.length);\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i];\n          }\n          var ret = fn.apply(this, args);\n          var cb = args[args.length - 1];\n          if (typeof ret === 'function' && ret !== cb) {\n            Object.keys(cb).forEach(function (k) {\n              ret[k] = cb[k];\n            });\n          }\n          return ret;\n        }\n      }\n\n    }, {}], 121: [function (require, module, exports) {\n      module.exports = extend;\n\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      function extend() {\n        var target = {};\n\n        for (var i = 0; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      }\n\n    }, {}] }, {}, [9])(9);\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/webpack/buildin/global.js */ 9), __webpack_require__(/*! @dcloudio/uni-mp-weixin/dist/mp.js */ 10)[\"default\"], __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js */ 7)[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vdXRpbHMvbXF0dGpzMy9tcXR0LmpzIl0sIm5hbWVzIjpbImYiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwiciIsImUiLCJuIiwidCIsIm8iLCJpIiwiYyIsInJlcXVpcmUiLCJ1IiwiYSIsIkVycm9yIiwiY29kZSIsInAiLCJjYWxsIiwibGVuZ3RoIiwicHJvY2VzcyIsImdsb2JhbCIsImV2ZW50cyIsIlN0b3JlIiwibXF0dFBhY2tldCIsIldyaXRhYmxlIiwiaW5oZXJpdHMiLCJyZUludGVydmFsIiwidmFsaWRhdGlvbnMiLCJ4dGVuZCIsInNldEltbWVkaWF0ZSIsImNhbGxiYWNrIiwibmV4dFRpY2siLCJkZWZhdWx0Q29ubmVjdE9wdGlvbnMiLCJrZWVwYWxpdmUiLCJyZXNjaGVkdWxlUGluZ3MiLCJwcm90b2NvbElkIiwicHJvdG9jb2xWZXJzaW9uIiwicmVjb25uZWN0UGVyaW9kIiwiY29ubmVjdFRpbWVvdXQiLCJjbGVhbiIsInJlc3Vic2NyaWJlIiwiZXJyb3JzIiwiZGVmYXVsdElkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwic2VuZFBhY2tldCIsImNsaWVudCIsInBhY2tldCIsImNiIiwiZW1pdCIsInJlc3VsdCIsIndyaXRlVG9TdHJlYW0iLCJzdHJlYW0iLCJvcHRpb25zIiwib25jZSIsImZsdXNoIiwicXVldWUiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsIm1lc3NhZ2VJZCIsImZsdXNoVm9sYXRpbGUiLCJ2b2xhdGlsZSIsInN0b3JlQW5kU2VuZCIsImNiU3RvcmVQdXQiLCJvdXRnb2luZ1N0b3JlIiwicHV0Iiwic3RvcmVkUGFja2V0IiwiZXJyIiwibm9wIiwiTXF0dENsaWVudCIsInN0cmVhbUJ1aWxkZXIiLCJrIiwidGhhdCIsImNsaWVudElkIiwiY3VzdG9tSGFuZGxlQWNrcyIsImFyZ3VtZW50cyIsImluY29taW5nU3RvcmUiLCJxdWV1ZVFvU1plcm8iLCJ1bmRlZmluZWQiLCJfcmVzdWJzY3JpYmVUb3BpY3MiLCJtZXNzYWdlSWRUb1RvcGljIiwicGluZ1RpbWVyIiwiY29ubmVjdGVkIiwiZGlzY29ubmVjdGluZyIsImNvbm5hY2tUaW1lciIsInJlY29ubmVjdFRpbWVyIiwiX3N0b3JlUHJvY2Vzc2luZyIsIl9wYWNrZXRJZHNEdXJpbmdTdG9yZVByb2Nlc3NpbmciLCJuZXh0SWQiLCJtYXgiLCJmbG9vciIsIm91dGdvaW5nIiwiX2ZpcnN0Q29ubmVjdGlvbiIsIm9uIiwiY2xlYXJUaW1lb3V0IiwiZGVsaXZlciIsImVudHJ5Iiwic2hpZnQiLCJfc2VuZFBhY2tldCIsImNsZWFyIiwiX3NldHVwUmVjb25uZWN0IiwiRXZlbnRFbWl0dGVyIiwiX3NldHVwU3RyZWFtIiwicHJvdG90eXBlIiwiY29ubmVjdFBhY2tldCIsIndyaXRhYmxlIiwicGFyc2VyIiwiY29tcGxldGVQYXJzZSIsInBhY2tldHMiLCJfY2xlYXJSZWNvbm5lY3QiLCJwdXNoIiwibmV4dFRpY2tXb3JrIiwid29yayIsImRvbmUiLCJfaGFuZGxlUGFja2V0IiwiX3dyaXRlIiwiYnVmIiwiZW5jIiwicGFyc2UiLCJwaXBlIiwiY3JlYXRlIiwiY21kIiwiYmluZCIsInByb3BlcnRpZXMiLCJhdXRoZW50aWNhdGlvbk1ldGhvZCIsImF1dGhlbnRpY2F0aW9uRGF0YSIsImF1dGhQYWNrZXQiLCJyZWFzb25Db2RlIiwic2V0TWF4TGlzdGVuZXJzIiwic2V0VGltZW91dCIsIl9jbGVhblVwIiwibWF4aW11bVBhY2tldFNpemUiLCJlbmQiLCJyZWFzb25TdHJpbmciLCJfaGFuZGxlUHVibGlzaCIsIl9oYW5kbGVBY2siLCJfaGFuZGxlUHVicmVsIiwiX2hhbmRsZUNvbm5hY2siLCJfaGFuZGxlUGluZ3Jlc3AiLCJfaGFuZGxlRGlzY29ubmVjdCIsIl9jaGVja0Rpc2Nvbm5lY3RpbmciLCJwdWJsaXNoIiwidG9waWMiLCJtZXNzYWdlIiwib3B0cyIsImRlZmF1bHRPcHRzIiwicW9zIiwicmV0YWluIiwiZHVwIiwicGF5bG9hZCIsIl9uZXh0SWQiLCJ0b3BpY0FsaWFzIiwidG9waWNBbGlhc01heGltdW0iLCJfc3RvcmVQYWNrZXQiLCJzdWJzY3JpYmUiLCJhcmdzIiwiQXJyYXkiLCJzdWJzIiwib2JqIiwicG9wIiwiaW52YWxpZFRvcGljIiwidmVyc2lvbiIsInZhbGlkYXRlVG9waWNzIiwibmwiLCJyYXAiLCJyaCIsImlzQXJyYXkiLCJoYXNPd25Qcm9wZXJ0eSIsImN1cnJlbnRPcHRzIiwic3Vic2NyaXB0aW9ucyIsInRvcGljcyIsInN1YiIsImdyYW50ZWQiLCJ1bnN1YnNjcmliZSIsInVuc3Vic2NyaXB0aW9ucyIsImZvcmNlIiwiY2xvc2VTdG9yZXMiLCJkaXNjb25uZWN0ZWQiLCJjbG9zZSIsImFwcGx5IiwiX2RlZmVycmVkUmVjb25uZWN0IiwiZmluaXNoIiwicmVtb3ZlT3V0Z29pbmdNZXNzYWdlIiwibWlkIiwiZGVsIiwicmVjb25uZWN0IiwiX3JlY29ubmVjdCIsInJlY29ubmVjdGluZyIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImZvcmNlZCIsImRlc3Ryb3kiLCJyZW1vdmVMaXN0ZW5lciIsIl9zaGlmdFBpbmdJbnRlcnZhbCIsIl9zZXR1cFBpbmdUaW1lciIsInBpbmdSZXNwIiwiX2NoZWNrUGluZyIsInJlc2NoZWR1bGUiLCJyYyIsInJldHVybkNvZGUiLCJzZXJ2ZXJLZWVwQWxpdmUiLCJfb25Db25uZWN0IiwidmFsaWRSZWFzb25Db2RlcyIsImVycm9yIiwiaW5kZXhPZiIsImhhbmRsZU1lc3NhZ2UiLCJ0eXBlIiwicmVzcG9uc2UiLCJwdWJhY2tSQyIsInB1YnJlY1JDIiwiZ3JhbnRlZEkiLCJjb21wIiwiZ2V0IiwicHViIiwiaWQiLCJnZXRMYXN0TWVzc2FnZUlkIiwiX3Jlc3Vic2NyaWJlIiwiY29ubmFjayIsIl9yZXN1YnNjcmliZVRvcGljc0tleXMiLCJzZXNzaW9uUHJlc2VudCIsInRvcGljSSIsInJlc3Vic2NyaWJlVG9waWMiLCJzdGFydFN0cmVhbVByb2Nlc3MiLCJvdXRTdG9yZSIsImNyZWF0ZVN0cmVhbSIsImNsZWFyU3RvcmVQcm9jZXNzaW5nIiwicmVtb3ZlIiwic3RvcmVEZWxpdmVyIiwicmVhZCIsInN0YXR1cyIsImFsbFByb2Nlc3NlZCIsInNlbGYiLCJ3aW5kb3ciLCJCdWZmZXIiLCJUcmFuc2Zvcm0iLCJkdXBsZXhpZnkiLCJiYXNlNjQiLCJteSIsInByb3h5IiwiaXNJbml0aWFsaXplZCIsImJ1aWxkUHJveHkiLCJjaHVuayIsImVuY29kaW5nIiwibmV4dCIsInNlbmRTb2NrZXRNZXNzYWdlIiwiZGF0YSIsImJ1ZmZlciIsInN1Y2Nlc3MiLCJmYWlsIiwiX2ZsdXNoIiwic29ja2V0RW5kIiwiY2xvc2VTb2NrZXQiLCJzZXREZWZhdWx0T3B0cyIsImhvc3RuYW1lIiwicGF0aCIsIndzT3B0aW9ucyIsImJ1aWxkVXJsIiwicHJvdG9jb2wiLCJ1cmwiLCJwb3J0IiwidHJhbnNmb3JtV3NVcmwiLCJiaW5kRXZlbnRIYW5kbGVyIiwib25Tb2NrZXRPcGVuIiwic2V0UmVhZGFibGUiLCJzZXRXcml0YWJsZSIsIm9uU29ja2V0TWVzc2FnZSIsInJlcyIsImFycmF5IiwidG9CeXRlQXJyYXkiLCJmcm9tIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJBcnJheUJ1ZmZlciIsInJlYWRBc0FycmF5QnVmZmVyIiwib25Tb2NrZXRDbG9zZSIsIm9uU29ja2V0RXJyb3IiLCJidWlsZFN0cmVhbSIsImhvc3QiLCJ3ZWJzb2NrZXRTdWJQcm90b2NvbCIsImNvbm5lY3RTb2NrZXQiLCJwcm90b2NvbHMiLCJuZXQiLCJidWlsZEJ1aWxkZXIiLCJjcmVhdGVDb25uZWN0aW9uIiwidGxzIiwibXF0dENsaWVudCIsImNvbm5lY3Rpb24iLCJyZWplY3RVbmF1dGhvcml6ZWQiLCJjb25uZWN0IiwiYXV0aG9yaXplZCIsImhhbmRsZVRMU2Vycm9ycyIsIndlYnNvY2tldCIsInVybE1vZHVsZSIsIldTU19PUFRJT05TIiwiSVNfQlJPV1NFUiIsInRpdGxlIiwicHJvcCIsImNyZWF0ZVdlYlNvY2tldCIsImJ1aWxkQnVpbGRlckJyb3dzZXIiLCJkb2N1bWVudCIsInBhcnNlZCIsIlVSTCIsInNvY2tldFRhc2siLCJzZW5kIiwiZXJyTXNnIiwib25PcGVuIiwib25NZXNzYWdlIiwib25DbG9zZSIsIm9uRXJyb3IiLCJ3eCIsIl9kZXN0cm95IiwiZGVzdHJveVJlZiIsIlJlYWRhYmxlIiwic3RyZWFtc09wdHMiLCJvYmplY3RNb2RlIiwiZGVmYXVsdFN0b3JlT3B0aW9ucyIsIk1hcCIsIl9pbmZsaWdodHMiLCJzZXQiLCJkZXN0cm95ZWQiLCJ2YWx1ZXMiLCJ2YWx1ZSIsImtleSIsIl9yZWFkIiwiZGVsZXRlIiwidmFsaWRhdGVUb3BpYyIsInBhcnRzIiwic3BsaXQiLCJtcXR0IiwidGNwIiwic3NsIiwibXF0dHMiLCJ3eHMiLCJhbGkiLCJhbGlzIiwid3MiLCJ3c3MiLCJwYXJzZUF1dGhPcHRpb25zIiwibWF0Y2hlcyIsImF1dGgiLCJtYXRjaCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJicm9rZXJVcmwiLCJOdW1iZXIiLCJyZXBsYWNlIiwicXVlcnkiLCJjZXJ0IiwiaXNTZWN1cmUiLCJmaWx0ZXIiLCJpbmRleCIsImRlZmF1bHRQcm90b2NvbCIsIndyYXBwZXIiLCJzZXJ2ZXJzIiwiX3JlY29ubmVjdENvdW50IiwiYnl0ZUxlbmd0aCIsImZyb21CeXRlQXJyYXkiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJVaW50OEFycmF5IiwibGVuIiwiY2hhckNvZGVBdCIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImFyciIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJvdXRwdXQiLCJqb2luIiwiZXh0cmFCeXRlcyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsImllZWU3NTQiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJLX01BWF9MRU5HVEgiLCJrTWF4TGVuZ3RoIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0IiwiY29uc29sZSIsIl9fcHJvdG9fXyIsImZvbyIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImlzQnVmZmVyIiwiYnl0ZU9mZnNldCIsImNyZWF0ZUJ1ZmZlciIsIlJhbmdlRXJyb3IiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiVHlwZUVycm9yIiwiYWxsb2NVbnNhZmUiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uZmlndXJhYmxlIiwicG9vbFNpemUiLCJmcm9tU3RyaW5nIiwiaXNWaWV3IiwiZnJvbUFycmF5TGlrZSIsImlzSW5zdGFuY2UiLCJmcm9tQXJyYXlCdWZmZXIiLCJ2YWx1ZU9mIiwiYiIsImZyb21PYmplY3QiLCJ0b1ByaW1pdGl2ZSIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsInN0cmluZyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJ3cml0ZSIsInNsaWNlIiwiY29weSIsIm51bWJlcklzTmFOIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsIm9mZnNldCIsIngiLCJ5IiwibWluIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiLCJsaXN0IiwicG9zIiwibXVzdE1hdGNoIiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsIm0iLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJ0b0xvY2FsZVN0cmluZyIsImVxdWFscyIsImluc3BlY3QiLCJzdHIiLCJ0cmltIiwidGFyZ2V0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwidmFsIiwiZGlyIiwiYXJyYXlJbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJqIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlSW50IiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIl9hcnIiLCJmaXJzdEJ5dGUiLCJjb2RlUG9pbnQiLCJieXRlc1BlclNlcXVlbmNlIiwic2Vjb25kQnl0ZSIsInRoaXJkQnl0ZSIsImZvdXJ0aEJ5dGUiLCJ0ZW1wQ29kZVBvaW50IiwiZGVjb2RlQ29kZVBvaW50c0FycmF5IiwiTUFYX0FSR1VNRU5UU19MRU5HVEgiLCJjb2RlUG9pbnRzIiwiZnJvbUNoYXJDb2RlIiwicmV0Iiwib3V0IiwidG9IZXgiLCJieXRlcyIsIm5ld0J1ZiIsInN1YmFycmF5IiwiY2hlY2tPZmZzZXQiLCJleHQiLCJyZWFkVUludExFIiwibm9Bc3NlcnQiLCJtdWwiLCJyZWFkVUludEJFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludExFIiwicG93IiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsImxpbWl0Iiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJjb3B5V2l0aGluIiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsInNyYyIsImRzdCIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm9iamVjdENyZWF0ZSIsIm9iamVjdENyZWF0ZVBvbHlmaWxsIiwib2JqZWN0S2V5cyIsIm9iamVjdEtleXNQb2x5ZmlsbCIsIkZ1bmN0aW9uIiwiZnVuY3Rpb25CaW5kUG9seWZpbGwiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJoYXNEZWZpbmVQcm9wZXJ0eSIsImlzTmFOIiwiJGdldE1heExpc3RlbmVycyIsImdldE1heExpc3RlbmVycyIsImVtaXROb25lIiwiaGFuZGxlciIsImlzRm4iLCJsaXN0ZW5lcnMiLCJhcnJheUNsb25lIiwiZW1pdE9uZSIsImFyZzEiLCJlbWl0VHdvIiwiYXJnMiIsImVtaXRUaHJlZSIsImFyZzMiLCJlbWl0TWFueSIsImVyIiwiZG9FcnJvciIsImNvbnRleHQiLCJfYWRkTGlzdGVuZXIiLCJsaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwidW5zaGlmdCIsIndhcm5lZCIsInciLCJlbWl0dGVyIiwiY291bnQiLCJ3YXJuIiwiYWRkTGlzdGVuZXIiLCJwcmVwZW5kTGlzdGVuZXIiLCJvbmNlV3JhcHBlciIsImZpcmVkIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNwbGljZU9uZSIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9saXN0ZW5lcnMiLCJ1bndyYXAiLCJldmxpc3RlbmVyIiwidW53cmFwTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJSZWZsZWN0Iiwib3duS2V5cyIsInByb3RvIiwiRiIsImZuIiwib2JqZWN0VG9TdHJpbmciLCJpc0Jvb2xlYW4iLCJpc051bGwiLCJpc051bGxPclVuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwiaXNSZWdFeHAiLCJyZSIsImlzT2JqZWN0IiwiaXNEYXRlIiwiZCIsImlzRXJyb3IiLCJpc0Z1bmN0aW9uIiwiaXNQcmltaXRpdmUiLCJub3JtYWxpemVPcHRpb25zIiwiZW5zdXJlQ2FsbGFibGUiLCJtYXAiLCJjYWxsYWJsZSIsInZhbGlkVmFsdWUiLCJkZXNjIiwiZGdzIiwib3ZlcndyaXRlRGVmaW5pdGlvbiIsInJlc29sdmVDb250ZXh0IiwicHJvcHMiLCJhc3NpZ24iLCJub3JtYWxpemVPcHRzIiwiaXNDYWxsYWJsZSIsImNvbnRhaW5zIiwiZHNjciIsImdzIiwiZW9zIiwiU0lHTkFMX0ZMVVNIIiwib251bmNvcmsiLCJfY29ya2VkIiwiYXV0b0Rlc3Ryb3kiLCJfYXV0b0Rlc3Ryb3kiLCJkZXN0cm95ZXIiLCJfZW5kZWQiLCJfd3JpdGFibGVTdGF0ZSIsImZpbmlzaGVkIiwidG9TdHJlYW1zMiIsInJzIiwiaGlnaFdhdGVyTWFyayIsIndyYXAiLCJEdXBsZXhpZnkiLCJyZWFkYWJsZSIsIkR1cGxleCIsIl93cml0YWJsZSIsIl9yZWFkYWJsZSIsIl9yZWFkYWJsZTIiLCJfZm9yd2FyZERlc3Ryb3kiLCJfZm9yd2FyZEVuZCIsIl9vbmRyYWluIiwiX2RyYWluZWQiLCJfZm9yd2FyZGluZyIsIl91bndyaXRlIiwiX3VucmVhZCIsImNvcmsiLCJ1bmNvcmsiLCJ1bmVuZCIsIm9uZHJhaW4iLCJyZXN1bWUiLCJvbnJlYWRhYmxlIiwiX2ZvcndhcmQiLCJvbmVuZCIsIl9yZWFkYWJsZVN0YXRlIiwiX2ZpbmlzaCIsInByZWZpbmlzaGVkIiwiZW5kaW5nIiwibm9vcCIsImlzUmVxdWVzdCIsInNldEhlYWRlciIsImFib3J0IiwiaXNDaGlsZFByb2Nlc3MiLCJzdGRpbyIsIm9ubGVnYWN5ZmluaXNoIiwib25maW5pc2giLCJvbmV4aXQiLCJleGl0Q29kZSIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiZW5kZWQiLCJvbnJlcXVlc3QiLCJyZXEiLCJ0b1Bvc0ludCIsIm9iakhhc093blByb3BlcnR5IiwiYWJzIiwic2VhcmNoRWxlbWVudCIsImZyb21JbmRleCIsIkJvb2xlYW4iLCJpdGVyYXRvclN5bWJvbCIsIml0ZXJhdG9yIiwiaXNBcmd1bWVudHMiLCJpc1ZhbHVlIiwiYXJyYXlMaWtlIiwibWFwRm4iLCJ0aGlzQXJnIiwiQ29udGV4dCIsImdldEl0ZXJhdG9yIiwib2JqVG9TdHJpbmciLCJzaWduIiwiTmFOIiwidG9JbnRlZ2VyIiwib2JqUHJvcGVydHlJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm1ldGhvZCIsImRlZlZhbCIsImNvbXBhcmVGbiIsInNvcnQiLCJiYXIiLCJ0cnp5IiwiZGVzdCIsImFGcm9tIiwicHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZSIsImVuc3VyZSIsInNoaW0iLCJudWxsT2JqZWN0IiwicG9seVByb3BzIiwibGV2ZWwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZGVmaW5lUHJvcGVydGllcyIsImZ1bmN0aW9uIiwib2JqZWN0IiwiX3VuZGVmaW5lZCIsInRhcmdldE9iaiIsIm9wdHMxIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsInBsYWluT2JqZWN0IiwiY3VzdG9tQ3JlYXRlIiwib2JqSXNQcm90b3R5cGVPZiIsImlzUHJvdG90eXBlT2YiLCJudWxsRGVzYyIsInZhbGlkYXRlIiwiaXNOdWxsQmFzZSIsIm51bGxQb2x5ZmlsbCIsInRtcE9iajEiLCJ0bXBPYmoyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaWdub3JlIiwic2VhcmNoU3RyaW5nIiwiSXRlcmF0b3IiLCJBcnJheUl0ZXJhdG9yIiwia2luZCIsIl9yZXNvbHZlIiwiX19raW5kX18iLCJfX2xpc3RfXyIsInRvU3RyaW5nVGFnIiwic29tZSIsIml0ZXJhYmxlIiwibW9kZSIsImRvQnJlYWsiLCJicm9rZW4iLCJjaGFyIiwiU3RyaW5nSXRlcmF0b3IiLCJhdXRvQmluZCIsIl9fY29udGV4dF9fIiwiX19uZXh0SW5kZXhfXyIsIl9vbkFkZCIsIl9vbkRlbGV0ZSIsIl9vbkNsZWFyIiwiX25leHQiLCJfX3JlZG9fXyIsIl91bkJpbmQiLCJfY3JlYXRlUmVzdWx0Iiwib2ZmIiwicmVkbyIsInNwbGljZSIsIl9fbGVuZ3RoX18iLCJpc0l0ZXJhYmxlIiwiZW50cmllcyIsImhhcyIsInRvU3RyaW5nVGFnU3ltYm9sIiwia2luZHMiLCJ1bkJpbmQiLCJNYXBJdGVyYXRvciIsIl9fbWFwS2V5c0RhdGFfXyIsIl9fdmFsdWVzX18iLCJfX21hcFZhbHVlc0RhdGFfXyIsImVJbmRleE9mIiwiZWUiLCJmb3JPZiIsImlzTmF0aXZlIiwiTWFwUG9seSIsInZhbGlkVHlwZXMiLCJzeW1ib2wiLCJ2YWxpZGF0ZVN5bWJvbCIsIm9ialByb3RvdHlwZSIsIk5hdGl2ZVN5bWJvbCIsIlN5bWJvbFBvbHlmaWxsIiwiSGlkZGVuU3ltYm9sIiwiZ2xvYmFsU3ltYm9scyIsImlzTmF0aXZlU2FmZSIsImdlbmVyYXRlTmFtZSIsImNyZWF0ZWQiLCJwb3N0Zml4IiwiaWUxMUJ1Z1dvcmthcm91bmQiLCJkZXNjcmlwdGlvbiIsIl9fZGVzY3JpcHRpb25fXyIsIl9fbmFtZV9fIiwiZm9yIiwia2V5Rm9yIiwicyIsImhhc0luc3RhbmNlIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwic2VhcmNoIiwidW5zY29wYWJsZXMiLCJkZXNjcmlwdG9yIiwibWV0aG9kcyIsImRlc2NyaXB0b3JzIiwiYmFzZSIsIl9fZWVfXyIsIl9fZWVPbmNlTGlzdGVuZXJfXyIsImNhbmRpZGF0ZSIsImwiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsInJ0IiwibG9nIiwiTE4yIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiaXNTbG93QnVmZmVyIiwidHlwZXMiLCJjb2RlcyIsInYiLCJDTURfU0hJRlQiLCJDTURfTUFTSyIsIkRVUF9NQVNLIiwiUU9TX01BU0siLCJRT1NfU0hJRlQiLCJSRVRBSU5fTUFTSyIsIkxFTkdUSF9NQVNLIiwiTEVOR1RIX0ZJTl9NQVNLIiwiU0VTU0lPTlBSRVNFTlRfTUFTSyIsIlNFU1NJT05QUkVTRU5UX0hFQURFUiIsIkNPTk5BQ0tfSEVBREVSIiwiVVNFUk5BTUVfTUFTSyIsIlBBU1NXT1JEX01BU0siLCJXSUxMX1JFVEFJTl9NQVNLIiwiV0lMTF9RT1NfTUFTSyIsIldJTExfUU9TX1NISUZUIiwiV0lMTF9GTEFHX01BU0siLCJDTEVBTl9TRVNTSU9OX01BU0siLCJDT05ORUNUX0hFQURFUiIsInNlc3Npb25FeHBpcnlJbnRlcnZhbCIsIndpbGxEZWxheUludGVydmFsIiwicmVjZWl2ZU1heGltdW0iLCJyZXF1ZXN0UmVzcG9uc2VJbmZvcm1hdGlvbiIsInJlcXVlc3RQcm9ibGVtSW5mb3JtYXRpb24iLCJ1c2VyUHJvcGVydGllcyIsInBheWxvYWRGb3JtYXRJbmRpY2F0b3IiLCJtZXNzYWdlRXhwaXJ5SW50ZXJ2YWwiLCJjb250ZW50VHlwZSIsInJlc3BvbnNlVG9waWMiLCJjb3JyZWxhdGlvbkRhdGEiLCJtYXhpbXVtUW9TIiwicmV0YWluQXZhaWxhYmxlIiwiYXNzaWduZWRDbGllbnRJZGVudGlmaWVyIiwid2lsZGNhcmRTdWJzY3JpcHRpb25BdmFpbGFibGUiLCJzdWJzY3JpcHRpb25JZGVudGlmaWVyc0F2YWlsYWJsZSIsInNoYXJlZFN1YnNjcmlwdGlvbkF2YWlsYWJsZSIsInJlc3BvbnNlSW5mb3JtYXRpb24iLCJzZXJ2ZXJSZWZlcmVuY2UiLCJzdWJzY3JpcHRpb25JZGVudGlmaWVyIiwicHJvcGVydGllc0NvZGVzIiwicHJvcGVydGllc1R5cGVzIiwiZ2VuSGVhZGVyIiwiUFVCTElTSF9IRUFERVIiLCJTVUJTQ1JJQkVfSEVBREVSIiwiU1VCU0NSSUJFX09QVElPTlNfUU9TX01BU0siLCJTVUJTQ1JJQkVfT1BUSU9OU19OTF9NQVNLIiwiU1VCU0NSSUJFX09QVElPTlNfTkxfU0hJRlQiLCJTVUJTQ1JJQkVfT1BUSU9OU19SQVBfTUFTSyIsIlNVQlNDUklCRV9PUFRJT05TX1JBUF9TSElGVCIsIlNVQlNDUklCRV9PUFRJT05TX1JIX01BU0siLCJTVUJTQ1JJQkVfT1BUSU9OU19SSF9TSElGVCIsIlNVQlNDUklCRV9PUFRJT05TX1JIIiwiU1VCU0NSSUJFX09QVElPTlNfTkwiLCJTVUJTQ1JJQkVfT1BUSU9OU19SQVAiLCJTVUJTQ1JJQkVfT1BUSU9OU19RT1MiLCJVTlNVQlNDUklCRV9IRUFERVIiLCJBQ0tTIiwidW5zdWJhY2siLCJwdWJhY2siLCJwdWJjb21wIiwicHVicmVsIiwicHVicmVjIiwiU1VCQUNLX0hFQURFUiIsIlZFUlNJT04zIiwiVkVSU0lPTjQiLCJWRVJTSU9ONSIsIlFPUyIsIkVNUFRZIiwicGluZ3JlcSIsInBpbmdyZXNwIiwiZGlzY29ubmVjdCIsIkVFIiwiZ2VuZXJhdGUiLCJBY2N1bXVsYXRvciIsIl9hcnJheSIsIl9pIiwibGVuZ3RocyIsIkR1cGxleFN0cmVhbSIsInV0aWwiLCJCdWZmZXJMaXN0IiwiX2J1ZnMiLCJfY2FsbGJhY2siLCJwaXBlciIsIm9uUGlwZSIsIm9uVW5waXBlIiwiYXBwZW5kIiwiX29mZnNldCIsInRvdCIsIl90IiwiX2FwcGVuZEJ1ZmZlciIsImFwcGVuZEJ1ZmZlciIsImNvbnN1bWUiLCJkc3RTdGFydCIsInNyY1N0YXJ0Iiwic3JjRW5kIiwiYnVmb2ZmIiwic2hhbGxvd1NsaWNlIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJidWZmZXJzIiwiZHVwbGljYXRlIiwiY2FjaGUiLCJnZW5lcmF0ZUJ1ZmZlciIsImdlbmVyYXRlQ2FjaGUiLCJjYWxjVmFyaWFibGVCeXRlSW50TGVuZ3RoIiwiZ2VuQnVmVmFyaWFibGVCeXRlSW50IiwiZGlnaXQiLCJnZW5lcmF0ZTRCeXRlQnVmZmVyIiwiZ2VuZXJhdGVOdW1iZXIiLCJQYWNrZXQiLCJibCIsImNvbnN0YW50cyIsIlBhcnNlciIsIm9wdCIsInNldHRpbmdzIiwiX3N0YXRlcyIsIl9yZXNldFN0YXRlIiwiX2xpc3QiLCJfc3RhdGVDb3VudGVyIiwiX3BhcnNlSGVhZGVyIiwiemVybyIsIl9wYXJzZUxlbmd0aCIsIl9wYXJzZVZhckJ5dGVOdW0iLCJfcGFyc2VQYXlsb2FkIiwiX3BvcyIsIl9wYXJzZUNvbm5lY3QiLCJfcGFyc2VDb25uYWNrIiwiX3BhcnNlUHVibGlzaCIsIl9wYXJzZUNvbmZpcm1hdGlvbiIsIl9wYXJzZVN1YnNjcmliZSIsIl9wYXJzZVN1YmFjayIsIl9wYXJzZVVuc3Vic2NyaWJlIiwiX3BhcnNlVW5zdWJhY2siLCJfcGFyc2VEaXNjb25uZWN0IiwiX3BhcnNlQXV0aCIsIl9lbWl0RXJyb3IiLCJmbGFncyIsIl9wYXJzZVN0cmluZyIsIndpbGwiLCJfcGFyc2VOdW0iLCJfcGFyc2VQcm9wZXJ0aWVzIiwid2lsbFByb3BlcnRpZXMiLCJfcGFyc2VCdWZmZXIiLCJfcGFyc2VNZXNzYWdlSWQiLCJzdWJzY3JpcHRpb24iLCJfcGFyc2VCeXRlIiwibWF5YmVCdWZmZXIiLCJfcGFyc2VTdHJpbmdQYWlyIiwiX3BhcnNlNEJ5dGVOdW0iLCJmdWxsSW5mb0ZsYWciLCJjdXJyZW50IiwicGFkZGluZyIsIl9wYXJzZUJ5VHlwZSIsImN1cnJlbnRVc2VyUHJvcGVydHkiLCJfbmV3UGFja2V0IiwiZW1wdHkiLCJ6ZXJvQnVmIiwibnVtYmVycyIsIm51bUNhY2hlIiwid3JpdGVOdW1iZXIiLCJ3cml0ZU51bWJlckNhY2hlZCIsInRvR2VuZXJhdGUiLCJjb25maXJtYXRpb24iLCJzdWJhY2siLCJlbXB0eVBhY2tldCIsIndyaXRlTnVtYmVyR2VuZXJhdGVkIiwicHJvcGVydGllc0RhdGEiLCJnZXRQcm9wZXJ0aWVzIiwicHJvdmlkZWRVc2VybmFtZSIsImlzU3RyaW5nT3JCdWZmZXIiLCJ3cml0ZVZhckJ5dGVJbnQiLCJ3cml0ZVN0cmluZ09yQnVmZmVyIiwid3JpdGVTdHJpbmciLCJnZXRQcm9wZXJ0aWVzQnlNYXhpbXVtUGFja2V0U2l6ZSIsIml0b3BpYyIsImlxb3MiLCJqdG9waWMiLCJqcW9zIiwiam5sIiwianJhcCIsImpyaCIsImpvcHRpb25zIiwidW5zdWJzIiwidmFyQnl0ZUludENhY2hlIiwic3RybGVuIiwid3JpdGVTdHJpbmdQYWlyIiwibnVtYmVyIiwid3JpdGU0Qnl0ZU51bWJlciIsInRvV3JpdGUiLCJ3cml0ZVByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzTGVuZ3RoIiwiZ2V0TGVuZ3RoUHJvcGVydHkiLCJyZWR1Y2UiLCJwcm9wTmFtZSIsInByb3BMZW5ndGgiLCJwcm9wZXJ0aWVzTGVuZ3RoTGVuZ3RoIiwibWF5RW1wdHlQcm9wcyIsImN1cnJlbnRNYXlFbXB0eVByb3AiLCJidWZPclN0cmluZyIsImZpZWxkIiwid3JhcHB5Iiwic3RyaWN0Iiwib25jZVN0cmljdCIsImNhbGxlZCIsIm9uY2VFcnJvciIsImFmdGVyVGlja09uZSIsImFmdGVyVGlja1R3byIsImFmdGVyVGlja1RocmVlIiwiYWZ0ZXJUaWNrIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwiSXRlbSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsInJvb3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJwdW55Y29kZSIsIm1heEludCIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZGVsaW1pdGVyIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJiYXNlTWludXNUTWluIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiZGlnaXRUb0Jhc2ljIiwiZmxhZyIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJkZWNvZGUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsImJhc2VNaW51c1QiLCJlbmNvZGUiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwicSIsImN1cnJlbnRWYWx1ZSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0ZXN0IiwidG9BU0NJSSIsImFtZCIsInFzIiwic2VwIiwiZXEiLCJyZWdleHAiLCJtYXhLZXlzIiwiaWR4Iiwia3N0ciIsInZzdHIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ4cyIsInN0cmluZ2lmeVByaW1pdGl2ZSIsImtzIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic3RyaW5naWZ5IiwicG5hIiwiYWxsb3dIYWxmT3BlbiIsIm9uRW5kTlQiLCJQYXNzVGhyb3VnaCIsIl90cmFuc2Zvcm0iLCJSZWFkYWJsZVN0YXRlIiwiRUVsaXN0ZW5lckNvdW50IiwiU3RyZWFtIiwiT3VyVWludDhBcnJheSIsIl91aW50OEFycmF5VG9CdWZmZXIiLCJfaXNVaW50OEFycmF5IiwiZGVidWdVdGlsIiwiZGVidWciLCJkZWJ1Z2xvZyIsImRlc3Ryb3lJbXBsIiwiU3RyaW5nRGVjb2RlciIsImtQcm94eUV2ZW50cyIsImV2ZW50IiwiaXNEdXBsZXgiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJod20iLCJyZWFkYWJsZUh3bSIsInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsImRlZmF1bHRId20iLCJwaXBlcyIsInBpcGVzQ291bnQiLCJmbG93aW5nIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJzeW5jIiwibmVlZFJlYWRhYmxlIiwiZW1pdHRlZFJlYWRhYmxlIiwicmVhZGFibGVMaXN0ZW5pbmciLCJyZXN1bWVTY2hlZHVsZWQiLCJkZWZhdWx0RW5jb2RpbmciLCJhd2FpdERyYWluIiwicmVhZGluZ01vcmUiLCJkZWNvZGVyIiwiX3VuZGVzdHJveSIsInVuZGVzdHJveSIsInNraXBDaHVua0NoZWNrIiwicmVhZGFibGVBZGRDaHVuayIsImFkZFRvRnJvbnQiLCJvbkVvZkNodW5rIiwiY2h1bmtJbnZhbGlkIiwiYWRkQ2h1bmsiLCJtYXliZVJlYWRNb3JlIiwibmVlZE1vcmVEYXRhIiwiZW1pdFJlYWRhYmxlIiwiaXNQYXVzZWQiLCJzZXRFbmNvZGluZyIsIk1BWF9IV00iLCJjb21wdXRlTmV3SGlnaFdhdGVyTWFyayIsImhvd011Y2hUb1JlYWQiLCJoZWFkIiwibk9yaWciLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsImZyb21MaXN0IiwiZW1pdFJlYWRhYmxlXyIsImZsb3ciLCJtYXliZVJlYWRNb3JlXyIsInBpcGVPcHRzIiwiZG9FbmQiLCJzdGRvdXQiLCJzdGRlcnIiLCJlbmRGbiIsInVucGlwZSIsIm9udW5waXBlIiwidW5waXBlSW5mbyIsImhhc1VucGlwZWQiLCJjbGVhbnVwIiwicGlwZU9uRHJhaW4iLCJjbGVhbmVkVXAiLCJvbmRhdGEiLCJuZWVkRHJhaW4iLCJpbmNyZWFzZWRBd2FpdERyYWluIiwicGF1c2UiLCJkZXN0cyIsImV2IiwiblJlYWRpbmdOZXh0VGljayIsInJlc3VtZV8iLCJfdGhpcyIsInBhdXNlZCIsIl9mcm9tTGlzdCIsImZyb21MaXN0UGFydGlhbCIsImhhc1N0cmluZ3MiLCJjb3B5RnJvbUJ1ZmZlclN0cmluZyIsImNvcHlGcm9tQnVmZmVyIiwibmIiLCJ0YWlsIiwiZW5kUmVhZGFibGVOVCIsImFmdGVyVHJhbnNmb3JtIiwidHMiLCJfdHJhbnNmb3JtU3RhdGUiLCJ0cmFuc2Zvcm1pbmciLCJ3cml0ZWNiIiwid3JpdGVjaHVuayIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwidHJhbnNmb3JtIiwicHJlZmluaXNoIiwiX3RoaXMyIiwiZXJyMiIsIldyaXRlUmVxIiwiQ29ya2VkUmVxdWVzdCIsIm9uQ29ya2VkRmluaXNoIiwiYXN5bmNXcml0ZSIsIldyaXRhYmxlU3RhdGUiLCJpbnRlcm5hbFV0aWwiLCJkZXByZWNhdGUiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJ3cml0YWJsZUh3bSIsIndyaXRhYmxlSGlnaFdhdGVyTWFyayIsImZpbmFsQ2FsbGVkIiwibm9EZWNvZGUiLCJkZWNvZGVTdHJpbmdzIiwid3JpdGluZyIsImNvcmtlZCIsImJ1ZmZlclByb2Nlc3NpbmciLCJvbndyaXRlIiwid3JpdGVsZW4iLCJidWZmZXJlZFJlcXVlc3QiLCJsYXN0QnVmZmVyZWRSZXF1ZXN0IiwicGVuZGluZ2NiIiwiZXJyb3JFbWl0dGVkIiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJjb3JrZWRSZXF1ZXN0c0ZyZWUiLCJnZXRCdWZmZXIiLCJfIiwicmVhbEhhc0luc3RhbmNlIiwid3JpdGV2IiwiX3dyaXRldiIsImZpbmFsIiwiX2ZpbmFsIiwid3JpdGVBZnRlckVuZCIsInZhbGlkQ2h1bmsiLCJ2YWxpZCIsImlzQnVmIiwid3JpdGVPckJ1ZmZlciIsImNsZWFyQnVmZmVyIiwic2V0RGVmYXVsdEVuY29kaW5nIiwiZGVjb2RlQ2h1bmsiLCJuZXdDaHVuayIsImxhc3QiLCJkb1dyaXRlIiwib253cml0ZUVycm9yIiwiZmluaXNoTWF5YmUiLCJvbndyaXRlU3RhdGVVcGRhdGUiLCJuZWVkRmluaXNoIiwiYWZ0ZXJXcml0ZSIsIm9ud3JpdGVEcmFpbiIsImhvbGRlciIsImFsbEJ1ZmZlcnMiLCJlbmRXcml0YWJsZSIsImNhbGxGaW5hbCIsIm5lZWQiLCJjb3JrUmVxIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsImNvcHlCdWZmZXIiLCJjdXN0b20iLCJyZWFkYWJsZURlc3Ryb3llZCIsIndyaXRhYmxlRGVzdHJveWVkIiwiZW1pdEVycm9yTlQiLCJfbm9ybWFsaXplRW5jb2RpbmciLCJyZXRyaWVkIiwibm9ybWFsaXplRW5jb2RpbmciLCJuZW5jIiwidGV4dCIsInV0ZjE2VGV4dCIsInV0ZjE2RW5kIiwiZmlsbExhc3QiLCJ1dGY4RmlsbExhc3QiLCJiYXNlNjRUZXh0IiwiYmFzZTY0RW5kIiwic2ltcGxlV3JpdGUiLCJzaW1wbGVFbmQiLCJsYXN0TmVlZCIsImxhc3RUb3RhbCIsImxhc3RDaGFyIiwidXRmOEVuZCIsInV0ZjhUZXh0IiwidXRmOENoZWNrQnl0ZSIsImJ5dGUiLCJ1dGY4Q2hlY2tJbmNvbXBsZXRlIiwidXRmOENoZWNrRXh0cmFCeXRlcyIsInRvdGFsIiwiUmVJbnRlcnZhbCIsImludGVydmFsIiwiX2FyZ3MiLCJfaW50ZXJ2YWwiLCJjb3B5UHJvcHMiLCJTYWZlQnVmZmVyIiwiZ2V0U3RhdGVMZW5ndGgiLCJjbGVhckltbWVkaWF0ZSIsImltbWVkaWF0ZUlkcyIsIm5leHRJbW1lZGlhdGVJZCIsIlRpbWVvdXQiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIml0ZW0iLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0Iiwib25OZXh0VGljayIsInVybFBhcnNlIiwicmVzb2x2ZSIsInVybFJlc29sdmUiLCJyZXNvbHZlT2JqZWN0IiwidXJsUmVzb2x2ZU9iamVjdCIsImZvcm1hdCIsInVybEZvcm1hdCIsIlVybCIsInNsYXNoZXMiLCJoYXNoIiwicGF0aG5hbWUiLCJocmVmIiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsInVuc2FmZVByb3RvY29sIiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInF1ZXJ5c3RyaW5nIiwicGFyc2VRdWVyeVN0cmluZyIsInNsYXNoZXNEZW5vdGVIb3N0IiwicXVlcnlJbmRleCIsInNwbGl0dGVyIiwidVNwbGl0Iiwic2xhc2hSZWdleCIsInJlc3QiLCJzaW1wbGVQYXRoIiwiZXhlYyIsImxvd2VyUHJvdG8iLCJob3N0RW5kIiwiaGVjIiwiYXRTaWduIiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsImgiLCJhZSIsImVzYyIsImVzY2FwZSIsInFtIiwiY2hhckF0Iiwic291cmNlIiwicmVsYXRpdmUiLCJyZWwiLCJ0a2V5cyIsInRrIiwidGtleSIsInJrZXlzIiwicmsiLCJya2V5IiwicmVsUGF0aCIsImlzU291cmNlQWJzIiwiaXNSZWxBYnMiLCJtdXN0RW5kQWJzIiwicmVtb3ZlQWxsRG90cyIsInNyY1BhdGgiLCJwc3ljaG90aWMiLCJhdXRoSW5Ib3N0IiwiaGFzVHJhaWxpbmdTbGFzaCIsInVwIiwiaXNBYnNvbHV0ZSIsIm1zZyIsImNvbmZpZyIsImRlcHJlY2F0ZWQiLCJ0cmFjZSIsImxvY2FsU3RvcmFnZSIsImZvcm1hdFJlZ0V4cCIsIm9iamVjdHMiLCJKU09OIiwibm9EZXByZWNhdGlvbiIsInRocm93RGVwcmVjYXRpb24iLCJ0cmFjZURlcHJlY2F0aW9uIiwiZGVidWdzIiwiZGVidWdFbnZpcm9uIiwiTk9ERV9ERUJVRyIsInRvVXBwZXJDYXNlIiwiUmVnRXhwIiwicGlkIiwiY3R4Iiwic2VlbiIsInN0eWxpemUiLCJzdHlsaXplTm9Db2xvciIsImRlcHRoIiwiY29sb3JzIiwic2hvd0hpZGRlbiIsIl9leHRlbmQiLCJjdXN0b21JbnNwZWN0Iiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwic3R5bGVzIiwic3R5bGVUeXBlIiwic3R5bGUiLCJhcnJheVRvSGFzaCIsInJlY3Vyc2VUaW1lcyIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsInZpc2libGVLZXlzIiwiZm9ybWF0RXJyb3IiLCJEYXRlIiwiYnJhY2VzIiwidG9VVENTdHJpbmciLCJmb3JtYXRBcnJheSIsImZvcm1hdFByb3BlcnR5IiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJzaW1wbGUiLCJsaW5lIiwibnVtTGluZXNFc3QiLCJwcmV2IiwiY3VyIiwiYXIiLCJwYWQiLCJtb250aHMiLCJ0aW1lc3RhbXAiLCJ0aW1lIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldERhdGUiLCJnZXRNb250aCIsIm9yaWdpbiIsImFkZCIsIldTIiwiV2ViU29ja2V0U3RyZWFtIiwic29ja2V0V3JpdGUiLCJzb2NrZXQiLCJpc0Jyb3dzZXIiLCJXZWJTb2NrZXQiLCJzb2NrZXRXcml0ZUJyb3dzZXIiLCJzb2NrZXRXcml0ZU5vZGUiLCJiaW5hcnkiLCJidWZmZXJTaXplIiwiYnJvd3NlckJ1ZmZlclNpemUiLCJidWZmZXJUaW1lb3V0IiwiYnJvd3NlckJ1ZmZlclRpbWVvdXQiLCJiaW5hcnlUeXBlIiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJvbm9wZW4iLCJvbm1lc3NhZ2UiLCJjb2VyY2VUb0J1ZmZlciIsImJ1ZmZlcmVkQW1vdW50IiwiY2h1bmtzIiwiTW96V2ViU29ja2V0IiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiQUFBQSxrRkFBQyxVQUFTQSxDQUFULEVBQVcsQ0FBQyxJQUFHLElBQUgsRUFBMEQsQ0FBQ0MsTUFBTSxDQUFDQyxPQUFQLEdBQWVGLENBQUMsRUFBaEIsQ0FBbUIsQ0FBOUUsTUFBbUYsVUFBOE4sQ0FBOVQsRUFBZ1UsWUFBVSxDQUFDLElBQUlHLE1BQUosRUFBV0YsTUFBWCxFQUFrQkMsT0FBbEIsQ0FBMEIsT0FBUSxZQUFVLENBQUMsU0FBU0UsQ0FBVCxDQUFXQyxDQUFYLEVBQWFDLENBQWIsRUFBZUMsQ0FBZixFQUFpQixDQUFDLFNBQVNDLENBQVQsQ0FBV0MsQ0FBWCxFQUFhVCxDQUFiLEVBQWUsQ0FBQyxJQUFHLENBQUNNLENBQUMsQ0FBQ0csQ0FBRCxDQUFMLEVBQVMsQ0FBQyxJQUFHLENBQUNKLENBQUMsQ0FBQ0ksQ0FBRCxDQUFMLEVBQVMsQ0FBQyxJQUFJQyxDQUFDLEdBQUMsY0FBWSxPQUFPQyxPQUFuQixJQUE0QkEsT0FBbEMsQ0FBMEMsSUFBRyxDQUFDWCxDQUFELElBQUlVLENBQVAsRUFBUyxPQUFPQSxPQUFDLENBQUNELENBQUQsRUFBRyxDQUFDLENBQUosQ0FBUixDQUFlLElBQUdHLENBQUgsRUFBSyxPQUFPQSxDQUFDLENBQUNILENBQUQsRUFBRyxDQUFDLENBQUosQ0FBUixDQUFlLElBQUlJLENBQUMsR0FBQyxJQUFJQyxLQUFKLENBQVUseUJBQXVCTCxDQUF2QixHQUF5QixHQUFuQyxDQUFOLENBQThDLE1BQU1JLENBQUMsQ0FBQ0UsSUFBRixHQUFPLGtCQUFQLEVBQTBCRixDQUFoQyxDQUFrQyxLQUFJRyxDQUFDLEdBQUNWLENBQUMsQ0FBQ0csQ0FBRCxDQUFELEdBQUss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QUFDd0IsQ0FBRCxDQUFYO0FBQ0QsYUFGRDtBQUdEO0FBQ0QsaUJBQU9rYixHQUFQO0FBQ0Q7QUFDRjs7QUFFQSxLQW5DUyxFQW1DUixFQW5DUSxDQS91Yzh5QixFQWt4Y2x6QixLQUFJLENBQUMsVUFBU2pmLE9BQVQsRUFBaUJWLE1BQWpCLEVBQXdCQyxPQUF4QixFQUFnQztBQUMzQ0QsWUFBTSxDQUFDQyxPQUFQLEdBQWlCd2dELE1BQWpCOztBQUVBLFVBQUloMkMsY0FBYyxHQUFHL0csTUFBTSxDQUFDK0MsU0FBUCxDQUFpQmdFLGNBQXRDOztBQUVBLGVBQVNnMkMsTUFBVCxHQUFrQjtBQUNkLFlBQUkxakMsTUFBTSxHQUFHLEVBQWI7O0FBRUEsYUFBSyxJQUFJdmMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3FFLFNBQVMsQ0FBQzVELE1BQTlCLEVBQXNDVCxDQUFDLEVBQXZDLEVBQTJDO0FBQ3ZDLGNBQUkyNUMsTUFBTSxHQUFHdDFDLFNBQVMsQ0FBQ3JFLENBQUQsQ0FBdEI7O0FBRUEsZUFBSyxJQUFJNlQsR0FBVCxJQUFnQjhsQyxNQUFoQixFQUF3QjtBQUNwQixnQkFBSTF2QyxjQUFjLENBQUN6SixJQUFmLENBQW9CbTVDLE1BQXBCLEVBQTRCOWxDLEdBQTVCLENBQUosRUFBc0M7QUFDbEMwSSxvQkFBTSxDQUFDMUksR0FBRCxDQUFOLEdBQWM4bEMsTUFBTSxDQUFDOWxDLEdBQUQsQ0FBcEI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsZUFBTzBJLE1BQVA7QUFDSDs7QUFFQSxLQXJCUyxFQXFCUixFQXJCUSxDQWx4Yzh5QixFQUE1YyxFQXV5Y3JXLEVBdnljcVcsRUF1eWNsVyxDQUFDLENBQUQsQ0F2eWNrVyxFQXV5YzdWLENBdnljNlYsQ0FBUDtBQXd5Y3BXLENBeHljRCxFIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5tcXR0ID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXG52YXIgU3RvcmUgPSByZXF1aXJlKCcuL3N0b3JlJylcbnZhciBtcXR0UGFja2V0ID0gcmVxdWlyZSgnbXF0dC1wYWNrZXQnKVxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuV3JpdGFibGVcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciByZUludGVydmFsID0gcmVxdWlyZSgncmVpbnRlcnZhbCcpXG52YXIgdmFsaWRhdGlvbnMgPSByZXF1aXJlKCcuL3ZhbGlkYXRpb25zJylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBzZXRJbW1lZGlhdGUgPSBnbG9iYWwuc2V0SW1tZWRpYXRlIHx8IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAvLyB3b3JrcyBpbiBub2RlIHYwLjhcbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbn1cbnZhciBkZWZhdWx0Q29ubmVjdE9wdGlvbnMgPSB7XG4gIGtlZXBhbGl2ZTogNjAsXG4gIHJlc2NoZWR1bGVQaW5nczogdHJ1ZSxcbiAgcHJvdG9jb2xJZDogJ01RVFQnLFxuICBwcm90b2NvbFZlcnNpb246IDQsXG4gIHJlY29ubmVjdFBlcmlvZDogMTAwMCxcbiAgY29ubmVjdFRpbWVvdXQ6IDMwICogMTAwMCxcbiAgY2xlYW46IHRydWUsXG4gIHJlc3Vic2NyaWJlOiB0cnVlXG59XG52YXIgZXJyb3JzID0ge1xuICAwOiAnJyxcbiAgMTogJ1VuYWNjZXB0YWJsZSBwcm90b2NvbCB2ZXJzaW9uJyxcbiAgMjogJ0lkZW50aWZpZXIgcmVqZWN0ZWQnLFxuICAzOiAnU2VydmVyIHVuYXZhaWxhYmxlJyxcbiAgNDogJ0JhZCB1c2VybmFtZSBvciBwYXNzd29yZCcsXG4gIDU6ICdOb3QgYXV0aG9yaXplZCcsXG4gIDE2OiAnTm8gbWF0Y2hpbmcgc3Vic2NyaWJlcnMnLFxuICAxNzogJ05vIHN1YnNjcmlwdGlvbiBleGlzdGVkJyxcbiAgMTI4OiAnVW5zcGVjaWZpZWQgZXJyb3InLFxuICAxMjk6ICdNYWxmb3JtZWQgUGFja2V0JyxcbiAgMTMwOiAnUHJvdG9jb2wgRXJyb3InLFxuICAxMzE6ICdJbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBlcnJvcicsXG4gIDEzMjogJ1Vuc3VwcG9ydGVkIFByb3RvY29sIFZlcnNpb24nLFxuICAxMzM6ICdDbGllbnQgSWRlbnRpZmllciBub3QgdmFsaWQnLFxuICAxMzQ6ICdCYWQgVXNlciBOYW1lIG9yIFBhc3N3b3JkJyxcbiAgMTM1OiAnTm90IGF1dGhvcml6ZWQnLFxuICAxMzY6ICdTZXJ2ZXIgdW5hdmFpbGFibGUnLFxuICAxMzc6ICdTZXJ2ZXIgYnVzeScsXG4gIDEzODogJ0Jhbm5lZCcsXG4gIDEzOTogJ1NlcnZlciBzaHV0dGluZyBkb3duJyxcbiAgMTQwOiAnQmFkIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCcsXG4gIDE0MTogJ0tlZXAgQWxpdmUgdGltZW91dCcsXG4gIDE0MjogJ1Nlc3Npb24gdGFrZW4gb3ZlcicsXG4gIDE0MzogJ1RvcGljIEZpbHRlciBpbnZhbGlkJyxcbiAgMTQ0OiAnVG9waWMgTmFtZSBpbnZhbGlkJyxcbiAgMTQ1OiAnUGFja2V0IGlkZW50aWZpZXIgaW4gdXNlJyxcbiAgMTQ2OiAnUGFja2V0IElkZW50aWZpZXIgbm90IGZvdW5kJyxcbiAgMTQ3OiAnUmVjZWl2ZSBNYXhpbXVtIGV4Y2VlZGVkJyxcbiAgMTQ4OiAnVG9waWMgQWxpYXMgaW52YWxpZCcsXG4gIDE0OTogJ1BhY2tldCB0b28gbGFyZ2UnLFxuICAxNTA6ICdNZXNzYWdlIHJhdGUgdG9vIGhpZ2gnLFxuICAxNTE6ICdRdW90YSBleGNlZWRlZCcsXG4gIDE1MjogJ0FkbWluaXN0cmF0aXZlIGFjdGlvbicsXG4gIDE1MzogJ1BheWxvYWQgZm9ybWF0IGludmFsaWQnLFxuICAxNTQ6ICdSZXRhaW4gbm90IHN1cHBvcnRlZCcsXG4gIDE1NTogJ1FvUyBub3Qgc3VwcG9ydGVkJyxcbiAgMTU2OiAnVXNlIGFub3RoZXIgc2VydmVyJyxcbiAgMTU3OiAnU2VydmVyIG1vdmVkJyxcbiAgMTU4OiAnU2hhcmVkIFN1YnNjcmlwdGlvbnMgbm90IHN1cHBvcnRlZCcsXG4gIDE1OTogJ0Nvbm5lY3Rpb24gcmF0ZSBleGNlZWRlZCcsXG4gIDE2MDogJ01heGltdW0gY29ubmVjdCB0aW1lJyxcbiAgMTYxOiAnU3Vic2NyaXB0aW9uIElkZW50aWZpZXJzIG5vdCBzdXBwb3J0ZWQnLFxuICAxNjI6ICdXaWxkY2FyZCBTdWJzY3JpcHRpb25zIG5vdCBzdXBwb3J0ZWQnXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRJZCAoKSB7XG4gIHJldHVybiAnbXF0dGpzXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMiwgOClcbn1cblxuZnVuY3Rpb24gc2VuZFBhY2tldCAoY2xpZW50LCBwYWNrZXQsIGNiKSB7XG4gIGNsaWVudC5lbWl0KCdwYWNrZXRzZW5kJywgcGFja2V0KVxuXG4gIHZhciByZXN1bHQgPSBtcXR0UGFja2V0LndyaXRlVG9TdHJlYW0ocGFja2V0LCBjbGllbnQuc3RyZWFtLCBjbGllbnQub3B0aW9ucylcblxuICBpZiAoIXJlc3VsdCAmJiBjYikge1xuICAgIGNsaWVudC5zdHJlYW0ub25jZSgnZHJhaW4nLCBjYilcbiAgfSBlbHNlIGlmIChjYikge1xuICAgIGNiKClcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaCAocXVldWUpIHtcbiAgaWYgKHF1ZXVlKSB7XG4gICAgT2JqZWN0LmtleXMocXVldWUpLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2VJZCkge1xuICAgICAgaWYgKHR5cGVvZiBxdWV1ZVttZXNzYWdlSWRdLmNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHF1ZXVlW21lc3NhZ2VJZF0uY2IobmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCcpKVxuICAgICAgICBkZWxldGUgcXVldWVbbWVzc2FnZUlkXVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hWb2xhdGlsZSAocXVldWUpIHtcbiAgaWYgKHF1ZXVlKSB7XG4gICAgT2JqZWN0LmtleXMocXVldWUpLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2VJZCkge1xuICAgICAgaWYgKHF1ZXVlW21lc3NhZ2VJZF0udm9sYXRpbGUgJiYgdHlwZW9mIHF1ZXVlW21lc3NhZ2VJZF0uY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcXVldWVbbWVzc2FnZUlkXS5jYihuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gY2xvc2VkJykpXG4gICAgICAgIGRlbGV0ZSBxdWV1ZVttZXNzYWdlSWRdXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZUFuZFNlbmQgKGNsaWVudCwgcGFja2V0LCBjYiwgY2JTdG9yZVB1dCkge1xuICBjbGllbnQub3V0Z29pbmdTdG9yZS5wdXQocGFja2V0LCBmdW5jdGlvbiBzdG9yZWRQYWNrZXQgKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYiAmJiBjYihlcnIpXG4gICAgfVxuICAgIGNiU3RvcmVQdXQoKVxuICAgIHNlbmRQYWNrZXQoY2xpZW50LCBwYWNrZXQsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBub3AgKCkge31cblxuLyoqXG4gKiBNcXR0Q2xpZW50IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSAtIHN0cmVhbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGNvbm5lY3Rpb24gb3B0aW9uc1xuICogKHNlZSBDb25uZWN0aW9uI2Nvbm5lY3QpXG4gKi9cbmZ1bmN0aW9uIE1xdHRDbGllbnQgKHN0cmVhbUJ1aWxkZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1xdHRDbGllbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBNcXR0Q2xpZW50KHN0cmVhbUJ1aWxkZXIsIG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgLy8gRGVmYXVsdHNcbiAgZm9yIChrIGluIGRlZmF1bHRDb25uZWN0T3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zW2tdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5vcHRpb25zW2tdID0gZGVmYXVsdENvbm5lY3RPcHRpb25zW2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9uc1trXSA9IG9wdGlvbnNba11cbiAgICB9XG4gIH1cblxuICB0aGlzLm9wdGlvbnMuY2xpZW50SWQgPSAodHlwZW9mIG9wdGlvbnMuY2xpZW50SWQgPT09ICdzdHJpbmcnKSA/IG9wdGlvbnMuY2xpZW50SWQgOiBkZWZhdWx0SWQoKVxuXG4gIHRoaXMub3B0aW9ucy5jdXN0b21IYW5kbGVBY2tzID0gKG9wdGlvbnMucHJvdG9jb2xWZXJzaW9uID09PSA1ICYmIG9wdGlvbnMuY3VzdG9tSGFuZGxlQWNrcykgPyBvcHRpb25zLmN1c3RvbUhhbmRsZUFja3MgOiBmdW5jdGlvbiAoKSB7IGFyZ3VtZW50c1szXSgwKSB9XG5cbiAgdGhpcy5zdHJlYW1CdWlsZGVyID0gc3RyZWFtQnVpbGRlclxuXG4gIC8vIEluZmxpZ2h0IG1lc3NhZ2Ugc3RvcmFnZXNcbiAgdGhpcy5vdXRnb2luZ1N0b3JlID0gb3B0aW9ucy5vdXRnb2luZ1N0b3JlIHx8IG5ldyBTdG9yZSgpXG4gIHRoaXMuaW5jb21pbmdTdG9yZSA9IG9wdGlvbnMuaW5jb21pbmdTdG9yZSB8fCBuZXcgU3RvcmUoKVxuXG4gIC8vIFNob3VsZCBRb1MgemVybyBtZXNzYWdlcyBiZSBxdWV1ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBicm9rZW4/XG4gIHRoaXMucXVldWVRb1NaZXJvID0gb3B0aW9ucy5xdWV1ZVFvU1plcm8gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLnF1ZXVlUW9TWmVyb1xuXG4gIC8vIG1hcCBvZiBzdWJzY3JpYmVkIHRvcGljcyB0byBzdXBwb3J0IHJlY29ubmVjdGlvblxuICB0aGlzLl9yZXN1YnNjcmliZVRvcGljcyA9IHt9XG5cbiAgLy8gbWFwIG9mIGEgc3Vic2NyaWJlIG1lc3NhZ2VJZCBhbmQgYSB0b3BpY1xuICB0aGlzLm1lc3NhZ2VJZFRvVG9waWMgPSB7fVxuXG4gIC8vIFBpbmcgdGltZXIsIHNldHVwIGluIF9zZXR1cFBpbmdUaW1lclxuICB0aGlzLnBpbmdUaW1lciA9IG51bGxcbiAgLy8gSXMgdGhlIGNsaWVudCBjb25uZWN0ZWQ/XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2VcbiAgLy8gQXJlIHdlIGRpc2Nvbm5lY3Rpbmc/XG4gIHRoaXMuZGlzY29ubmVjdGluZyA9IGZhbHNlXG4gIC8vIFBhY2tldCBxdWV1ZVxuICB0aGlzLnF1ZXVlID0gW11cbiAgLy8gY29ubmFjayB0aW1lclxuICB0aGlzLmNvbm5hY2tUaW1lciA9IG51bGxcbiAgLy8gUmVjb25uZWN0IHRpbWVyXG4gIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsXG4gIC8vIElzIHByb2Nlc3Npbmcgc3RvcmU/XG4gIHRoaXMuX3N0b3JlUHJvY2Vzc2luZyA9IGZhbHNlXG4gIC8vIFBhY2tldCBJZHMgYXJlIHB1dCBpbnRvIHRoZSBzdG9yZSBkdXJpbmcgc3RvcmUgcHJvY2Vzc2luZ1xuICB0aGlzLl9wYWNrZXRJZHNEdXJpbmdTdG9yZVByb2Nlc3NpbmcgPSB7fVxuICAvKipcbiAgICogTWVzc2FnZUlEcyBzdGFydGluZyB3aXRoIDFcbiAgICogZW5zdXJlIHRoYXQgbmV4dElkIGlzIG1pbi4gMSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcXR0anMvTVFUVC5qcy9pc3N1ZXMvODEwXG4gICAqL1xuICB0aGlzLm5leHRJZCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDY1NTM1KSlcblxuICAvLyBJbmZsaWdodCBjYWxsYmFja3NcbiAgdGhpcy5vdXRnb2luZyA9IHt9XG5cbiAgLy8gVHJ1ZSBpZiBjb25uZWN0aW9uIGlzIGZpcnN0IHRpbWUuXG4gIHRoaXMuX2ZpcnN0Q29ubmVjdGlvbiA9IHRydWVcblxuICAvLyBNYXJrIGRpc2Nvbm5lY3RlZCBvbiBzdHJlYW0gY2xvc2VcbiAgdGhpcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5hY2tUaW1lcilcbiAgfSlcblxuICAvLyBTZW5kIHF1ZXVlZCBwYWNrZXRzXG4gIHRoaXMub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZVxuXG4gICAgZnVuY3Rpb24gZGVsaXZlciAoKSB7XG4gICAgICB2YXIgZW50cnkgPSBxdWV1ZS5zaGlmdCgpXG4gICAgICB2YXIgcGFja2V0ID0gbnVsbFxuXG4gICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBwYWNrZXQgPSBlbnRyeS5wYWNrZXRcblxuICAgICAgdGhhdC5fc2VuZFBhY2tldChcbiAgICAgICAgcGFja2V0LFxuICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVudHJ5LmNiKSB7XG4gICAgICAgICAgICBlbnRyeS5jYihlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGl2ZXIoKVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuXG4gICAgZGVsaXZlcigpXG4gIH0pXG5cbiAgLy8gQ2xlYXIgcGluZyB0aW1lclxuICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhhdC5waW5nVGltZXIgIT09IG51bGwpIHtcbiAgICAgIHRoYXQucGluZ1RpbWVyLmNsZWFyKClcbiAgICAgIHRoYXQucGluZ1RpbWVyID0gbnVsbFxuICAgIH1cbiAgfSlcblxuICAvLyBTZXR1cCByZWNvbm5lY3QgdGltZXIgb24gZGlzY29ubmVjdFxuICB0aGlzLm9uKCdjbG9zZScsIHRoaXMuX3NldHVwUmVjb25uZWN0KVxuXG4gIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gIHRoaXMuX3NldHVwU3RyZWFtKClcbn1cbmluaGVyaXRzKE1xdHRDbGllbnQsIGV2ZW50cy5FdmVudEVtaXR0ZXIpXG5cbi8qKlxuICogc2V0dXAgdGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoZSBpbm5lciBzdHJlYW0uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9zZXR1cFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbm5lY3RQYWNrZXRcbiAgdmFyIHRoYXQgPSB0aGlzXG4gIHZhciB3cml0YWJsZSA9IG5ldyBXcml0YWJsZSgpXG4gIHZhciBwYXJzZXIgPSBtcXR0UGFja2V0LnBhcnNlcih0aGlzLm9wdGlvbnMpXG4gIHZhciBjb21wbGV0ZVBhcnNlID0gbnVsbFxuICB2YXIgcGFja2V0cyA9IFtdXG5cbiAgdGhpcy5fY2xlYXJSZWNvbm5lY3QoKVxuXG4gIHRoaXMuc3RyZWFtID0gdGhpcy5zdHJlYW1CdWlsZGVyKHRoaXMpXG5cbiAgcGFyc2VyLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgcGFja2V0cy5wdXNoKHBhY2tldClcbiAgfSlcblxuICBmdW5jdGlvbiBuZXh0VGlja1dvcmsgKCkge1xuICAgIGlmIChwYWNrZXRzLmxlbmd0aCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayh3b3JrKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZG9uZSA9IGNvbXBsZXRlUGFyc2VcbiAgICAgIGNvbXBsZXRlUGFyc2UgPSBudWxsXG4gICAgICBkb25lKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3b3JrICgpIHtcbiAgICB2YXIgcGFja2V0ID0gcGFja2V0cy5zaGlmdCgpXG5cbiAgICBpZiAocGFja2V0KSB7XG4gICAgICB0aGF0Ll9oYW5kbGVQYWNrZXQocGFja2V0LCBuZXh0VGlja1dvcmspXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb25lID0gY29tcGxldGVQYXJzZVxuICAgICAgY29tcGxldGVQYXJzZSA9IG51bGxcbiAgICAgIGlmIChkb25lKSBkb25lKClcbiAgICB9XG4gIH1cblxuICB3cml0YWJsZS5fd3JpdGUgPSBmdW5jdGlvbiAoYnVmLCBlbmMsIGRvbmUpIHtcbiAgICBjb21wbGV0ZVBhcnNlID0gZG9uZVxuICAgIHBhcnNlci5wYXJzZShidWYpXG4gICAgd29yaygpXG4gIH1cblxuICB0aGlzLnN0cmVhbS5waXBlKHdyaXRhYmxlKVxuXG4gIC8vIFN1cHByZXNzIGNvbm5lY3Rpb24gZXJyb3JzXG4gIHRoaXMuc3RyZWFtLm9uKCdlcnJvcicsIG5vcClcblxuICAvLyBFY2hvIHN0cmVhbSBjbG9zZVxuICB0aGlzLnN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmx1c2hWb2xhdGlsZSh0aGF0Lm91dGdvaW5nKVxuICAgIHRoYXQuZW1pdCgnY2xvc2UnKVxuICB9KVxuXG4gIC8vIFNlbmQgYSBjb25uZWN0IHBhY2tldFxuICBjb25uZWN0UGFja2V0ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLm9wdGlvbnMpXG4gIGNvbm5lY3RQYWNrZXQuY21kID0gJ2Nvbm5lY3QnXG4gIC8vIGF2b2lkIG1lc3NhZ2UgcXVldWVcbiAgc2VuZFBhY2tldCh0aGlzLCBjb25uZWN0UGFja2V0KVxuXG4gIC8vIEVjaG8gY29ubmVjdGlvbiBlcnJvcnNcbiAgcGFyc2VyLm9uKCdlcnJvcicsIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpKVxuXG4gIC8vIGF1dGhcbiAgaWYgKHRoaXMub3B0aW9ucy5wcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucHJvcGVydGllcy5hdXRoZW50aWNhdGlvbk1ldGhvZCAmJiB0aGlzLm9wdGlvbnMucHJvcGVydGllcy5hdXRoZW50aWNhdGlvbkRhdGEpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1BhY2tldCBoYXMgbm8gQXV0aGVudGljYXRpb24gTWV0aG9kJykpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnByb3BlcnRpZXMuYXV0aGVudGljYXRpb25NZXRob2QgJiYgdGhpcy5vcHRpb25zLmF1dGhQYWNrZXQgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5hdXRoUGFja2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGF1dGhQYWNrZXQgPSB4dGVuZCh7Y21kOiAnYXV0aCcsIHJlYXNvbkNvZGU6IDB9LCB0aGlzLm9wdGlvbnMuYXV0aFBhY2tldClcbiAgICAgIHNlbmRQYWNrZXQodGhpcywgYXV0aFBhY2tldClcbiAgICB9XG4gIH1cblxuICAvLyBtYW55IGRyYWluIGxpc3RlbmVycyBhcmUgbmVlZGVkIGZvciBxb3MgMSBjYWxsYmFja3MgaWYgdGhlIGNvbm5lY3Rpb24gaXMgaW50ZXJtaXR0ZW50XG4gIHRoaXMuc3RyZWFtLnNldE1heExpc3RlbmVycygxMDAwKVxuXG4gIGNsZWFyVGltZW91dCh0aGlzLmNvbm5hY2tUaW1lcilcbiAgdGhpcy5jb25uYWNrVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGF0Ll9jbGVhblVwKHRydWUpXG4gIH0sIHRoaXMub3B0aW9ucy5jb25uZWN0VGltZW91dClcbn1cblxuTXF0dENsaWVudC5wcm90b3R5cGUuX2hhbmRsZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIGRvbmUpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICBpZiAob3B0aW9ucy5wcm90b2NvbFZlcnNpb24gPT09IDUgJiYgb3B0aW9ucy5wcm9wZXJ0aWVzICYmIG9wdGlvbnMucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSAmJiBvcHRpb25zLnByb3BlcnRpZXMubWF4aW11bVBhY2tldFNpemUgPCBwYWNrZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignZXhjZWVkaW5nIHBhY2tldHMgc2l6ZSAnICsgcGFja2V0LmNtZCkpXG4gICAgdGhpcy5lbmQoe3JlYXNvbkNvZGU6IDE0OSwgcHJvcGVydGllczogeyByZWFzb25TdHJpbmc6ICdNYXhpbXVtIHBhY2tldCBzaXplIHdhcyBleGNlZWRlZCcgfX0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRoaXMuZW1pdCgncGFja2V0cmVjZWl2ZScsIHBhY2tldClcblxuICBzd2l0Y2ggKHBhY2tldC5jbWQpIHtcbiAgICBjYXNlICdwdWJsaXNoJzpcbiAgICAgIHRoaXMuX2hhbmRsZVB1Ymxpc2gocGFja2V0LCBkb25lKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwdWJhY2snOlxuICAgIGNhc2UgJ3B1YnJlYyc6XG4gICAgY2FzZSAncHViY29tcCc6XG4gICAgY2FzZSAnc3ViYWNrJzpcbiAgICBjYXNlICd1bnN1YmFjayc6XG4gICAgICB0aGlzLl9oYW5kbGVBY2socGFja2V0KVxuICAgICAgZG9uZSgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3B1YnJlbCc6XG4gICAgICB0aGlzLl9oYW5kbGVQdWJyZWwocGFja2V0LCBkb25lKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdjb25uYWNrJzpcbiAgICAgIHRoaXMuX2hhbmRsZUNvbm5hY2socGFja2V0KVxuICAgICAgZG9uZSgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3BpbmdyZXNwJzpcbiAgICAgIHRoaXMuX2hhbmRsZVBpbmdyZXNwKHBhY2tldClcbiAgICAgIGRvbmUoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgIHRoaXMuX2hhbmRsZURpc2Nvbm5lY3QocGFja2V0KVxuICAgICAgZG9uZSgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAvLyBtYXliZSB3ZSBzaG91bGQgZG8gYW4gZXJyb3IgaGFuZGxpbmdcbiAgICAgIC8vIG9yIGp1c3QgbG9nIGl0XG4gICAgICBicmVha1xuICB9XG59XG5cbk1xdHRDbGllbnQucHJvdG90eXBlLl9jaGVja0Rpc2Nvbm5lY3RpbmcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdjbGllbnQgZGlzY29ubmVjdGluZycpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdjbGllbnQgZGlzY29ubmVjdGluZycpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5kaXNjb25uZWN0aW5nXG59XG5cbi8qKlxuICogcHVibGlzaCAtIHB1Ymxpc2ggPG1lc3NhZ2U+IHRvIDx0b3BpYz5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgLSB0b3BpYyB0byBwdWJsaXNoIHRvXG4gKiBAcGFyYW0ge1N0cmluZywgQnVmZmVyfSBtZXNzYWdlIC0gbWVzc2FnZSB0byBwdWJsaXNoXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gcHVibGlzaCBvcHRpb25zLCBpbmNsdWRlczpcbiAqICAgIHtOdW1iZXJ9IHFvcyAtIHFvcyBsZXZlbCB0byBwdWJsaXNoIG9uXG4gKiAgICB7Qm9vbGVhbn0gcmV0YWluIC0gd2hldGhlciBvciBub3QgdG8gcmV0YWluIHRoZSBtZXNzYWdlXG4gKiAgICB7Qm9vbGVhbn0gZHVwIC0gd2hldGhlciBvciBub3QgbWFyayBhIG1lc3NhZ2UgYXMgZHVwbGljYXRlXG4gKiAgICB7RnVuY3Rpb259IGNiU3RvcmVQdXQgLSBmdW5jdGlvbigpe30gY2FsbGVkIHdoZW4gbWVzc2FnZSBpcyBwdXQgaW50byBgb3V0Z29pbmdTdG9yZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBmdW5jdGlvbihlcnIpe31cbiAqICAgIGNhbGxlZCB3aGVuIHB1Ymxpc2ggc3VjY2VlZHMgb3IgZmFpbHNcbiAqIEByZXR1cm5zIHtNcXR0Q2xpZW50fSB0aGlzIC0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqIEBleGFtcGxlIGNsaWVudC5wdWJsaXNoKCd0b3BpYycsICdtZXNzYWdlJyk7XG4gKiBAZXhhbXBsZVxuICogICAgIGNsaWVudC5wdWJsaXNoKCd0b3BpYycsICdtZXNzYWdlJywge3FvczogMSwgcmV0YWluOiB0cnVlLCBkdXA6IHRydWV9KTtcbiAqIEBleGFtcGxlIGNsaWVudC5wdWJsaXNoKCd0b3BpYycsICdtZXNzYWdlJywgY29uc29sZS5sb2cpO1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKHRvcGljLCBtZXNzYWdlLCBvcHRzLCBjYWxsYmFjaykge1xuICB2YXIgcGFja2V0XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gLnB1Ymxpc2godG9waWMsIHBheWxvYWQsIGNiKTtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgb3B0cyA9IG51bGxcbiAgfVxuXG4gIC8vIGRlZmF1bHQgb3B0c1xuICB2YXIgZGVmYXVsdE9wdHMgPSB7cW9zOiAwLCByZXRhaW46IGZhbHNlLCBkdXA6IGZhbHNlfVxuICBvcHRzID0geHRlbmQoZGVmYXVsdE9wdHMsIG9wdHMpXG5cbiAgaWYgKHRoaXMuX2NoZWNrRGlzY29ubmVjdGluZyhjYWxsYmFjaykpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcGFja2V0ID0ge1xuICAgIGNtZDogJ3B1Ymxpc2gnLFxuICAgIHRvcGljOiB0b3BpYyxcbiAgICBwYXlsb2FkOiBtZXNzYWdlLFxuICAgIHFvczogb3B0cy5xb3MsXG4gICAgcmV0YWluOiBvcHRzLnJldGFpbixcbiAgICBtZXNzYWdlSWQ6IHRoaXMuX25leHRJZCgpLFxuICAgIGR1cDogb3B0cy5kdXBcbiAgfVxuXG4gIGlmIChvcHRpb25zLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gb3B0cy5wcm9wZXJ0aWVzXG4gICAgaWYgKCghb3B0aW9ucy5wcm9wZXJ0aWVzICYmIHBhY2tldC5wcm9wZXJ0aWVzICYmIHBhY2tldC5wcm9wZXJ0aWVzLnRvcGljQWxpYXMpIHx8ICgob3B0cy5wcm9wZXJ0aWVzICYmIG9wdGlvbnMucHJvcGVydGllcykgJiZcbiAgICAgICgob3B0cy5wcm9wZXJ0aWVzLnRvcGljQWxpYXMgJiYgb3B0aW9ucy5wcm9wZXJ0aWVzLnRvcGljQWxpYXNNYXhpbXVtICYmIG9wdHMucHJvcGVydGllcy50b3BpY0FsaWFzID4gb3B0aW9ucy5wcm9wZXJ0aWVzLnRvcGljQWxpYXNNYXhpbXVtKSB8fFxuICAgICAgICAoIW9wdGlvbnMucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bSAmJiBvcHRzLnByb3BlcnRpZXMudG9waWNBbGlhcykpKSkge1xuICAgICAgLypcbiAgICAgIGlmIHdlIGFyZSBkb25gdCBzZXR1cCB0b3BpYyBhbGlhcyBvclxuICAgICAgdG9waWMgYWxpYXMgbWF4aW11bSBsZXNzIHRoYW4gdG9waWMgYWxpYXMgb3JcbiAgICAgIHNlcnZlciBkb25gdCBnaXZlIHRvcGljIGFsaWFzIG1heGltdW0sXG4gICAgICB3ZSBhcmUgcmVtb3ZpbmcgdG9waWMgYWxpYXMgZnJvbSBwYWNrZXRcbiAgICAgICovXG4gICAgICBkZWxldGUgcGFja2V0LnByb3BlcnRpZXMudG9waWNBbGlhc1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAob3B0cy5xb3MpIHtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAyOlxuICAgICAgLy8gQWRkIHRvIGNhbGxiYWNrc1xuICAgICAgdGhpcy5vdXRnb2luZ1twYWNrZXQubWVzc2FnZUlkXSA9IHtcbiAgICAgICAgdm9sYXRpbGU6IGZhbHNlLFxuICAgICAgICBjYjogY2FsbGJhY2sgfHwgbm9wXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc3RvcmVQcm9jZXNzaW5nKSB7XG4gICAgICAgIHRoaXMuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZ1twYWNrZXQubWVzc2FnZUlkXSA9IGZhbHNlXG4gICAgICAgIHRoaXMuX3N0b3JlUGFja2V0KHBhY2tldCwgdW5kZWZpbmVkLCBvcHRzLmNiU3RvcmVQdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZW5kUGFja2V0KHBhY2tldCwgdW5kZWZpbmVkLCBvcHRzLmNiU3RvcmVQdXQpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodGhpcy5fc3RvcmVQcm9jZXNzaW5nKSB7XG4gICAgICAgIHRoaXMuX3N0b3JlUGFja2V0KHBhY2tldCwgY2FsbGJhY2ssIG9wdHMuY2JTdG9yZVB1dClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbmRQYWNrZXQocGFja2V0LCBjYWxsYmFjaywgb3B0cy5jYlN0b3JlUHV0KVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogc3Vic2NyaWJlIC0gc3Vic2NyaWJlIHRvIDx0b3BpYz5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZywgQXJyYXksIE9iamVjdH0gdG9waWMgLSB0b3BpYyhzKSB0byBzdWJzY3JpYmUgdG8sIHN1cHBvcnRzIG9iamVjdHMgaW4gdGhlIGZvcm0geyd0b3BpYyc6IHFvc31cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25hbCBzdWJzY3JpcHRpb24gb3B0aW9ucywgaW5jbHVkZXM6XG4gKiAgICB7TnVtYmVyfSBxb3MgLSBzdWJzY3JpYmUgcW9zIGxldmVsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gZnVuY3Rpb24oZXJyLCBncmFudGVkKXt9IHdoZXJlOlxuICogICAge0Vycm9yfSBlcnIgLSBzdWJzY3JpcHRpb24gZXJyb3IgKG5vbmUgYXQgdGhlIG1vbWVudCEpXG4gKiAgICB7QXJyYXl9IGdyYW50ZWQgLSBhcnJheSBvZiB7dG9waWM6ICd0JywgcW9zOiAwfVxuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKCd0b3BpYycpO1xuICogQGV4YW1wbGUgY2xpZW50LnN1YnNjcmliZSgndG9waWMnLCB7cW9zOiAxfSk7XG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKHsndG9waWMnOiB7cW9zOiAwfSwgJ3RvcGljMic6IHtxb3M6IDF9fSwgY29uc29sZS5sb2cpO1xuICogQGV4YW1wbGUgY2xpZW50LnN1YnNjcmliZSgndG9waWMnLCBjb25zb2xlLmxvZyk7XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldFxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgfVxuICB2YXIgc3VicyA9IFtdXG4gIHZhciBvYmogPSBhcmdzLnNoaWZ0KClcbiAgdmFyIHJlc3Vic2NyaWJlID0gb2JqLnJlc3Vic2NyaWJlXG4gIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCkgfHwgbm9wXG4gIHZhciBvcHRzID0gYXJncy5wb3AoKVxuICB2YXIgaW52YWxpZFRvcGljXG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgdmVyc2lvbiA9IHRoaXMub3B0aW9ucy5wcm90b2NvbFZlcnNpb25cblxuICBkZWxldGUgb2JqLnJlc3Vic2NyaWJlXG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgb2JqID0gW29ial1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0gY2FsbGJhY2tcbiAgICBjYWxsYmFjayA9IG5vcFxuICB9XG5cbiAgaW52YWxpZFRvcGljID0gdmFsaWRhdGlvbnMudmFsaWRhdGVUb3BpY3Mob2JqKVxuICBpZiAoaW52YWxpZFRvcGljICE9PSBudWxsKSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCBuZXcgRXJyb3IoJ0ludmFsaWQgdG9waWMgJyArIGludmFsaWRUb3BpYykpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlmICh0aGlzLl9jaGVja0Rpc2Nvbm5lY3RpbmcoY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBkZWZhdWx0T3B0cyA9IHtcbiAgICBxb3M6IDBcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIGRlZmF1bHRPcHRzLm5sID0gZmFsc2VcbiAgICBkZWZhdWx0T3B0cy5yYXAgPSBmYWxzZVxuICAgIGRlZmF1bHRPcHRzLnJoID0gMFxuICB9XG4gIG9wdHMgPSB4dGVuZChkZWZhdWx0T3B0cywgb3B0cylcblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICBpZiAoIXRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzLmhhc093blByb3BlcnR5KHRvcGljKSB8fFxuICAgICAgICB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1t0b3BpY10ucW9zIDwgb3B0cy5xb3MgfHxcbiAgICAgICAgICByZXN1YnNjcmliZSkge1xuICAgICAgICB2YXIgY3VycmVudE9wdHMgPSB7XG4gICAgICAgICAgdG9waWM6IHRvcGljLFxuICAgICAgICAgIHFvczogb3B0cy5xb3NcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgICAgICAgIGN1cnJlbnRPcHRzLm5sID0gb3B0cy5ubFxuICAgICAgICAgIGN1cnJlbnRPcHRzLnJhcCA9IG9wdHMucmFwXG4gICAgICAgICAgY3VycmVudE9wdHMucmggPSBvcHRzLnJoXG4gICAgICAgICAgY3VycmVudE9wdHMucHJvcGVydGllcyA9IG9wdHMucHJvcGVydGllc1xuICAgICAgICB9XG4gICAgICAgIHN1YnMucHVzaChjdXJyZW50T3B0cylcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIE9iamVjdFxuICAgICAgLmtleXMob2JqKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKCF0aGF0Ll9yZXN1YnNjcmliZVRvcGljcy5oYXNPd25Qcm9wZXJ0eShrKSB8fFxuICAgICAgICAgIHRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzW2tdLnFvcyA8IG9ialtrXS5xb3MgfHxcbiAgICAgICAgICAgIHJlc3Vic2NyaWJlKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRPcHRzID0ge1xuICAgICAgICAgICAgdG9waWM6IGssXG4gICAgICAgICAgICBxb3M6IG9ialtrXS5xb3NcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRPcHRzLm5sID0gb2JqW2tdLm5sXG4gICAgICAgICAgICBjdXJyZW50T3B0cy5yYXAgPSBvYmpba10ucmFwXG4gICAgICAgICAgICBjdXJyZW50T3B0cy5yaCA9IG9ialtrXS5yaFxuICAgICAgICAgICAgY3VycmVudE9wdHMucHJvcGVydGllcyA9IG9wdHMucHJvcGVydGllc1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJzLnB1c2goY3VycmVudE9wdHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBwYWNrZXQgPSB7XG4gICAgY21kOiAnc3Vic2NyaWJlJyxcbiAgICBzdWJzY3JpcHRpb25zOiBzdWJzLFxuICAgIHFvczogMSxcbiAgICByZXRhaW46IGZhbHNlLFxuICAgIGR1cDogZmFsc2UsXG4gICAgbWVzc2FnZUlkOiB0aGlzLl9uZXh0SWQoKVxuICB9XG5cbiAgaWYgKG9wdHMucHJvcGVydGllcykge1xuICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gb3B0cy5wcm9wZXJ0aWVzXG4gIH1cblxuICBpZiAoIXN1YnMubGVuZ3RoKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgW10pXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBzdWJzY3JpcHRpb25zIHRvIHJlc3Vic2NyaWJlIHRvIGluIGNhc2Ugb2YgZGlzY29ubmVjdFxuICBpZiAodGhpcy5vcHRpb25zLnJlc3Vic2NyaWJlKSB7XG4gICAgdmFyIHRvcGljcyA9IFtdXG4gICAgc3Vicy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgIGlmICh0aGF0Lm9wdGlvbnMucmVjb25uZWN0UGVyaW9kID4gMCkge1xuICAgICAgICB2YXIgdG9waWMgPSB7IHFvczogc3ViLnFvcyB9XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgICAgICAgdG9waWMubmwgPSBzdWIubmwgfHwgZmFsc2VcbiAgICAgICAgICB0b3BpYy5yYXAgPSBzdWIucmFwIHx8IGZhbHNlXG4gICAgICAgICAgdG9waWMucmggPSBzdWIucmggfHwgMFxuICAgICAgICAgIHRvcGljLnByb3BlcnRpZXMgPSBzdWIucHJvcGVydGllc1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzW3N1Yi50b3BpY10gPSB0b3BpY1xuICAgICAgICB0b3BpY3MucHVzaChzdWIudG9waWMpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGF0Lm1lc3NhZ2VJZFRvVG9waWNbcGFja2V0Lm1lc3NhZ2VJZF0gPSB0b3BpY3NcbiAgfVxuXG4gIHRoaXMub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPSB7XG4gICAgdm9sYXRpbGU6IHRydWUsXG4gICAgY2I6IGZ1bmN0aW9uIChlcnIsIHBhY2tldCkge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgdmFyIGdyYW50ZWQgPSBwYWNrZXQuZ3JhbnRlZFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYW50ZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBzdWJzW2ldLnFvcyA9IGdyYW50ZWRbaV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhlcnIsIHN1YnMpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fc2VuZFBhY2tldChwYWNrZXQpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiB1bnN1YnNjcmliZSAtIHVuc3Vic2NyaWJlIGZyb20gdG9waWMocylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZywgQXJyYXl9IHRvcGljIC0gdG9waWNzIHRvIHVuc3Vic2NyaWJlIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25hbCBzdWJzY3JpcHRpb24gb3B0aW9ucywgaW5jbHVkZXM6XG4gKiAgICB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gcHJvcGVydGllcyBvZiB1bnN1YnNjcmliZSBwYWNrZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBjYWxsYmFjayBmaXJlZCBvbiB1bnN1YmFja1xuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKiBAZXhhbXBsZSBjbGllbnQudW5zdWJzY3JpYmUoJ3RvcGljJyk7XG4gKiBAZXhhbXBsZSBjbGllbnQudW5zdWJzY3JpYmUoJ3RvcGljJywgY29uc29sZS5sb2cpO1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHtcbiAgICBjbWQ6ICd1bnN1YnNjcmliZScsXG4gICAgcW9zOiAxLFxuICAgIG1lc3NhZ2VJZDogdGhpcy5fbmV4dElkKClcbiAgfVxuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gIH1cbiAgdmFyIHRvcGljID0gYXJncy5zaGlmdCgpXG4gIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCkgfHwgbm9wXG4gIHZhciBvcHRzID0gYXJncy5wb3AoKVxuXG4gIGlmICh0eXBlb2YgdG9waWMgPT09ICdzdHJpbmcnKSB7XG4gICAgdG9waWMgPSBbdG9waWNdXG4gIH1cblxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IGNhbGxiYWNrXG4gICAgY2FsbGJhY2sgPSBub3BcbiAgfVxuXG4gIGlmICh0aGlzLl9jaGVja0Rpc2Nvbm5lY3RpbmcoY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG9waWMgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucyA9IFt0b3BpY11cbiAgfSBlbHNlIGlmICh0eXBlb2YgdG9waWMgPT09ICdvYmplY3QnICYmIHRvcGljLmxlbmd0aCkge1xuICAgIHBhY2tldC51bnN1YnNjcmlwdGlvbnMgPSB0b3BpY1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5yZXN1YnNjcmliZSkge1xuICAgIHBhY2tldC51bnN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgIGRlbGV0ZSB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1t0b3BpY11cbiAgICB9KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JyAmJiBvcHRzLnByb3BlcnRpZXMpIHtcbiAgICBwYWNrZXQucHJvcGVydGllcyA9IG9wdHMucHJvcGVydGllc1xuICB9XG5cbiAgdGhpcy5vdXRnb2luZ1twYWNrZXQubWVzc2FnZUlkXSA9IHtcbiAgICB2b2xhdGlsZTogdHJ1ZSxcbiAgICBjYjogY2FsbGJhY2tcbiAgfVxuXG4gIHRoaXMuX3NlbmRQYWNrZXQocGFja2V0KVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogZW5kIC0gY2xvc2UgY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm5zIHtNcXR0Q2xpZW50fSB0aGlzIC0gZm9yIGNoYWluaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIC0gZG8gbm90IHdhaXQgZm9yIGFsbCBpbi1mbGlnaHQgbWVzc2FnZXMgdG8gYmUgYWNrZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGVkIHdoZW4gdGhlIGNsaWVudCBoYXMgYmVlbiBjbG9zZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIHZhciBmb3JjZSA9IGFyZ3VtZW50c1swXVxuICB2YXIgb3B0cyA9IGFyZ3VtZW50c1sxXVxuICB2YXIgY2IgPSBhcmd1bWVudHNbMl1cblxuICBpZiAoZm9yY2UgPT0gbnVsbCB8fCB0eXBlb2YgZm9yY2UgIT09ICdib29sZWFuJykge1xuICAgIGNiID0gb3B0cyB8fCBub3BcbiAgICBvcHRzID0gZm9yY2VcbiAgICBmb3JjZSA9IGZhbHNlXG4gICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgY2IgPSBvcHRzXG4gICAgICBvcHRzID0gbnVsbFxuICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG5vcFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0gbnVsbFxuICB9XG5cbiAgY2IgPSBjYiB8fCBub3BcblxuICBmdW5jdGlvbiBjbG9zZVN0b3JlcyAoKSB7XG4gICAgdGhhdC5kaXNjb25uZWN0ZWQgPSB0cnVlXG4gICAgdGhhdC5pbmNvbWluZ1N0b3JlLmNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQub3V0Z29pbmdTdG9yZS5jbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgICB0aGF0LmVtaXQoJ2VuZCcpXG4gICAgICB9KVxuICAgIH0pXG4gICAgaWYgKHRoYXQuX2RlZmVycmVkUmVjb25uZWN0KSB7XG4gICAgICB0aGF0Ll9kZWZlcnJlZFJlY29ubmVjdCgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoICgpIHtcbiAgICAvLyBkZWZlciBjbG9zZXNTdG9yZXMgb2YgYW4gSS9PIGN5Y2xlLFxuICAgIC8vIGp1c3QgdG8gbWFrZSBzdXJlIHRoaW5ncyBhcmVcbiAgICAvLyBvayBmb3Igd2Vic29ja2V0c1xuICAgIHRoYXQuX2NsZWFuVXAoZm9yY2UsIHNldEltbWVkaWF0ZS5iaW5kKG51bGwsIGNsb3NlU3RvcmVzKSwgb3B0cylcbiAgfVxuXG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RpbmcpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdGhpcy5fY2xlYXJSZWNvbm5lY3QoKVxuXG4gIHRoaXMuZGlzY29ubmVjdGluZyA9IHRydWVcblxuICBpZiAoIWZvcmNlICYmIE9iamVjdC5rZXlzKHRoaXMub3V0Z29pbmcpLmxlbmd0aCA+IDApIHtcbiAgICAvLyB3YWl0IDEwbXMsIGp1c3QgdG8gYmUgc3VyZSB3ZSByZWNlaXZlZCBhbGwgb2YgaXRcbiAgICB0aGlzLm9uY2UoJ291dGdvaW5nRW1wdHknLCBzZXRUaW1lb3V0LmJpbmQobnVsbCwgZmluaXNoLCAxMCkpXG4gIH0gZWxzZSB7XG4gICAgZmluaXNoKClcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogcmVtb3ZlT3V0Z29pbmdNZXNzYWdlIC0gcmVtb3ZlIGEgbWVzc2FnZSBpbiBvdXRnb2luZyBzdG9yZVxuICogdGhlIG91dGdvaW5nIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGhlIEVycm9yKCdNZXNzYWdlIHJlbW92ZWQnKSBpZiB0aGUgbWVzc2FnZSBpcyByZW1vdmVkXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1pZCAtIG1lc3NhZ2VJZCB0byByZW1vdmUgbWVzc2FnZVxuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKlxuICogQGV4YW1wbGUgY2xpZW50LnJlbW92ZU91dGdvaW5nTWVzc2FnZShjbGllbnQuZ2V0TGFzdE1lc3NhZ2VJZCgpKTtcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUucmVtb3ZlT3V0Z29pbmdNZXNzYWdlID0gZnVuY3Rpb24gKG1pZCkge1xuICB2YXIgY2IgPSB0aGlzLm91dGdvaW5nW21pZF0gPyB0aGlzLm91dGdvaW5nW21pZF0uY2IgOiBudWxsXG4gIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21pZF1cbiAgdGhpcy5vdXRnb2luZ1N0b3JlLmRlbCh7bWVzc2FnZUlkOiBtaWR9LCBmdW5jdGlvbiAoKSB7XG4gICAgY2IobmV3IEVycm9yKCdNZXNzYWdlIHJlbW92ZWQnKSlcbiAgfSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiByZWNvbm5lY3QgLSBjb25uZWN0IGFnYWluIHVzaW5nIHRoZSBzYW1lIG9wdGlvbnMgYXMgY29ubmVjdCgpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbmFsIHJlY29ubmVjdCBvcHRpb25zLCBpbmNsdWRlczpcbiAqICAgIHtTdG9yZX0gaW5jb21pbmdTdG9yZSAtIGEgc3RvcmUgZm9yIHRoZSBpbmNvbWluZyBwYWNrZXRzXG4gKiAgICB7U3RvcmV9IG91dGdvaW5nU3RvcmUgLSBhIHN0b3JlIGZvciB0aGUgb3V0Z29pbmcgcGFja2V0c1xuICogICAgaWYgb3B0cyBpcyBub3QgZ2l2ZW4sIGN1cnJlbnQgc3RvcmVzIGFyZSB1c2VkXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgdGhhdC5vcHRpb25zLmluY29taW5nU3RvcmUgPSBvcHRzLmluY29taW5nU3RvcmVcbiAgICAgIHRoYXQub3B0aW9ucy5vdXRnb2luZ1N0b3JlID0gb3B0cy5vdXRnb2luZ1N0b3JlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQub3B0aW9ucy5pbmNvbWluZ1N0b3JlID0gbnVsbFxuICAgICAgdGhhdC5vcHRpb25zLm91dGdvaW5nU3RvcmUgPSBudWxsXG4gICAgfVxuICAgIHRoYXQuaW5jb21pbmdTdG9yZSA9IHRoYXQub3B0aW9ucy5pbmNvbWluZ1N0b3JlIHx8IG5ldyBTdG9yZSgpXG4gICAgdGhhdC5vdXRnb2luZ1N0b3JlID0gdGhhdC5vcHRpb25zLm91dGdvaW5nU3RvcmUgfHwgbmV3IFN0b3JlKClcbiAgICB0aGF0LmRpc2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHRoYXQuZGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGF0Ll9kZWZlcnJlZFJlY29ubmVjdCA9IG51bGxcbiAgICB0aGF0Ll9yZWNvbm5lY3QoKVxuICB9XG5cbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZyAmJiAhdGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICB0aGlzLl9kZWZlcnJlZFJlY29ubmVjdCA9IGZcbiAgfSBlbHNlIHtcbiAgICBmKClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIF9yZWNvbm5lY3QgLSBpbXBsZW1lbnQgcmVjb25uZWN0aW9uXG4gKiBAYXBpIHByaXZhdGVpc2hcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3JlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdyZWNvbm5lY3QnKVxuICB0aGlzLl9zZXR1cFN0cmVhbSgpXG59XG5cbi8qKlxuICogX3NldHVwUmVjb25uZWN0IC0gc2V0dXAgcmVjb25uZWN0IHRpbWVyXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9zZXR1cFJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgaWYgKCF0aGF0LmRpc2Nvbm5lY3RpbmcgJiYgIXRoYXQucmVjb25uZWN0VGltZXIgJiYgKHRoYXQub3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QgPiAwKSkge1xuICAgIGlmICghdGhpcy5yZWNvbm5lY3RpbmcpIHtcbiAgICAgIHRoaXMuZW1pdCgnb2ZmbGluZScpXG4gICAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWVcbiAgICB9XG4gICAgdGhhdC5yZWNvbm5lY3RUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuX3JlY29ubmVjdCgpXG4gICAgfSwgdGhhdC5vcHRpb25zLnJlY29ubmVjdFBlcmlvZClcbiAgfVxufVxuXG4vKipcbiAqIF9jbGVhclJlY29ubmVjdCAtIGNsZWFyIHRoZSByZWNvbm5lY3QgdGltZXJcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2NsZWFyUmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWNvbm5lY3RUaW1lcilcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbFxuICB9XG59XG5cbi8qKlxuICogX2NsZWFuVXAgLSBjbGVhbiB1cCBvbiBjb25uZWN0aW9uIGVuZFxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9jbGVhblVwID0gZnVuY3Rpb24gKGZvcmNlZCwgZG9uZSkge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50c1syXVxuICBpZiAoZG9uZSkge1xuICAgIHRoaXMuc3RyZWFtLm9uKCdjbG9zZScsIGRvbmUpXG4gIH1cblxuICBpZiAoZm9yY2VkKSB7XG4gICAgaWYgKCh0aGlzLm9wdGlvbnMucmVjb25uZWN0UGVyaW9kID09PSAwKSAmJiB0aGlzLm9wdGlvbnMuY2xlYW4pIHtcbiAgICAgIGZsdXNoKHRoaXMub3V0Z29pbmcpXG4gICAgfVxuICAgIHRoaXMuc3RyZWFtLmRlc3Ryb3koKVxuICB9IGVsc2Uge1xuICAgIHZhciBwYWNrZXQgPSB4dGVuZCh7IGNtZDogJ2Rpc2Nvbm5lY3QnIH0sIG9wdHMpXG4gICAgdGhpcy5fc2VuZFBhY2tldChcbiAgICAgIHBhY2tldCxcbiAgICAgIHNldEltbWVkaWF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICB0aGlzLnN0cmVhbS5lbmQuYmluZCh0aGlzLnN0cmVhbSlcbiAgICAgIClcbiAgICApXG4gIH1cblxuICBpZiAoIXRoaXMuZGlzY29ubmVjdGluZykge1xuICAgIHRoaXMuX2NsZWFyUmVjb25uZWN0KClcbiAgICB0aGlzLl9zZXR1cFJlY29ubmVjdCgpXG4gIH1cblxuICBpZiAodGhpcy5waW5nVGltZXIgIT09IG51bGwpIHtcbiAgICB0aGlzLnBpbmdUaW1lci5jbGVhcigpXG4gICAgdGhpcy5waW5nVGltZXIgPSBudWxsXG4gIH1cblxuICBpZiAoZG9uZSAmJiAhdGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBkb25lKVxuICAgIGRvbmUoKVxuICB9XG59XG5cbi8qKlxuICogX3NlbmRQYWNrZXQgLSBzZW5kIG9yIHF1ZXVlIGEgcGFja2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIHBhY2tldCB0eXBlIChzZWUgYHByb3RvY29sYClcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBwYWNrZXQgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFjayB3aGVuIHRoZSBwYWNrZXQgaXMgc2VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JTdG9yZVB1dCAtIGNhbGxlZCB3aGVuIG1lc3NhZ2UgaXMgcHV0IGludG8gb3V0Z29pbmdTdG9yZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgY2IsIGNiU3RvcmVQdXQpIHtcbiAgY2JTdG9yZVB1dCA9IGNiU3RvcmVQdXQgfHwgbm9wXG5cbiAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMuX3N0b3JlUGFja2V0KHBhY2tldCwgY2IsIGNiU3RvcmVQdXQpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBXaGVuIHNlbmRpbmcgYSBwYWNrZXQsIHJlc2NoZWR1bGUgdGhlIHBpbmcgdGltZXJcbiAgdGhpcy5fc2hpZnRQaW5nSW50ZXJ2YWwoKVxuXG4gIHN3aXRjaCAocGFja2V0LmNtZCkge1xuICAgIGNhc2UgJ3B1Ymxpc2gnOlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwdWJyZWwnOlxuICAgICAgc3RvcmVBbmRTZW5kKHRoaXMsIHBhY2tldCwgY2IsIGNiU3RvcmVQdXQpXG4gICAgICByZXR1cm5cbiAgICBkZWZhdWx0OlxuICAgICAgc2VuZFBhY2tldCh0aGlzLCBwYWNrZXQsIGNiKVxuICAgICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKHBhY2tldC5xb3MpIHtcbiAgICBjYXNlIDI6XG4gICAgY2FzZSAxOlxuICAgICAgc3RvcmVBbmRTZW5kKHRoaXMsIHBhY2tldCwgY2IsIGNiU3RvcmVQdXQpXG4gICAgICBicmVha1xuICAgIC8qKlxuICAgICAqIG5vIG5lZWQgb2YgY2FzZSBoZXJlIHNpbmNlIGl0IHdpbGwgYmUgY2F1Z2h0IGJ5IGRlZmF1bHRcbiAgICAgKiBhbmQganNoaW50IGNvbXBseSB0aGF0IGJlZm9yZSBkZWZhdWx0IGl0IG11c3QgYmUgYSBicmVha1xuICAgICAqIGFueXdheSBpdCB3aWxsIHJlc3VsdCBpbiAtMSBldmFsdWF0aW9uXG4gICAgICovXG4gICAgY2FzZSAwOlxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBzZW5kUGFja2V0KHRoaXMsIHBhY2tldCwgY2IpXG4gICAgICBicmVha1xuICB9XG59XG5cbi8qKlxuICogX3N0b3JlUGFja2V0IC0gcXVldWUgYSBwYWNrZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gcGFja2V0IHR5cGUgKHNlZSBgcHJvdG9jb2xgKVxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHBhY2tldCBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIHdoZW4gdGhlIHBhY2tldCBpcyBzZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlN0b3JlUHV0IC0gY2FsbGVkIHdoZW4gbWVzc2FnZSBpcyBwdXQgaW50byBvdXRnb2luZ1N0b3JlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3N0b3JlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgY2IsIGNiU3RvcmVQdXQpIHtcbiAgY2JTdG9yZVB1dCA9IGNiU3RvcmVQdXQgfHwgbm9wXG5cbiAgaWYgKCgocGFja2V0LnFvcyB8fCAwKSA9PT0gMCAmJiB0aGlzLnF1ZXVlUW9TWmVybykgfHwgcGFja2V0LmNtZCAhPT0gJ3B1Ymxpc2gnKSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKHsgcGFja2V0OiBwYWNrZXQsIGNiOiBjYiB9KVxuICB9IGVsc2UgaWYgKHBhY2tldC5xb3MgPiAwKSB7XG4gICAgY2IgPSB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID8gdGhpcy5vdXRnb2luZ1twYWNrZXQubWVzc2FnZUlkXS5jYiA6IG51bGxcbiAgICB0aGlzLm91dGdvaW5nU3RvcmUucHV0KHBhY2tldCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IgJiYgY2IoZXJyKVxuICAgICAgfVxuICAgICAgY2JTdG9yZVB1dCgpXG4gICAgfSlcbiAgfSBlbHNlIGlmIChjYikge1xuICAgIGNiKG5ldyBFcnJvcignTm8gY29ubmVjdGlvbiB0byBicm9rZXInKSlcbiAgfVxufVxuXG4vKipcbiAqIF9zZXR1cFBpbmdUaW1lciAtIHNldHVwIHRoZSBwaW5nIHRpbWVyXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9zZXR1cFBpbmdUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgaWYgKCF0aGlzLnBpbmdUaW1lciAmJiB0aGlzLm9wdGlvbnMua2VlcGFsaXZlKSB7XG4gICAgdGhpcy5waW5nUmVzcCA9IHRydWVcbiAgICB0aGlzLnBpbmdUaW1lciA9IHJlSW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5fY2hlY2tQaW5nKClcbiAgICB9LCB0aGlzLm9wdGlvbnMua2VlcGFsaXZlICogMTAwMClcbiAgfVxufVxuXG4vKipcbiAqIF9zaGlmdFBpbmdJbnRlcnZhbCAtIHJlc2NoZWR1bGUgdGhlIHBpbmcgaW50ZXJ2YWxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NoaWZ0UGluZ0ludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5waW5nVGltZXIgJiYgdGhpcy5vcHRpb25zLmtlZXBhbGl2ZSAmJiB0aGlzLm9wdGlvbnMucmVzY2hlZHVsZVBpbmdzKSB7XG4gICAgdGhpcy5waW5nVGltZXIucmVzY2hlZHVsZSh0aGlzLm9wdGlvbnMua2VlcGFsaXZlICogMTAwMClcbiAgfVxufVxuLyoqXG4gKiBfY2hlY2tQaW5nIC0gY2hlY2sgaWYgYSBwaW5ncmVzcCBoYXMgY29tZSBiYWNrLCBhbmQgcGluZyB0aGUgc2VydmVyIGFnYWluXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9jaGVja1BpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBpbmdSZXNwKSB7XG4gICAgdGhpcy5waW5nUmVzcCA9IGZhbHNlXG4gICAgdGhpcy5fc2VuZFBhY2tldCh7IGNtZDogJ3BpbmdyZXEnIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gZG8gYSBmb3JjZWQgY2xlYW51cCBzaW5jZSBzb2NrZXQgd2lsbCBiZSBpbiBiYWQgc2hhcGVcbiAgICB0aGlzLl9jbGVhblVwKHRydWUpXG4gIH1cbn1cblxuLyoqXG4gKiBfaGFuZGxlUGluZ3Jlc3AgLSBoYW5kbGUgYSBwaW5ncmVzcFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlUGluZ3Jlc3AgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGluZ1Jlc3AgPSB0cnVlXG59XG5cbi8qKlxuICogX2hhbmRsZUNvbm5hY2tcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlQ29ubmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgdmFyIHZlcnNpb24gPSBvcHRpb25zLnByb3RvY29sVmVyc2lvblxuICB2YXIgcmMgPSB2ZXJzaW9uID09PSA1ID8gcGFja2V0LnJlYXNvbkNvZGUgOiBwYWNrZXQucmV0dXJuQ29kZVxuXG4gIGNsZWFyVGltZW91dCh0aGlzLmNvbm5hY2tUaW1lcilcblxuICBpZiAocGFja2V0LnByb3BlcnRpZXMpIHtcbiAgICBpZiAocGFja2V0LnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW0pIHtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9wZXJ0aWVzKSB7IG9wdGlvbnMucHJvcGVydGllcyA9IHt9IH1cbiAgICAgIG9wdGlvbnMucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bSA9IHBhY2tldC5wcm9wZXJ0aWVzLnRvcGljQWxpYXNNYXhpbXVtXG4gICAgfVxuICAgIGlmIChwYWNrZXQucHJvcGVydGllcy5zZXJ2ZXJLZWVwQWxpdmUgJiYgb3B0aW9ucy5rZWVwYWxpdmUpIHtcbiAgICAgIG9wdGlvbnMua2VlcGFsaXZlID0gcGFja2V0LnByb3BlcnRpZXMuc2VydmVyS2VlcEFsaXZlXG4gICAgICB0aGlzLl9zaGlmdFBpbmdJbnRlcnZhbCgpXG4gICAgfVxuICAgIGlmIChwYWNrZXQucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSkge1xuICAgICAgaWYgKCFvcHRpb25zLnByb3BlcnRpZXMpIHsgb3B0aW9ucy5wcm9wZXJ0aWVzID0ge30gfVxuICAgICAgb3B0aW9ucy5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplID0gcGFja2V0LnByb3BlcnRpZXMubWF4aW11bVBhY2tldFNpemVcbiAgICB9XG4gIH1cblxuICBpZiAocmMgPT09IDApIHtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhpcy5fb25Db25uZWN0KHBhY2tldClcbiAgfSBlbHNlIGlmIChyYyA+IDApIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIHJlZnVzZWQ6ICcgKyBlcnJvcnNbcmNdKVxuICAgIGVyci5jb2RlID0gcmNcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG59XG5cbi8qKlxuICogX2hhbmRsZVB1Ymxpc2hcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuLypcbnRob3NlIGxhdGUgMiBjYXNlIHNob3VsZCBiZSByZXdyaXRlIHRvIGNvbXBseSB3aXRoIGNvZGluZyBzdHlsZTpcblxuY2FzZSAxOlxuY2FzZSAwOlxuICAvLyBkbyBub3Qgd2FpdCBzZW5kaW5nIGEgcHViYWNrXG4gIC8vIG5vIGNhbGxiYWNrIHBhc3NlZFxuICBpZiAoMSA9PT0gcW9zKSB7XG4gICAgdGhpcy5fc2VuZFBhY2tldCh7XG4gICAgICBjbWQ6ICdwdWJhY2snLFxuICAgICAgbWVzc2FnZUlkOiBtaWRcbiAgICB9KTtcbiAgfVxuICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50IGZvciBib3RoIHFvcyAxIGFuZCAwXG4gIHRoaXMuZW1pdCgnbWVzc2FnZScsIHRvcGljLCBtZXNzYWdlLCBwYWNrZXQpO1xuICB0aGlzLmhhbmRsZU1lc3NhZ2UocGFja2V0LCBkb25lKTtcbiAgYnJlYWs7XG5kZWZhdWx0OlxuICAvLyBkbyBub3RoaW5nIGJ1dCBldmVyeSBzd2l0Y2ggbXVzIGhhdmUgYSBkZWZhdWx0XG4gIC8vIGxvZyBvciB0aHJvdyBhbiBlcnJvciBhYm91dCB1bmtub3duIHFvc1xuICBicmVhaztcblxuZm9yIG5vdyBpIGp1c3Qgc3VwcHJlc3NlZCB0aGUgd2FybmluZ3NcbiovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlUHVibGlzaCA9IGZ1bmN0aW9uIChwYWNrZXQsIGRvbmUpIHtcbiAgZG9uZSA9IHR5cGVvZiBkb25lICE9PSAndW5kZWZpbmVkJyA/IGRvbmUgOiBub3BcbiAgdmFyIHRvcGljID0gcGFja2V0LnRvcGljLnRvU3RyaW5nKClcbiAgdmFyIG1lc3NhZ2UgPSBwYWNrZXQucGF5bG9hZFxuICB2YXIgcW9zID0gcGFja2V0LnFvc1xuICB2YXIgbWlkID0gcGFja2V0Lm1lc3NhZ2VJZFxuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgdmFyIHZhbGlkUmVhc29uQ29kZXMgPSBbMCwgMTYsIDEyOCwgMTMxLCAxMzUsIDE0NCwgMTQ1LCAxNTEsIDE1M11cblxuICBzd2l0Y2ggKHFvcykge1xuICAgIGNhc2UgMjoge1xuICAgICAgb3B0aW9ucy5jdXN0b21IYW5kbGVBY2tzKHRvcGljLCBtZXNzYWdlLCBwYWNrZXQsIGZ1bmN0aW9uIChlcnJvciwgY29kZSkge1xuICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIGNvZGUgPSBlcnJvclxuICAgICAgICAgIGVycm9yID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcikgeyByZXR1cm4gdGhhdC5lbWl0KCdlcnJvcicsIGVycm9yKSB9XG4gICAgICAgIGlmICh2YWxpZFJlYXNvbkNvZGVzLmluZGV4T2YoY29kZSkgPT09IC0xKSB7IHJldHVybiB0aGF0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdXcm9uZyByZWFzb24gY29kZSBmb3IgcHVicmVjJykpIH1cbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICB0aGF0Ll9zZW5kUGFja2V0KHtjbWQ6ICdwdWJyZWMnLCBtZXNzYWdlSWQ6IG1pZCwgcmVhc29uQ29kZTogY29kZX0sIGRvbmUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhhdC5pbmNvbWluZ1N0b3JlLnB1dChwYWNrZXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoe2NtZDogJ3B1YnJlYycsIG1lc3NhZ2VJZDogbWlkfSwgZG9uZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50XG4gICAgICBvcHRpb25zLmN1c3RvbUhhbmRsZUFja3ModG9waWMsIG1lc3NhZ2UsIHBhY2tldCwgZnVuY3Rpb24gKGVycm9yLCBjb2RlKSB7XG4gICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgY29kZSA9IGVycm9yXG4gICAgICAgICAgZXJyb3IgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yKSB7IHJldHVybiB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyb3IpIH1cbiAgICAgICAgaWYgKHZhbGlkUmVhc29uQ29kZXMuaW5kZXhPZihjb2RlKSA9PT0gLTEpIHsgcmV0dXJuIHRoYXQuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1dyb25nIHJlYXNvbiBjb2RlIGZvciBwdWJhY2snKSkgfVxuICAgICAgICBpZiAoIWNvZGUpIHsgdGhhdC5lbWl0KCdtZXNzYWdlJywgdG9waWMsIG1lc3NhZ2UsIHBhY2tldCkgfVxuICAgICAgICB0aGF0LmhhbmRsZU1lc3NhZ2UocGFja2V0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUgJiYgZG9uZShlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoe2NtZDogJ3B1YmFjaycsIG1lc3NhZ2VJZDogbWlkLCByZWFzb25Db2RlOiBjb2RlfSwgZG9uZSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIDA6XG4gICAgICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB0b3BpYywgbWVzc2FnZSwgcGFja2V0KVxuICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKHBhY2tldCwgZG9uZSlcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIC8vIGxvZyBvciB0aHJvdyBhbiBlcnJvciBhYm91dCB1bmtub3duIHFvc1xuICAgICAgYnJlYWtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBtZXNzYWdlcyB3aXRoIGJhY2twcmVzc3VyZSBzdXBwb3J0LCBvbmUgYXQgYSB0aW1lLlxuICogT3ZlcnJpZGUgYXQgd2lsbC5cbiAqXG4gKiBAcGFyYW0gUGFja2V0IHBhY2tldCB0aGUgcGFja2V0XG4gKiBAcGFyYW0gRnVuY3Rpb24gY2FsbGJhY2sgY2FsbCB3aGVuIGZpbmlzaGVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKVxufVxuXG4vKipcbiAqIF9oYW5kbGVBY2tcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlQWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFwib2ZmXCIgKi9cbiAgdmFyIG1pZCA9IHBhY2tldC5tZXNzYWdlSWRcbiAgdmFyIHR5cGUgPSBwYWNrZXQuY21kXG4gIHZhciByZXNwb25zZSA9IG51bGxcbiAgdmFyIGNiID0gdGhpcy5vdXRnb2luZ1ttaWRdID8gdGhpcy5vdXRnb2luZ1ttaWRdLmNiIDogbnVsbFxuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIGVyclxuXG4gIGlmICghY2IpIHtcbiAgICAvLyBTZXJ2ZXIgc2VudCBhbiBhY2sgaW4gZXJyb3IsIGlnbm9yZSBpdC5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFByb2Nlc3NcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncHViY29tcCc6XG4gICAgICAvLyBzYW1lIHRoaW5nIGFzIHB1YmFjayBmb3IgUW9TIDJcbiAgICBjYXNlICdwdWJhY2snOlxuICAgICAgdmFyIHB1YmFja1JDID0gcGFja2V0LnJlYXNvbkNvZGVcbiAgICAgIC8vIENhbGxiYWNrIC0gd2UncmUgZG9uZVxuICAgICAgaWYgKHB1YmFja1JDICYmIHB1YmFja1JDID4gMCAmJiBwdWJhY2tSQyAhPT0gMTYpIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKCdQdWJsaXNoIGVycm9yOiAnICsgZXJyb3JzW3B1YmFja1JDXSlcbiAgICAgICAgZXJyLmNvZGUgPSBwdWJhY2tSQ1xuICAgICAgICBjYihlcnIsIHBhY2tldClcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21pZF1cbiAgICAgIHRoaXMub3V0Z29pbmdTdG9yZS5kZWwocGFja2V0LCBjYilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHVicmVjJzpcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICBjbWQ6ICdwdWJyZWwnLFxuICAgICAgICBxb3M6IDIsXG4gICAgICAgIG1lc3NhZ2VJZDogbWlkXG4gICAgICB9XG4gICAgICB2YXIgcHVicmVjUkMgPSBwYWNrZXQucmVhc29uQ29kZVxuXG4gICAgICBpZiAocHVicmVjUkMgJiYgcHVicmVjUkMgPiAwICYmIHB1YnJlY1JDICE9PSAxNikge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ1B1Ymxpc2ggZXJyb3I6ICcgKyBlcnJvcnNbcHVicmVjUkNdKVxuICAgICAgICBlcnIuY29kZSA9IHB1YnJlY1JDXG4gICAgICAgIGNiKGVyciwgcGFja2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VuZFBhY2tldChyZXNwb25zZSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnc3ViYWNrJzpcbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21pZF1cbiAgICAgIGZvciAodmFyIGdyYW50ZWRJID0gMDsgZ3JhbnRlZEkgPCBwYWNrZXQuZ3JhbnRlZC5sZW5ndGg7IGdyYW50ZWRJKyspIHtcbiAgICAgICAgaWYgKChwYWNrZXQuZ3JhbnRlZFtncmFudGVkSV0gJiAweDgwKSAhPT0gMCkge1xuICAgICAgICAgIC8vIHN1YmFjayB3aXRoIEZhaWx1cmUgc3RhdHVzXG4gICAgICAgICAgdmFyIHRvcGljcyA9IHRoaXMubWVzc2FnZUlkVG9Ub3BpY1ttaWRdXG4gICAgICAgICAgaWYgKHRvcGljcykge1xuICAgICAgICAgICAgdG9waWNzLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1t0b3BpY11cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYihudWxsLCBwYWNrZXQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3Vuc3ViYWNrJzpcbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21pZF1cbiAgICAgIGNiKG51bGwpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgcGFja2V0IHR5cGUnKSlcbiAgfVxuXG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RpbmcgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3V0Z29pbmcpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuZW1pdCgnb3V0Z29pbmdFbXB0eScpXG4gIH1cbn1cblxuLyoqXG4gKiBfaGFuZGxlUHVicmVsXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVQdWJyZWwgPSBmdW5jdGlvbiAocGFja2V0LCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IHR5cGVvZiBjYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IG5vcFxuICB2YXIgbWlkID0gcGFja2V0Lm1lc3NhZ2VJZFxuICB2YXIgdGhhdCA9IHRoaXNcblxuICB2YXIgY29tcCA9IHtjbWQ6ICdwdWJjb21wJywgbWVzc2FnZUlkOiBtaWR9XG5cbiAgdGhhdC5pbmNvbWluZ1N0b3JlLmdldChwYWNrZXQsIGZ1bmN0aW9uIChlcnIsIHB1Yikge1xuICAgIGlmICghZXJyKSB7XG4gICAgICB0aGF0LmVtaXQoJ21lc3NhZ2UnLCBwdWIudG9waWMsIHB1Yi5wYXlsb2FkLCBwdWIpXG4gICAgICB0aGF0LmhhbmRsZU1lc3NhZ2UocHViLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRoYXQuaW5jb21pbmdTdG9yZS5kZWwocHViLCBub3ApXG4gICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoY29tcCwgY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9zZW5kUGFja2V0KGNvbXAsIGNhbGxiYWNrKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBfaGFuZGxlRGlzY29ubmVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlRGlzY29ubmVjdCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcGFja2V0KVxufVxuXG4vKipcbiAqIF9uZXh0SWRcbiAqIEByZXR1cm4gdW5zaWduZWQgaW50XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9uZXh0SWQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGlkIGJlY29tZXMgY3VycmVudCBzdGF0ZSBvZiB0aGlzLm5leHRJZCBhbmQgaW5jcmVtZW50cyBhZnRlcndhcmRzXG4gIHZhciBpZCA9IHRoaXMubmV4dElkKytcbiAgLy8gRW5zdXJlIDE2IGJpdCB1bnNpZ25lZCBpbnQgKG1heCA2NTUzNSwgbmV4dElkIGdvdCBvbmUgaGlnaGVyKVxuICBpZiAodGhpcy5uZXh0SWQgPT09IDY1NTM2KSB7XG4gICAgdGhpcy5uZXh0SWQgPSAxXG4gIH1cbiAgcmV0dXJuIGlkXG59XG5cbi8qKlxuICogZ2V0TGFzdE1lc3NhZ2VJZFxuICogQHJldHVybiB1bnNpZ25lZCBpbnRcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuZ2V0TGFzdE1lc3NhZ2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLm5leHRJZCA9PT0gMSkgPyA2NTUzNSA6ICh0aGlzLm5leHRJZCAtIDEpXG59XG5cbi8qKlxuICogX3Jlc3Vic2NyaWJlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3Jlc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNvbm5hY2spIHtcbiAgdmFyIF9yZXN1YnNjcmliZVRvcGljc0tleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9yZXN1YnNjcmliZVRvcGljcylcbiAgaWYgKCF0aGlzLl9maXJzdENvbm5lY3Rpb24gJiZcbiAgICAgICh0aGlzLm9wdGlvbnMuY2xlYW4gfHwgKHRoaXMub3B0aW9ucy5wcm90b2NvbFZlcnNpb24gPT09IDUgJiYgIWNvbm5hY2suc2Vzc2lvblByZXNlbnQpKSAmJlxuICAgICAgX3Jlc3Vic2NyaWJlVG9waWNzS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXN1YnNjcmliZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICAgICAgZm9yICh2YXIgdG9waWNJID0gMDsgdG9waWNJIDwgX3Jlc3Vic2NyaWJlVG9waWNzS2V5cy5sZW5ndGg7IHRvcGljSSsrKSB7XG4gICAgICAgICAgdmFyIHJlc3Vic2NyaWJlVG9waWMgPSB7fVxuICAgICAgICAgIHJlc3Vic2NyaWJlVG9waWNbX3Jlc3Vic2NyaWJlVG9waWNzS2V5c1t0b3BpY0ldXSA9IHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzW19yZXN1YnNjcmliZVRvcGljc0tleXNbdG9waWNJXV1cbiAgICAgICAgICByZXN1YnNjcmliZVRvcGljLnJlc3Vic2NyaWJlID0gdHJ1ZVxuICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKHJlc3Vic2NyaWJlVG9waWMsIHtwcm9wZXJ0aWVzOiByZXN1YnNjcmliZVRvcGljW19yZXN1YnNjcmliZVRvcGljc0tleXNbdG9waWNJXV0ucHJvcGVydGllc30pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzLnJlc3Vic2NyaWJlID0gdHJ1ZVxuICAgICAgICB0aGlzLnN1YnNjcmliZSh0aGlzLl9yZXN1YnNjcmliZVRvcGljcylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MgPSB7fVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2ZpcnN0Q29ubmVjdGlvbiA9IGZhbHNlXG59XG5cbi8qKlxuICogX29uQ29ubmVjdFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fb25Db25uZWN0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBwYWNrZXQpXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgdGhhdCA9IHRoaXNcblxuICB0aGlzLl9zZXR1cFBpbmdUaW1lcigpXG4gIHRoaXMuX3Jlc3Vic2NyaWJlKHBhY2tldClcblxuICB0aGlzLmNvbm5lY3RlZCA9IHRydWVcblxuICBmdW5jdGlvbiBzdGFydFN0cmVhbVByb2Nlc3MgKCkge1xuICAgIHZhciBvdXRTdG9yZSA9IHRoYXQub3V0Z29pbmdTdG9yZS5jcmVhdGVTdHJlYW0oKVxuXG4gICAgZnVuY3Rpb24gY2xlYXJTdG9yZVByb2Nlc3NpbmcgKCkge1xuICAgICAgdGhhdC5fc3RvcmVQcm9jZXNzaW5nID0gZmFsc2VcbiAgICAgIHRoYXQuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZyA9IHt9XG4gICAgfVxuXG4gICAgdGhhdC5vbmNlKCdjbG9zZScsIHJlbW92ZSlcbiAgICBvdXRTdG9yZS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBjbGVhclN0b3JlUHJvY2Vzc2luZygpXG4gICAgICB0aGF0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHJlbW92ZSlcbiAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgICBvdXRTdG9yZS5kZXN0cm95KClcbiAgICAgIG91dFN0b3JlID0gbnVsbFxuICAgICAgY2xlYXJTdG9yZVByb2Nlc3NpbmcoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3JlRGVsaXZlciAoKSB7XG4gICAgICAvLyBlZGdlIGNhc2UsIHdlIHdyYXBwZWQgdGhpcyB0d2ljZVxuICAgICAgaWYgKCFvdXRTdG9yZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoYXQuX3N0b3JlUHJvY2Vzc2luZyA9IHRydWVcblxuICAgICAgdmFyIHBhY2tldCA9IG91dFN0b3JlLnJlYWQoMSlcblxuICAgICAgdmFyIGNiXG5cbiAgICAgIGlmICghcGFja2V0KSB7XG4gICAgICAgIC8vIHJlYWQgd2hlbiBkYXRhIGlzIGF2YWlsYWJsZSBpbiB0aGUgZnV0dXJlXG4gICAgICAgIG91dFN0b3JlLm9uY2UoJ3JlYWRhYmxlJywgc3RvcmVEZWxpdmVyKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBhbHJlYWR5IHByb2Nlc3NlZCBzdG9yZSBwYWNrZXRzXG4gICAgICBpZiAodGhhdC5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nW3BhY2tldC5tZXNzYWdlSWRdKSB7XG4gICAgICAgIHN0b3JlRGVsaXZlcigpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBzdHJlYW0gcmVhZCBvcGVyYXRpb25zIHdoZW4gZGlzY29ubmVjdGVkXG4gICAgICBpZiAoIXRoYXQuZGlzY29ubmVjdGluZyAmJiAhdGhhdC5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgICBjYiA9IHRoYXQub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPyB0aGF0Lm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdLmNiIDogbnVsbFxuICAgICAgICB0aGF0Lm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0ge1xuICAgICAgICAgIHZvbGF0aWxlOiBmYWxzZSxcbiAgICAgICAgICBjYjogZnVuY3Rpb24gKGVyciwgc3RhdHVzKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgcGFzc2VkIGluIHRvIHB1Ymxpc2ggZ2V0cyBpbnZva2VkXG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgY2IoZXJyLCBzdGF0dXMpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0b3JlRGVsaXZlcigpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoYXQuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZ1twYWNrZXQubWVzc2FnZUlkXSA9IHRydWVcbiAgICAgICAgdGhhdC5fc2VuZFBhY2tldChwYWNrZXQpXG4gICAgICB9IGVsc2UgaWYgKG91dFN0b3JlLmRlc3Ryb3kpIHtcbiAgICAgICAgb3V0U3RvcmUuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0U3RvcmUub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhbGxQcm9jZXNzZWQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGF0Ll9wYWNrZXRJZHNEdXJpbmdTdG9yZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgaWYgKCF0aGF0Ll9wYWNrZXRJZHNEdXJpbmdTdG9yZVByb2Nlc3NpbmdbaWRdKSB7XG4gICAgICAgICAgYWxsUHJvY2Vzc2VkID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWxsUHJvY2Vzc2VkKSB7XG4gICAgICAgIGNsZWFyU3RvcmVQcm9jZXNzaW5nKClcbiAgICAgICAgdGhhdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCByZW1vdmUpXG4gICAgICAgIHRoYXQuZW1pdCgnY29ubmVjdCcsIHBhY2tldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0U3RyZWFtUHJvY2VzcygpXG4gICAgICB9XG4gICAgfSlcbiAgICBzdG9yZURlbGl2ZXIoKVxuICB9XG4gIC8vIHN0YXJ0IGZsb3dpbmdcbiAgc3RhcnRTdHJlYW1Qcm9jZXNzKClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNcXR0Q2xpZW50XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vc3RvcmVcIjo3LFwiLi92YWxpZGF0aW9uc1wiOjgsXCJfcHJvY2Vzc1wiOjkyLFwiZXZlbnRzXCI6MTMsXCJpbmhlcml0c1wiOjgwLFwibXF0dC1wYWNrZXRcIjo4NCxcInJlYWRhYmxlLXN0cmVhbVwiOjEwOCxcInJlaW50ZXJ2YWxcIjoxMDksXCJ4dGVuZFwiOjEyMX1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBkdXBsZXhpZnkgPSByZXF1aXJlKCdkdXBsZXhpZnknKVxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5cbi8qIGdsb2JhbCBGaWxlUmVhZGVyICovXG52YXIgbXlcbnZhciBwcm94eVxudmFyIHN0cmVhbVxudmFyIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZVxuXG5mdW5jdGlvbiBidWlsZFByb3h5ICgpIHtcbiAgdmFyIHByb3h5ID0gbmV3IFRyYW5zZm9ybSgpXG4gIHByb3h5Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIG5leHQpIHtcbiAgICBteS5zZW5kU29ja2V0TWVzc2FnZSh7XG4gICAgICBkYXRhOiBjaHVuay5idWZmZXIsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHQoKVxuICAgICAgfSxcbiAgICAgIGZhaWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV4dChuZXcgRXJyb3IoKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHByb3h5Ll9mbHVzaCA9IGZ1bmN0aW9uIHNvY2tldEVuZCAoZG9uZSkge1xuICAgIG15LmNsb3NlU29ja2V0KHtcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9uZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBwcm94eVxufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0T3B0cyAob3B0cykge1xuICBpZiAoIW9wdHMuaG9zdG5hbWUpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gJ2xvY2FsaG9zdCdcbiAgfVxuICBpZiAoIW9wdHMucGF0aCkge1xuICAgIG9wdHMucGF0aCA9ICcvJ1xuICB9XG5cbiAgaWYgKCFvcHRzLndzT3B0aW9ucykge1xuICAgIG9wdHMud3NPcHRpb25zID0ge31cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFVybCAob3B0cywgY2xpZW50KSB7XG4gIHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgPT09ICdhbGlzJyA/ICd3c3MnIDogJ3dzJ1xuICB2YXIgdXJsID0gcHJvdG9jb2wgKyAnOi8vJyArIG9wdHMuaG9zdG5hbWUgKyBvcHRzLnBhdGhcbiAgaWYgKG9wdHMucG9ydCAmJiBvcHRzLnBvcnQgIT09IDgwICYmIG9wdHMucG9ydCAhPT0gNDQzKSB7XG4gICAgdXJsID0gcHJvdG9jb2wgKyAnOi8vJyArIG9wdHMuaG9zdG5hbWUgKyAnOicgKyBvcHRzLnBvcnQgKyBvcHRzLnBhdGhcbiAgfVxuICBpZiAodHlwZW9mIChvcHRzLnRyYW5zZm9ybVdzVXJsKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVybCA9IG9wdHMudHJhbnNmb3JtV3NVcmwodXJsLCBvcHRzLCBjbGllbnQpXG4gIH1cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBiaW5kRXZlbnRIYW5kbGVyICgpIHtcbiAgaWYgKGlzSW5pdGlhbGl6ZWQpIHJldHVyblxuXG4gIGlzSW5pdGlhbGl6ZWQgPSB0cnVlXG5cbiAgbXkub25Tb2NrZXRPcGVuKGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0uc2V0UmVhZGFibGUocHJveHkpXG4gICAgc3RyZWFtLnNldFdyaXRhYmxlKHByb3h5KVxuICAgIHN0cmVhbS5lbWl0KCdjb25uZWN0JylcbiAgfSlcblxuICBteS5vblNvY2tldE1lc3NhZ2UoZnVuY3Rpb24gKHJlcykge1xuICAgIGlmICh0eXBlb2YgcmVzLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgYXJyYXkgPSBiYXNlNjQudG9CeXRlQXJyYXkocmVzLmRhdGEpXG4gICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oYXJyYXkpXG4gICAgICBwcm94eS5wdXNoKGJ1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHJlYWRlci5yZXN1bHRcblxuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICAgICAgZWxzZSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKVxuICAgICAgICBwcm94eS5wdXNoKGRhdGEpXG4gICAgICB9KVxuICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHJlcy5kYXRhKVxuICAgIH1cbiAgfSlcblxuICBteS5vblNvY2tldENsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0uZW5kKClcbiAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH0pXG5cbiAgbXkub25Tb2NrZXRFcnJvcihmdW5jdGlvbiAocmVzKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3kocmVzKVxuICB9KVxufVxuXG5mdW5jdGlvbiBidWlsZFN0cmVhbSAoY2xpZW50LCBvcHRzKSB7XG4gIG9wdHMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdFxuXG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBob3N0LiBTcGVjaWZ5IGhvc3QgbWFudWFsbHkuJylcbiAgfVxuXG4gIHZhciB3ZWJzb2NrZXRTdWJQcm90b2NvbCA9XG4gICAgKG9wdHMucHJvdG9jb2xJZCA9PT0gJ01RSXNkcCcpICYmIChvcHRzLnByb3RvY29sVmVyc2lvbiA9PT0gMylcbiAgICAgID8gJ21xdHR2My4xJ1xuICAgICAgOiAnbXF0dCdcblxuICBzZXREZWZhdWx0T3B0cyhvcHRzKVxuXG4gIHZhciB1cmwgPSBidWlsZFVybChvcHRzLCBjbGllbnQpXG4gIG15ID0gb3B0cy5teVxuICBteS5jb25uZWN0U29ja2V0KHtcbiAgICB1cmw6IHVybCxcbiAgICBwcm90b2NvbHM6IHdlYnNvY2tldFN1YlByb3RvY29sXG4gIH0pXG5cbiAgcHJveHkgPSBidWlsZFByb3h5KClcbiAgc3RyZWFtID0gZHVwbGV4aWZ5Lm9iaigpXG5cbiAgYmluZEV2ZW50SGFuZGxlcigpXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkU3RyZWFtXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbn0se1wiYmFzZTY0LWpzXCI6MTAsXCJidWZmZXJcIjoxMixcImR1cGxleGlmeVwiOjE3LFwicmVhZGFibGUtc3RyZWFtXCI6MTA4fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcbnZhciBuZXQgPSByZXF1aXJlKCduZXQnKVxuXG4vKlxuICB2YXJpYWJsZXMgcG9ydCBhbmQgaG9zdCBjYW4gYmUgcmVtb3ZlZCBzaW5jZVxuICB5b3UgaGF2ZSBhbGwgcmVxdWlyZWQgaW5mb3JtYXRpb24gaW4gb3B0cyBvYmplY3RcbiovXG5mdW5jdGlvbiBidWlsZEJ1aWxkZXIgKGNsaWVudCwgb3B0cykge1xuICB2YXIgcG9ydCwgaG9zdFxuICBvcHRzLnBvcnQgPSBvcHRzLnBvcnQgfHwgMTg4M1xuICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3QgfHwgJ2xvY2FsaG9zdCdcblxuICBwb3J0ID0gb3B0cy5wb3J0XG4gIGhvc3QgPSBvcHRzLmhvc3RuYW1lXG5cbiAgcmV0dXJuIG5ldC5jcmVhdGVDb25uZWN0aW9uKHBvcnQsIGhvc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRCdWlsZGVyXG5cbn0se1wibmV0XCI6MTF9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xudmFyIHRscyA9IHJlcXVpcmUoJ3RscycpXG5cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRlciAobXF0dENsaWVudCwgb3B0cykge1xuICB2YXIgY29ubmVjdGlvblxuICBvcHRzLnBvcnQgPSBvcHRzLnBvcnQgfHwgODg4M1xuICBvcHRzLmhvc3QgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdCB8fCAnbG9jYWxob3N0J1xuXG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgIT09IGZhbHNlXG5cbiAgZGVsZXRlIG9wdHMucGF0aFxuXG4gIGNvbm5lY3Rpb24gPSB0bHMuY29ubmVjdChvcHRzKVxuICAvKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IFsyLCBcIm5vZnVuY1wiXSAqL1xuICBjb25uZWN0aW9uLm9uKCdzZWN1cmVDb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRzLnJlamVjdFVuYXV0aG9yaXplZCAmJiAhY29ubmVjdGlvbi5hdXRob3JpemVkKSB7XG4gICAgICBjb25uZWN0aW9uLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdUTFMgbm90IGF1dGhvcml6ZWQnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVUTFNlcnJvcnMpXG4gICAgfVxuICB9KVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRMU2Vycm9ycyAoZXJyKSB7XG4gICAgLy8gSG93IGNhbiBJIGdldCB2ZXJpZnkgdGhpcyBlcnJvciBpcyBhIHRscyBlcnJvcj9cbiAgICBpZiAob3B0cy5yZWplY3RVbmF1dGhvcml6ZWQpIHtcbiAgICAgIG1xdHRDbGllbnQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuXG4gICAgLy8gY2xvc2UgdGhpcyBjb25uZWN0aW9uIHRvIG1hdGNoIHRoZSBiZWhhdmlvdXIgb2YgbmV0XG4gICAgLy8gb3RoZXJ3aXNlIGFsbCB3ZSBnZXQgaXMgYW4gZXJyb3IgZnJvbSB0aGUgY29ubmVjdGlvblxuICAgIC8vIGFuZCBjbG9zZSBldmVudCBkb2Vzbid0IGZpcmUuIFRoaXMgaXMgYSB3b3JrIGFyb3VuZFxuICAgIC8vIHRvIGVuYWJsZSB0aGUgcmVjb25uZWN0IGNvZGUgdG8gd29yayB0aGUgc2FtZSBhcyB3aXRoXG4gICAgLy8gbmV0LmNyZWF0ZUNvbm5lY3Rpb25cbiAgICBjb25uZWN0aW9uLmVuZCgpXG4gIH1cblxuICBjb25uZWN0aW9uLm9uKCdlcnJvcicsIGhhbmRsZVRMU2Vycm9ycylcbiAgcmV0dXJuIGNvbm5lY3Rpb25cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZEJ1aWxkZXJcblxufSx7XCJ0bHNcIjoxMX1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnd2Vic29ja2V0LXN0cmVhbScpXG52YXIgdXJsTW9kdWxlID0gcmVxdWlyZSgndXJsJylcbnZhciBXU1NfT1BUSU9OUyA9IFtcbiAgJ3JlamVjdFVuYXV0aG9yaXplZCcsXG4gICdjYScsXG4gICdjZXJ0JyxcbiAgJ2tleScsXG4gICdwZngnLFxuICAncGFzc3BocmFzZSdcbl1cbnZhciBJU19CUk9XU0VSID0gcHJvY2Vzcy50aXRsZSA9PT0gJ2Jyb3dzZXInXG5cbmZ1bmN0aW9uIGJ1aWxkVXJsIChvcHRzLCBjbGllbnQpIHtcbiAgdmFyIHVybCA9IG9wdHMucHJvdG9jb2wgKyAnOi8vJyArIG9wdHMuaG9zdG5hbWUgKyAnOicgKyBvcHRzLnBvcnQgKyBvcHRzLnBhdGhcbiAgaWYgKHR5cGVvZiAob3B0cy50cmFuc2Zvcm1Xc1VybCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cmwgPSBvcHRzLnRyYW5zZm9ybVdzVXJsKHVybCwgb3B0cywgY2xpZW50KVxuICB9XG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdE9wdHMgKG9wdHMpIHtcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9ICdsb2NhbGhvc3QnXG4gIH1cbiAgaWYgKCFvcHRzLnBvcnQpIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbCA9PT0gJ3dzcycpIHtcbiAgICAgIG9wdHMucG9ydCA9IDQ0M1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLnBvcnQgPSA4MFxuICAgIH1cbiAgfVxuICBpZiAoIW9wdHMucGF0aCkge1xuICAgIG9wdHMucGF0aCA9ICcvJ1xuICB9XG5cbiAgaWYgKCFvcHRzLndzT3B0aW9ucykge1xuICAgIG9wdHMud3NPcHRpb25zID0ge31cbiAgfVxuICBpZiAoIUlTX0JST1dTRVIgJiYgb3B0cy5wcm90b2NvbCA9PT0gJ3dzcycpIHtcbiAgICAvLyBBZGQgY2VydC9rZXkvY2EgZXRjIG9wdGlvbnNcbiAgICBXU1NfT1BUSU9OUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiAhb3B0cy53c09wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgb3B0cy53c09wdGlvbnNbcHJvcF0gPSBvcHRzW3Byb3BdXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXQgKGNsaWVudCwgb3B0cykge1xuICB2YXIgd2Vic29ja2V0U3ViUHJvdG9jb2wgPVxuICAgIChvcHRzLnByb3RvY29sSWQgPT09ICdNUUlzZHAnKSAmJiAob3B0cy5wcm90b2NvbFZlcnNpb24gPT09IDMpXG4gICAgICA/ICdtcXR0djMuMSdcbiAgICAgIDogJ21xdHQnXG5cbiAgc2V0RGVmYXVsdE9wdHMob3B0cylcbiAgdmFyIHVybCA9IGJ1aWxkVXJsKG9wdHMsIGNsaWVudClcbiAgcmV0dXJuIHdlYnNvY2tldCh1cmwsIFt3ZWJzb2NrZXRTdWJQcm90b2NvbF0sIG9wdHMud3NPcHRpb25zKVxufVxuXG5mdW5jdGlvbiBidWlsZEJ1aWxkZXIgKGNsaWVudCwgb3B0cykge1xuICByZXR1cm4gY3JlYXRlV2ViU29ja2V0KGNsaWVudCwgb3B0cylcbn1cblxuZnVuY3Rpb24gYnVpbGRCdWlsZGVyQnJvd3NlciAoY2xpZW50LCBvcHRzKSB7XG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBvcHRzLmhvc3RcbiAgfVxuXG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIC8vIFRocm93aW5nIGFuIGVycm9yIGluIGEgV2ViIFdvcmtlciBpZiBubyBgaG9zdG5hbWVgIGlzIGdpdmVuLCBiZWNhdXNlIHdlXG4gICAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGBob3N0bmFtZWAgYXV0b21hdGljYWxseS4gIElmIGNvbm5lY3RpbmcgdG9cbiAgICAvLyBsb2NhbGhvc3QsIHBsZWFzZSBzdXBwbHkgdGhlIGBob3N0bmFtZWAgYXMgYW4gYXJndW1lbnQuXG4gICAgaWYgKHR5cGVvZiAoZG9jdW1lbnQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGhvc3QuIFNwZWNpZnkgaG9zdCBtYW51YWxseS4nKVxuICAgIH1cbiAgICB2YXIgcGFyc2VkID0gdXJsTW9kdWxlLnBhcnNlKGRvY3VtZW50LlVSTClcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2VkLmhvc3RuYW1lXG5cbiAgICBpZiAoIW9wdHMucG9ydCkge1xuICAgICAgb3B0cy5wb3J0ID0gcGFyc2VkLnBvcnRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVdlYlNvY2tldChjbGllbnQsIG9wdHMpXG59XG5cbmlmIChJU19CUk9XU0VSKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVpbGRCdWlsZGVyQnJvd3NlclxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWlsZEJ1aWxkZXJcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIl9wcm9jZXNzXCI6OTIsXCJ1cmxcIjoxMTMsXCJ3ZWJzb2NrZXQtc3RyZWFtXCI6MTE4fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsQnVmZmVyKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5JylcblxuLyogZ2xvYmFsIHd4ICovXG52YXIgc29ja2V0VGFza1xudmFyIHByb3h5XG52YXIgc3RyZWFtXG5cbmZ1bmN0aW9uIGJ1aWxkUHJveHkgKCkge1xuICB2YXIgcHJveHkgPSBuZXcgVHJhbnNmb3JtKClcbiAgcHJveHkuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgbmV4dCkge1xuICAgIHNvY2tldFRhc2suc2VuZCh7XG4gICAgICBkYXRhOiBjaHVuay5idWZmZXIsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHQoKVxuICAgICAgfSxcbiAgICAgIGZhaWw6IGZ1bmN0aW9uIChlcnJNc2cpIHtcbiAgICAgICAgbmV4dChuZXcgRXJyb3IoZXJyTXNnKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHByb3h5Ll9mbHVzaCA9IGZ1bmN0aW9uIHNvY2tldEVuZCAoZG9uZSkge1xuICAgIHNvY2tldFRhc2suY2xvc2Uoe1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHByb3h5XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRPcHRzIChvcHRzKSB7XG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSAnbG9jYWxob3N0J1xuICB9XG4gIGlmICghb3B0cy5wYXRoKSB7XG4gICAgb3B0cy5wYXRoID0gJy8nXG4gIH1cblxuICBpZiAoIW9wdHMud3NPcHRpb25zKSB7XG4gICAgb3B0cy53c09wdGlvbnMgPSB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVXJsIChvcHRzLCBjbGllbnQpIHtcbiAgdmFyIHByb3RvY29sID0gb3B0cy5wcm90b2NvbCA9PT0gJ3d4cycgPyAnd3NzJyA6ICd3cydcbiAgdmFyIHVybCA9IHByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgb3B0cy5wYXRoXG4gIGlmIChvcHRzLnBvcnQgJiYgb3B0cy5wb3J0ICE9PSA4MCAmJiBvcHRzLnBvcnQgIT09IDQ0Mykge1xuICAgIHVybCA9IHByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgJzonICsgb3B0cy5wb3J0ICsgb3B0cy5wYXRoXG4gIH1cbiAgaWYgKHR5cGVvZiAob3B0cy50cmFuc2Zvcm1Xc1VybCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cmwgPSBvcHRzLnRyYW5zZm9ybVdzVXJsKHVybCwgb3B0cywgY2xpZW50KVxuICB9XG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gYmluZEV2ZW50SGFuZGxlciAoKSB7XG4gIHNvY2tldFRhc2sub25PcGVuKGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0uc2V0UmVhZGFibGUocHJveHkpXG4gICAgc3RyZWFtLnNldFdyaXRhYmxlKHByb3h5KVxuICAgIHN0cmVhbS5lbWl0KCdjb25uZWN0JylcbiAgfSlcblxuICBzb2NrZXRUYXNrLm9uTWVzc2FnZShmdW5jdGlvbiAocmVzKSB7XG4gICAgdmFyIGRhdGEgPSByZXMuZGF0YVxuXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgZWxzZSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKVxuICAgIHByb3h5LnB1c2goZGF0YSlcbiAgfSlcblxuICBzb2NrZXRUYXNrLm9uQ2xvc2UoZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5lbmQoKVxuICAgIHN0cmVhbS5kZXN0cm95KClcbiAgfSlcblxuICBzb2NrZXRUYXNrLm9uRXJyb3IoZnVuY3Rpb24gKHJlcykge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcihyZXMuZXJyTXNnKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gYnVpbGRTdHJlYW0gKGNsaWVudCwgb3B0cykge1xuICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3RcblxuICBpZiAoIW9wdHMuaG9zdG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgaG9zdC4gU3BlY2lmeSBob3N0IG1hbnVhbGx5LicpXG4gIH1cblxuICB2YXIgd2Vic29ja2V0U3ViUHJvdG9jb2wgPVxuICAgIChvcHRzLnByb3RvY29sSWQgPT09ICdNUUlzZHAnKSAmJiAob3B0cy5wcm90b2NvbFZlcnNpb24gPT09IDMpXG4gICAgICA/ICdtcXR0djMuMSdcbiAgICAgIDogJ21xdHQnXG5cbiAgc2V0RGVmYXVsdE9wdHMob3B0cylcblxuICB2YXIgdXJsID0gYnVpbGRVcmwob3B0cywgY2xpZW50KVxuICBzb2NrZXRUYXNrID0gd3guY29ubmVjdFNvY2tldCh7XG4gICAgdXJsOiB1cmwsXG4gICAgcHJvdG9jb2xzOiB3ZWJzb2NrZXRTdWJQcm90b2NvbFxuICB9KVxuXG4gIHByb3h5ID0gYnVpbGRQcm94eSgpXG4gIHN0cmVhbSA9IGR1cGxleGlmeS5vYmooKVxuICBzdHJlYW0uX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICAgIHNvY2tldFRhc2suY2xvc2Uoe1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICBjYiAmJiBjYihlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHZhciBkZXN0cm95UmVmID0gc3RyZWFtLmRlc3Ryb3lcbiAgc3RyZWFtLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3kgPSBkZXN0cm95UmVmXG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNvY2tldFRhc2suY2xvc2Uoe1xuICAgICAgICBmYWlsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fZGVzdHJveShuZXcgRXJyb3IoKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9LmJpbmQoc3RyZWFtKVxuXG4gIGJpbmRFdmVudEhhbmRsZXIoKVxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZFN0cmVhbVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbn0se1wiX3Byb2Nlc3NcIjo5MixcImJ1ZmZlclwiOjEyLFwiZHVwbGV4aWZ5XCI6MTcsXCJyZWFkYWJsZS1zdHJlYW1cIjoxMDh9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGVcbnZhciBzdHJlYW1zT3B0cyA9IHsgb2JqZWN0TW9kZTogdHJ1ZSB9XG52YXIgZGVmYXVsdFN0b3JlT3B0aW9ucyA9IHtcbiAgY2xlYW46IHRydWVcbn1cblxuLyoqXG4gKiBlczYtbWFwIGNhbiBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXIgZXZlbiBpZiBFUyB2ZXJzaW9uIGlzIG9sZGVyLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcCNEZXNjcmlwdGlvblxuICogSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgYSBNYXAgd2hpY2ggaXMgYSBtYXAgb2YgYW4gb2JqZWN0LCBlc3BlY2lhbGx5XG4gKiBhIGRpY3Rpb25hcnkgb2YgZGljdGlvbmFyaWVzLCB3aWxsIG9ubHkgbWFwIHRvIHRoZSBvYmplY3QncyBpbnNlcnRpb25cbiAqIG9yZGVyLiBJbiBFUzIwMTUgdGhpcyBpcyBvcmRlcmVkIGZvciBvYmplY3RzIGJ1dCBmb3Igb2xkZXIgdmVyc2lvbnMgb2ZcbiAqIEVTLCB0aGlzIG1heSBiZSByYW5kb20gYW5kIG5vdCBvcmRlcmVkLlxuICpcbiAqL1xudmFyIE1hcCA9IHJlcXVpcmUoJ2VzNi1tYXAnKVxuXG4vKipcbiAqIEluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbWVzc2FnZSBzdG9yZVxuICogVGhpcyBjYW4gYWN0dWFsbHkgYmUgc2F2ZWQgaW50byBmaWxlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gc3RvcmUgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBTdG9yZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RvcmUpKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yZShvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIC8vIERlZmF1bHRzXG4gIHRoaXMub3B0aW9ucyA9IHh0ZW5kKGRlZmF1bHRTdG9yZU9wdGlvbnMsIG9wdGlvbnMpXG5cbiAgdGhpcy5faW5mbGlnaHRzID0gbmV3IE1hcCgpXG59XG5cbi8qKlxuICogQWRkcyBhIHBhY2tldCB0byB0aGUgc3RvcmUsIGEgcGFja2V0IGlzXG4gKiBhbnl0aGluZyB0aGF0IGhhcyBhIG1lc3NhZ2VJZCBwcm9wZXJ0eS5cbiAqXG4gKi9cblN0b3JlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICB0aGlzLl9pbmZsaWdodHMuc2V0KHBhY2tldC5tZXNzYWdlSWQsIHBhY2tldClcblxuICBpZiAoY2IpIHtcbiAgICBjYigpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJlYW0gd2l0aCBhbGwgdGhlIHBhY2tldHMgaW4gdGhlIHN0b3JlXG4gKlxuICovXG5TdG9yZS5wcm90b3R5cGUuY3JlYXRlU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyZWFtID0gbmV3IFJlYWRhYmxlKHN0cmVhbXNPcHRzKVxuICB2YXIgZGVzdHJveWVkID0gZmFsc2VcbiAgdmFyIHZhbHVlcyA9IFtdXG4gIHZhciBpID0gMFxuXG4gIHRoaXMuX2luZmxpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpXG4gIH0pXG5cbiAgc3RyZWFtLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGVzdHJveWVkICYmIGkgPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnB1c2godmFsdWVzW2krK10pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaChudWxsKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG4vKipcbiAqIGRlbGV0ZXMgYSBwYWNrZXQgZnJvbSB0aGUgc3RvcmUuXG4gKi9cblN0b3JlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICBwYWNrZXQgPSB0aGlzLl9pbmZsaWdodHMuZ2V0KHBhY2tldC5tZXNzYWdlSWQpXG4gIGlmIChwYWNrZXQpIHtcbiAgICB0aGlzLl9pbmZsaWdodHMuZGVsZXRlKHBhY2tldC5tZXNzYWdlSWQpXG4gICAgY2IobnVsbCwgcGFja2V0KVxuICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgY2IobmV3IEVycm9yKCdtaXNzaW5nIHBhY2tldCcpKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBnZXQgYSBwYWNrZXQgZnJvbSB0aGUgc3RvcmUuXG4gKi9cblN0b3JlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICBwYWNrZXQgPSB0aGlzLl9pbmZsaWdodHMuZ2V0KHBhY2tldC5tZXNzYWdlSWQpXG4gIGlmIChwYWNrZXQpIHtcbiAgICBjYihudWxsLCBwYWNrZXQpXG4gIH0gZWxzZSBpZiAoY2IpIHtcbiAgICBjYihuZXcgRXJyb3IoJ21pc3NpbmcgcGFja2V0JykpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBzdG9yZVxuICovXG5TdG9yZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5jbGVhbikge1xuICAgIHRoaXMuX2luZmxpZ2h0cyA9IG51bGxcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBjYigpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdG9yZVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiX3Byb2Nlc3NcIjo5MixcImVzNi1tYXBcIjo2NyxcInJlYWRhYmxlLXN0cmVhbVwiOjEwOCxcInh0ZW5kXCI6MTIxfV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBWYWxpZGF0ZSBhIHRvcGljIHRvIHNlZSBpZiBpdCdzIHZhbGlkIG9yIG5vdC5cbiAqIEEgdG9waWMgaXMgdmFsaWQgaWYgaXQgZm9sbG93IGJlbG93IHJ1bGVzOlxuICogLSBSdWxlICMxOiBJZiBhbnkgcGFydCBvZiB0aGUgdG9waWMgaXMgbm90IGArYCBvciBgI2AsIHRoZW4gaXQgbXVzdCBub3QgY29udGFpbiBgK2AgYW5kICcjJ1xuICogLSBSdWxlICMyOiBQYXJ0IGAjYCBtdXN0IGJlIGxvY2F0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgbWFpbGJveFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyAtIEEgdG9waWNcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgdG9waWMgaXMgdmFsaWQsIHJldHVybnMgdHJ1ZS4gT3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRvcGljICh0b3BpYykge1xuICB2YXIgcGFydHMgPSB0b3BpYy5zcGxpdCgnLycpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJ0c1tpXSA9PT0gJysnKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChwYXJ0c1tpXSA9PT0gJyMnKSB7XG4gICAgICAvLyBmb3IgUnVsZSAjMlxuICAgICAgcmV0dXJuIGkgPT09IHBhcnRzLmxlbmd0aCAtIDFcbiAgICB9XG5cbiAgICBpZiAocGFydHNbaV0uaW5kZXhPZignKycpICE9PSAtMSB8fCBwYXJ0c1tpXS5pbmRleE9mKCcjJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuIGFycmF5IG9mIHRvcGljcyB0byBzZWUgaWYgYW55IG9mIHRoZW0gaXMgdmFsaWQgb3Igbm90XG4gICogQHBhcmFtIHtBcnJheX0gdG9waWNzIC0gQXJyYXkgb2YgdG9waWNzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBJZiB0aGUgdG9waWNzIGlzIHZhbGlkLCByZXR1cm5zIG51bGwuIE90aGVyd2lzZSwgcmV0dXJucyB0aGUgaW52YWxpZCBvbmVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUb3BpY3MgKHRvcGljcykge1xuICBpZiAodG9waWNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnZW1wdHlfdG9waWNfbGlzdCdcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRvcGljcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghdmFsaWRhdGVUb3BpYyh0b3BpY3NbaV0pKSB7XG4gICAgICByZXR1cm4gdG9waWNzW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWxpZGF0ZVRvcGljczogdmFsaWRhdGVUb3BpY3Ncbn1cblxufSx7fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBNcXR0Q2xpZW50ID0gcmVxdWlyZSgnLi4vY2xpZW50JylcbnZhciBTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3JlJylcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHByb3RvY29scyA9IHt9XG5cbmlmIChwcm9jZXNzLnRpdGxlICE9PSAnYnJvd3NlcicpIHtcbiAgcHJvdG9jb2xzLm1xdHQgPSByZXF1aXJlKCcuL3RjcCcpXG4gIHByb3RvY29scy50Y3AgPSByZXF1aXJlKCcuL3RjcCcpXG4gIHByb3RvY29scy5zc2wgPSByZXF1aXJlKCcuL3RscycpXG4gIHByb3RvY29scy50bHMgPSByZXF1aXJlKCcuL3RscycpXG4gIHByb3RvY29scy5tcXR0cyA9IHJlcXVpcmUoJy4vdGxzJylcbn0gZWxzZSB7XG4gIHByb3RvY29scy53eCA9IHJlcXVpcmUoJy4vd3gnKVxuICBwcm90b2NvbHMud3hzID0gcmVxdWlyZSgnLi93eCcpXG5cbiAgcHJvdG9jb2xzLmFsaSA9IHJlcXVpcmUoJy4vYWxpJylcbiAgcHJvdG9jb2xzLmFsaXMgPSByZXF1aXJlKCcuL2FsaScpXG59XG5cbnByb3RvY29scy53cyA9IHJlcXVpcmUoJy4vd3MnKVxucHJvdG9jb2xzLndzcyA9IHJlcXVpcmUoJy4vd3MnKVxuXG4vKipcbiAqIFBhcnNlIHRoZSBhdXRoIGF0dHJpYnV0ZSBhbmQgbWVyZ2UgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGluIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIG9wdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gcGFyc2VBdXRoT3B0aW9ucyAob3B0cykge1xuICB2YXIgbWF0Y2hlc1xuICBpZiAob3B0cy5hdXRoKSB7XG4gICAgbWF0Y2hlcyA9IG9wdHMuYXV0aC5tYXRjaCgvXiguKyk6KC4rKSQvKVxuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICBvcHRzLnVzZXJuYW1lID0gbWF0Y2hlc1sxXVxuICAgICAgb3B0cy5wYXNzd29yZCA9IG1hdGNoZXNbMl1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy51c2VybmFtZSA9IG9wdHMuYXV0aFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGNvbm5lY3QgLSBjb25uZWN0IHRvIGFuIE1RVFQgYnJva2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbYnJva2VyVXJsXSAtIHVybCBvZiB0aGUgYnJva2VyLCBvcHRpb25hbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBzZWUgTXF0dENsaWVudCNjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBjb25uZWN0IChicm9rZXJVcmwsIG9wdHMpIHtcbiAgaWYgKCh0eXBlb2YgYnJva2VyVXJsID09PSAnb2JqZWN0JykgJiYgIW9wdHMpIHtcbiAgICBvcHRzID0gYnJva2VyVXJsXG4gICAgYnJva2VyVXJsID0gbnVsbFxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBpZiAoYnJva2VyVXJsKSB7XG4gICAgdmFyIHBhcnNlZCA9IHVybC5wYXJzZShicm9rZXJVcmwsIHRydWUpXG4gICAgaWYgKHBhcnNlZC5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gTnVtYmVyKHBhcnNlZC5wb3J0KVxuICAgIH1cblxuICAgIG9wdHMgPSB4dGVuZChwYXJzZWQsIG9wdHMpXG5cbiAgICBpZiAob3B0cy5wcm90b2NvbCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByb3RvY29sJylcbiAgICB9XG4gICAgb3B0cy5wcm90b2NvbCA9IG9wdHMucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJylcbiAgfVxuXG4gIC8vIG1lcmdlIGluIHRoZSBhdXRoIG9wdGlvbnMgaWYgc3VwcGxpZWRcbiAgcGFyc2VBdXRoT3B0aW9ucyhvcHRzKVxuXG4gIC8vIHN1cHBvcnQgY2xpZW50SWQgcGFzc2VkIGluIHRoZSBxdWVyeSBzdHJpbmcgb2YgdGhlIHVybFxuICBpZiAob3B0cy5xdWVyeSAmJiB0eXBlb2Ygb3B0cy5xdWVyeS5jbGllbnRJZCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRzLmNsaWVudElkID0gb3B0cy5xdWVyeS5jbGllbnRJZFxuICB9XG5cbiAgaWYgKG9wdHMuY2VydCAmJiBvcHRzLmtleSkge1xuICAgIGlmIChvcHRzLnByb3RvY29sKSB7XG4gICAgICBpZiAoWydtcXR0cycsICd3c3MnLCAnd3hzJywgJ2FsaXMnXS5pbmRleE9mKG9wdHMucHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgICBzd2l0Y2ggKG9wdHMucHJvdG9jb2wpIHtcbiAgICAgICAgICBjYXNlICdtcXR0JzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnbXF0dHMnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3dzJzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnd3NzJ1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICd3eCc6XG4gICAgICAgICAgICBvcHRzLnByb3RvY29sID0gJ3d4cydcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnYWxpJzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnYWxpcydcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcm90b2NvbCBmb3Igc2VjdXJlIGNvbm5lY3Rpb246IFwiJyArIG9wdHMucHJvdG9jb2wgKyAnXCIhJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb24ndCBrbm93IHdoYXQgcHJvdG9jb2wgaGUgd2FudCB0byB1c2UsIG1xdHRzIG9yIHdzc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNlY3VyZSBwcm90b2NvbCBrZXknKVxuICAgIH1cbiAgfVxuXG4gIGlmICghcHJvdG9jb2xzW29wdHMucHJvdG9jb2xdKSB7XG4gICAgdmFyIGlzU2VjdXJlID0gWydtcXR0cycsICd3c3MnXS5pbmRleE9mKG9wdHMucHJvdG9jb2wpICE9PSAtMVxuICAgIG9wdHMucHJvdG9jb2wgPSBbXG4gICAgICAnbXF0dCcsXG4gICAgICAnbXF0dHMnLFxuICAgICAgJ3dzJyxcbiAgICAgICd3c3MnLFxuICAgICAgJ3d4JyxcbiAgICAgICd3eHMnLFxuICAgICAgJ2FsaScsXG4gICAgICAnYWxpcydcbiAgICBdLmZpbHRlcihmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgaWYgKGlzU2VjdXJlICYmIGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBTa2lwIGluc2VjdXJlIHByb3RvY29scyB3aGVuIHJlcXVlc3RpbmcgYSBzZWN1cmUgb25lLlxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiAodHlwZW9mIHByb3RvY29sc1trZXldID09PSAnZnVuY3Rpb24nKVxuICAgIH0pWzBdXG4gIH1cblxuICBpZiAob3B0cy5jbGVhbiA9PT0gZmFsc2UgJiYgIW9wdHMuY2xpZW50SWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2xpZW50SWQgZm9yIHVuY2xlYW4gY2xpZW50cycpXG4gIH1cblxuICBpZiAob3B0cy5wcm90b2NvbCkge1xuICAgIG9wdHMuZGVmYXVsdFByb3RvY29sID0gb3B0cy5wcm90b2NvbFxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlciAoY2xpZW50KSB7XG4gICAgaWYgKG9wdHMuc2VydmVycykge1xuICAgICAgaWYgKCFjbGllbnQuX3JlY29ubmVjdENvdW50IHx8IGNsaWVudC5fcmVjb25uZWN0Q291bnQgPT09IG9wdHMuc2VydmVycy5sZW5ndGgpIHtcbiAgICAgICAgY2xpZW50Ll9yZWNvbm5lY3RDb3VudCA9IDBcbiAgICAgIH1cblxuICAgICAgb3B0cy5ob3N0ID0gb3B0cy5zZXJ2ZXJzW2NsaWVudC5fcmVjb25uZWN0Q291bnRdLmhvc3RcbiAgICAgIG9wdHMucG9ydCA9IG9wdHMuc2VydmVyc1tjbGllbnQuX3JlY29ubmVjdENvdW50XS5wb3J0XG4gICAgICBvcHRzLnByb3RvY29sID0gKCFvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0ucHJvdG9jb2wgPyBvcHRzLmRlZmF1bHRQcm90b2NvbCA6IG9wdHMuc2VydmVyc1tjbGllbnQuX3JlY29ubmVjdENvdW50XS5wcm90b2NvbClcbiAgICAgIG9wdHMuaG9zdG5hbWUgPSBvcHRzLmhvc3RcblxuICAgICAgY2xpZW50Ll9yZWNvbm5lY3RDb3VudCsrXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3RvY29sc1tvcHRzLnByb3RvY29sXShjbGllbnQsIG9wdHMpXG4gIH1cblxuICByZXR1cm4gbmV3IE1xdHRDbGllbnQod3JhcHBlciwgb3B0cylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0XG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdFxubW9kdWxlLmV4cG9ydHMuTXF0dENsaWVudCA9IE1xdHRDbGllbnRcbm1vZHVsZS5leHBvcnRzLlN0b3JlID0gU3RvcmVcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIi4uL2NsaWVudFwiOjEsXCIuLi9zdG9yZVwiOjcsXCIuL2FsaVwiOjIsXCIuL3RjcFwiOjMsXCIuL3Rsc1wiOjQsXCIuL3dzXCI6NSxcIi4vd3hcIjo2LFwiX3Byb2Nlc3NcIjo5MixcInVybFwiOjExMyxcInh0ZW5kXCI6MTIxfV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbn0se31dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxufSx7fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxufSx7XCJiYXNlNjQtanNcIjoxMCxcImllZWU3NTRcIjo3OX1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxufSx7fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChCdWZmZXIpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG59KS5jYWxsKHRoaXMse1wiaXNCdWZmZXJcIjpyZXF1aXJlKFwiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzXCIpfSlcbn0se1wiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzXCI6ODF9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb3B5ICAgICAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvY29weScpXG4gICwgbm9ybWFsaXplT3B0aW9ucyA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zJylcbiAgLCBlbnN1cmVDYWxsYWJsZSAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIG1hcCAgICAgICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9tYXAnKVxuICAsIGNhbGxhYmxlICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsaWRWYWx1ZSAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlJylcblxuICAsIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZWZpbmU7XG5cbmRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXNjLCBvcHRpb25zKSB7XG5cdHZhciB2YWx1ZSA9IHZhbGlkVmFsdWUoZGVzYykgJiYgY2FsbGFibGUoZGVzYy52YWx1ZSksIGRncztcblx0ZGdzID0gY29weShkZXNjKTtcblx0ZGVsZXRlIGRncy53cml0YWJsZTtcblx0ZGVsZXRlIGRncy52YWx1ZTtcblx0ZGdzLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIW9wdGlvbnMub3ZlcndyaXRlRGVmaW5pdGlvbiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUpKSByZXR1cm4gdmFsdWU7XG5cdFx0ZGVzYy52YWx1ZSA9IGJpbmQuY2FsbCh2YWx1ZSwgb3B0aW9ucy5yZXNvbHZlQ29udGV4dCA/IG9wdGlvbnMucmVzb2x2ZUNvbnRleHQodGhpcykgOiB0aGlzKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCBkZXNjKTtcblx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0fTtcblx0cmV0dXJuIGRncztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb3BzLyosIG9wdGlvbnMqLykge1xuXHR2YXIgb3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMoYXJndW1lbnRzWzFdKTtcblx0aWYgKG9wdGlvbnMucmVzb2x2ZUNvbnRleHQgIT0gbnVsbCkgZW5zdXJlQ2FsbGFibGUob3B0aW9ucy5yZXNvbHZlQ29udGV4dCk7XG5cdHJldHVybiBtYXAocHJvcHMsIGZ1bmN0aW9uIChkZXNjLCBuYW1lKSB7IHJldHVybiBkZWZpbmUobmFtZSwgZGVzYywgb3B0aW9ucyk7IH0pO1xufTtcblxufSx7XCJlczUtZXh0L29iamVjdC9jb3B5XCI6MzksXCJlczUtZXh0L29iamVjdC9tYXBcIjo0OCxcImVzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zXCI6NDksXCJlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZVwiOjU0LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWVcIjo1NX1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9hc3NpZ24nKVxuICAsIG5vcm1hbGl6ZU9wdHMgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9ucycpXG4gICwgaXNDYWxsYWJsZSAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlJylcbiAgLCBjb250YWlucyAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucycpXG5cbiAgLCBkO1xuXG5kID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZHNjciwgdmFsdWUvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCB3LCBvcHRpb25zLCBkZXNjO1xuXHRpZiAoKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB8fCAodHlwZW9mIGRzY3IgIT09ICdzdHJpbmcnKSkge1xuXHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHR2YWx1ZSA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcblx0fVxuXHRpZiAoZHNjciA9PSBudWxsKSB7XG5cdFx0YyA9IHcgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdFx0dyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgJ3cnKTtcblx0fVxuXG5cdGRlc2MgPSB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlLCB3cml0YWJsZTogdyB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxuZC5ncyA9IGZ1bmN0aW9uIChkc2NyLCBnZXQsIHNldC8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIG9wdGlvbnMsIGRlc2M7XG5cdGlmICh0eXBlb2YgZHNjciAhPT0gJ3N0cmluZycpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IGdldDtcblx0XHRnZXQgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbM107XG5cdH1cblx0aWYgKGdldCA9PSBudWxsKSB7XG5cdFx0Z2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKGdldCkpIHtcblx0XHRvcHRpb25zID0gZ2V0O1xuXHRcdGdldCA9IHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChzZXQgPT0gbnVsbCkge1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNDYWxsYWJsZShzZXQpKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKGRzY3IgPT0gbnVsbCkge1xuXHRcdGMgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCAnYycpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsICdlJyk7XG5cdH1cblxuXHRkZXNjID0geyBnZXQ6IGdldCwgc2V0OiBzZXQsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufTtcblxufSx7XCJlczUtZXh0L29iamVjdC9hc3NpZ25cIjozNixcImVzNS1leHQvb2JqZWN0L2lzLWNhbGxhYmxlXCI6NDIsXCJlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9uc1wiOjQ5LFwiZXM1LWV4dC9zdHJpbmcvIy9jb250YWluc1wiOjU2fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLEJ1ZmZlcil7XG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciBlb3MgPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzaGlmdCA9IHJlcXVpcmUoJ3N0cmVhbS1zaGlmdCcpXG5cbnZhciBTSUdOQUxfRkxVU0ggPSAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSlcbiAgPyBCdWZmZXIuZnJvbShbMF0pXG4gIDogbmV3IEJ1ZmZlcihbMF0pXG5cbnZhciBvbnVuY29yayA9IGZ1bmN0aW9uKHNlbGYsIGZuKSB7XG4gIGlmIChzZWxmLl9jb3JrZWQpIHNlbGYub25jZSgndW5jb3JrJywgZm4pXG4gIGVsc2UgZm4oKVxufVxuXG52YXIgYXV0b0Rlc3Ryb3kgPSBmdW5jdGlvbiAoc2VsZiwgZXJyKSB7XG4gIGlmIChzZWxmLl9hdXRvRGVzdHJveSkgc2VsZi5kZXN0cm95KGVycilcbn1cblxudmFyIGRlc3Ryb3llciA9IGZ1bmN0aW9uKHNlbGYsIGVuZCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVycikgYXV0b0Rlc3Ryb3koc2VsZiwgZXJyLm1lc3NhZ2UgPT09ICdwcmVtYXR1cmUgY2xvc2UnID8gbnVsbCA6IGVycilcbiAgICBlbHNlIGlmIChlbmQgJiYgIXNlbGYuX2VuZGVkKSBzZWxmLmVuZCgpXG4gIH1cbn1cblxudmFyIGVuZCA9IGZ1bmN0aW9uKHdzLCBmbikge1xuICBpZiAoIXdzKSByZXR1cm4gZm4oKVxuICBpZiAod3MuX3dyaXRhYmxlU3RhdGUgJiYgd3MuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHJldHVybiBmbigpXG4gIGlmICh3cy5fd3JpdGFibGVTdGF0ZSkgcmV0dXJuIHdzLmVuZChmbilcbiAgd3MuZW5kKClcbiAgZm4oKVxufVxuXG52YXIgdG9TdHJlYW1zMiA9IGZ1bmN0aW9uKHJzKSB7XG4gIHJldHVybiBuZXcgKHN0cmVhbS5SZWFkYWJsZSkoe29iamVjdE1vZGU6dHJ1ZSwgaGlnaFdhdGVyTWFyazoxNn0pLndyYXAocnMpXG59XG5cbnZhciBEdXBsZXhpZnkgPSBmdW5jdGlvbih3cml0YWJsZSwgcmVhZGFibGUsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleGlmeSkpIHJldHVybiBuZXcgRHVwbGV4aWZ5KHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cylcbiAgc3RyZWFtLkR1cGxleC5jYWxsKHRoaXMsIG9wdHMpXG5cbiAgdGhpcy5fd3JpdGFibGUgPSBudWxsXG4gIHRoaXMuX3JlYWRhYmxlID0gbnVsbFxuICB0aGlzLl9yZWFkYWJsZTIgPSBudWxsXG5cbiAgdGhpcy5fYXV0b0Rlc3Ryb3kgPSAhb3B0cyB8fCBvcHRzLmF1dG9EZXN0cm95ICE9PSBmYWxzZVxuICB0aGlzLl9mb3J3YXJkRGVzdHJveSA9ICFvcHRzIHx8IG9wdHMuZGVzdHJveSAhPT0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZEVuZCA9ICFvcHRzIHx8IG9wdHMuZW5kICE9PSBmYWxzZVxuICB0aGlzLl9jb3JrZWQgPSAxIC8vIHN0YXJ0IGNvcmtlZFxuICB0aGlzLl9vbmRyYWluID0gbnVsbFxuICB0aGlzLl9kcmFpbmVkID0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG4gIHRoaXMuX3Vud3JpdGUgPSBudWxsXG4gIHRoaXMuX3VucmVhZCA9IG51bGxcbiAgdGhpcy5fZW5kZWQgPSBmYWxzZVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICBpZiAod3JpdGFibGUpIHRoaXMuc2V0V3JpdGFibGUod3JpdGFibGUpXG4gIGlmIChyZWFkYWJsZSkgdGhpcy5zZXRSZWFkYWJsZShyZWFkYWJsZSlcbn1cblxuaW5oZXJpdHMoRHVwbGV4aWZ5LCBzdHJlYW0uRHVwbGV4KVxuXG5EdXBsZXhpZnkub2JqID0gZnVuY3Rpb24od3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIG9wdHMub2JqZWN0TW9kZSA9IHRydWVcbiAgb3B0cy5oaWdoV2F0ZXJNYXJrID0gMTZcbiAgcmV0dXJuIG5ldyBEdXBsZXhpZnkod3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCsrdGhpcy5fY29ya2VkID09PSAxKSB0aGlzLmVtaXQoJ2NvcmsnKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fY29ya2VkICYmIC0tdGhpcy5fY29ya2VkID09PSAwKSB0aGlzLmVtaXQoJ3VuY29yaycpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuc2V0V3JpdGFibGUgPSBmdW5jdGlvbih3cml0YWJsZSkge1xuICBpZiAodGhpcy5fdW53cml0ZSkgdGhpcy5fdW53cml0ZSgpXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgaWYgKHdyaXRhYmxlICYmIHdyaXRhYmxlLmRlc3Ryb3kpIHdyaXRhYmxlLmRlc3Ryb3koKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHdyaXRhYmxlID09PSBudWxsIHx8IHdyaXRhYmxlID09PSBmYWxzZSkge1xuICAgIHRoaXMuZW5kKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdW5lbmQgPSBlb3Mod3JpdGFibGUsIHt3cml0YWJsZTp0cnVlLCByZWFkYWJsZTpmYWxzZX0sIGRlc3Ryb3llcih0aGlzLCB0aGlzLl9mb3J3YXJkRW5kKSlcblxuICB2YXIgb25kcmFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbmRyYWluID0gc2VsZi5fb25kcmFpblxuICAgIHNlbGYuX29uZHJhaW4gPSBudWxsXG4gICAgaWYgKG9uZHJhaW4pIG9uZHJhaW4oKVxuICB9XG5cbiAgdmFyIGNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fd3JpdGFibGUucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbilcbiAgICB1bmVuZCgpXG4gIH1cblxuICBpZiAodGhpcy5fdW53cml0ZSkgcHJvY2Vzcy5uZXh0VGljayhvbmRyYWluKSAvLyBmb3JjZSBhIGRyYWluIG9uIHN0cmVhbSByZXNldCB0byBhdm9pZCBsaXZlbG9ja3NcblxuICB0aGlzLl93cml0YWJsZSA9IHdyaXRhYmxlXG4gIHRoaXMuX3dyaXRhYmxlLm9uKCdkcmFpbicsIG9uZHJhaW4pXG4gIHRoaXMuX3Vud3JpdGUgPSBjbGVhclxuXG4gIHRoaXMudW5jb3JrKCkgLy8gYWx3YXlzIHVuY29yayBzZXRXcml0YWJsZVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnNldFJlYWRhYmxlID0gZnVuY3Rpb24ocmVhZGFibGUpIHtcbiAgaWYgKHRoaXMuX3VucmVhZCkgdGhpcy5fdW5yZWFkKClcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAocmVhZGFibGUgJiYgcmVhZGFibGUuZGVzdHJveSkgcmVhZGFibGUuZGVzdHJveSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocmVhZGFibGUgPT09IG51bGwgfHwgcmVhZGFibGUgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5wdXNoKG51bGwpXG4gICAgdGhpcy5yZXN1bWUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB1bmVuZCA9IGVvcyhyZWFkYWJsZSwge3dyaXRhYmxlOmZhbHNlLCByZWFkYWJsZTp0cnVlfSwgZGVzdHJveWVyKHRoaXMpKVxuXG4gIHZhciBvbnJlYWRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZm9yd2FyZCgpXG4gIH1cblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLnB1c2gobnVsbClcbiAgfVxuXG4gIHZhciBjbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3JlYWRhYmxlMi5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBvbnJlYWRhYmxlKVxuICAgIHNlbGYuX3JlYWRhYmxlMi5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgdW5lbmQoKVxuICB9XG5cbiAgdGhpcy5fZHJhaW5lZCA9IHRydWVcbiAgdGhpcy5fcmVhZGFibGUgPSByZWFkYWJsZVxuICB0aGlzLl9yZWFkYWJsZTIgPSByZWFkYWJsZS5fcmVhZGFibGVTdGF0ZSA/IHJlYWRhYmxlIDogdG9TdHJlYW1zMihyZWFkYWJsZSlcbiAgdGhpcy5fcmVhZGFibGUyLm9uKCdyZWFkYWJsZScsIG9ucmVhZGFibGUpXG4gIHRoaXMuX3JlYWRhYmxlMi5vbignZW5kJywgb25lbmQpXG4gIHRoaXMuX3VucmVhZCA9IGNsZWFyXG5cbiAgdGhpcy5fZm9yd2FyZCgpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZHJhaW5lZCA9IHRydWVcbiAgdGhpcy5fZm9yd2FyZCgpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2ZvcndhcmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2ZvcndhcmRpbmcgfHwgIXRoaXMuX3JlYWRhYmxlMiB8fCAhdGhpcy5fZHJhaW5lZCkgcmV0dXJuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSB0cnVlXG5cbiAgdmFyIGRhdGFcblxuICB3aGlsZSAodGhpcy5fZHJhaW5lZCAmJiAoZGF0YSA9IHNoaWZ0KHRoaXMuX3JlYWRhYmxlMikpICE9PSBudWxsKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSBjb250aW51ZVxuICAgIHRoaXMuX2RyYWluZWQgPSB0aGlzLnB1c2goZGF0YSlcbiAgfVxuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSBmYWxzZVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZGVzdHJveShlcnIpXG4gIH0pXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKGVycikge1xuICAgIHZhciBvbmRyYWluID0gdGhpcy5fb25kcmFpblxuICAgIHRoaXMuX29uZHJhaW4gPSBudWxsXG4gICAgaWYgKG9uZHJhaW4pIG9uZHJhaW4oZXJyKVxuICAgIGVsc2UgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG4gIGlmICh0aGlzLl9mb3J3YXJkRGVzdHJveSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZSAmJiB0aGlzLl9yZWFkYWJsZS5kZXN0cm95KSB0aGlzLl9yZWFkYWJsZS5kZXN0cm95KClcbiAgICBpZiAodGhpcy5fd3JpdGFibGUgJiYgdGhpcy5fd3JpdGFibGUuZGVzdHJveSkgdGhpcy5fd3JpdGFibGUuZGVzdHJveSgpXG4gIH1cblxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihkYXRhLCBlbmMsIGNiKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIGNiKClcbiAgaWYgKHRoaXMuX2NvcmtlZCkgcmV0dXJuIG9udW5jb3JrKHRoaXMsIHRoaXMuX3dyaXRlLmJpbmQodGhpcywgZGF0YSwgZW5jLCBjYikpXG4gIGlmIChkYXRhID09PSBTSUdOQUxfRkxVU0gpIHJldHVybiB0aGlzLl9maW5pc2goY2IpXG4gIGlmICghdGhpcy5fd3JpdGFibGUpIHJldHVybiBjYigpXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlLndyaXRlKGRhdGEpID09PSBmYWxzZSkgdGhpcy5fb25kcmFpbiA9IGNiXG4gIGVsc2UgY2IoKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbihjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5lbWl0KCdwcmVlbmQnKVxuICBvbnVuY29yayh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBlbmQoc2VsZi5fZm9yd2FyZEVuZCAmJiBzZWxmLl93cml0YWJsZSwgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBoYXh4IHRvIG5vdCBlbWl0IHByZWZpbmlzaCB0d2ljZVxuICAgICAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPT09IGZhbHNlKSBzZWxmLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZVxuICAgICAgc2VsZi5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgb251bmNvcmsoc2VsZiwgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhLCBlbmMsIGNiKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZW5kKG51bGwsIG51bGwsIGRhdGEpXG4gIGlmICh0eXBlb2YgZW5jID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5lbmQoZGF0YSwgbnVsbCwgZW5jKVxuICB0aGlzLl9lbmRlZCA9IHRydWVcbiAgaWYgKGRhdGEpIHRoaXMud3JpdGUoZGF0YSlcbiAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZykgdGhpcy53cml0ZShTSUdOQUxfRkxVU0gpXG4gIHJldHVybiBzdHJlYW0uV3JpdGFibGUucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNiKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleGlmeVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbn0se1wiX3Byb2Nlc3NcIjo5MixcImJ1ZmZlclwiOjEyLFwiZW5kLW9mLXN0cmVhbVwiOjE4LFwiaW5oZXJpdHNcIjo4MCxcInJlYWRhYmxlLXN0cmVhbVwiOjEwOCxcInN0cmVhbS1zaGlmdFwiOjExMX1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc0NoaWxkUHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRyZXR1cm4gc3RyZWFtLnN0ZGlvICYmIEFycmF5LmlzQXJyYXkoc3RyZWFtLnN0ZGlvKSAmJiBzdHJlYW0uc3RkaW8ubGVuZ3RoID09PSAzXG59O1xuXG52YXIgZW9zID0gZnVuY3Rpb24oc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcblx0aWYgKCFvcHRzKSBvcHRzID0ge307XG5cblx0Y2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuXG5cdHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblx0dmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXHR2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IChvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGUpO1xuXHR2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IChvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGUpO1xuXG5cdHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuXHR9O1xuXG5cdHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHdyaXRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuXHR9O1xuXG5cdHZhciBvbmVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlYWRhYmxlID0gZmFsc2U7XG5cdFx0aWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuXHR9O1xuXG5cdHZhciBvbmV4aXQgPSBmdW5jdGlvbihleGl0Q29kZSkge1xuXHRcdGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBleGl0Q29kZSA/IG5ldyBFcnJvcignZXhpdGVkIHdpdGggZXJyb3IgY29kZTogJyArIGV4aXRDb2RlKSA6IG51bGwpO1xuXHR9O1xuXG5cdHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0Y2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG5cdH07XG5cblx0dmFyIG9uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAocmVhZGFibGUgJiYgIShycyAmJiBycy5lbmRlZCkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7XG5cdFx0aWYgKHdyaXRhYmxlICYmICEod3MgJiYgd3MuZW5kZWQpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHR9O1xuXG5cdHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdH07XG5cblx0aWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG5cdFx0c3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0aWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO1xuXHRcdGVsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0fSBlbHNlIGlmICh3cml0YWJsZSAmJiAhd3MpIHsgLy8gbGVnYWN5IHN0cmVhbXNcblx0XHRzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuXHR9XG5cblx0aWYgKGlzQ2hpbGRQcm9jZXNzKHN0cmVhbSkpIHN0cmVhbS5vbignZXhpdCcsIG9uZXhpdCk7XG5cblx0c3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG5cdHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuXHRpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcblx0c3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuXHRcdGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbmV4aXQpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVvcztcblxufSx7XCJvbmNlXCI6OTB9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBJbnNwaXJlZCBieSBHb29nbGUgQ2xvc3VyZTpcbi8vIGh0dHA6Ly9jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vc3ZuL2RvY3MvXG4vLyBjbG9zdXJlX2dvb2dfYXJyYXlfYXJyYXkuanMuaHRtbCNnb29nLmFycmF5LmNsZWFyXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdmFsdWUgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFsdWUodGhpcykubGVuZ3RoID0gMDtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG59LHtcIi4uLy4uL29iamVjdC92YWxpZC12YWx1ZVwiOjU1fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBudW1iZXJJc05hTiAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9udW1iZXIvaXMtbmFuXCIpXG4gICwgdG9Qb3NJbnQgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyXCIpXG4gICwgdmFsdWUgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCIpXG4gICwgaW5kZXhPZiAgICAgICAgICAgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxuICAsIG9iakhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGFicyAgICAgICAgICAgICAgID0gTWF0aC5hYnNcbiAgLCBmbG9vciAgICAgICAgICAgICA9IE1hdGguZmxvb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCovKSB7XG5cdHZhciBpLCBsZW5ndGgsIGZyb21JbmRleCwgdmFsO1xuXHRpZiAoIW51bWJlcklzTmFOKHNlYXJjaEVsZW1lbnQpKSByZXR1cm4gaW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdGxlbmd0aCA9IHRvUG9zSW50KHZhbHVlKHRoaXMpLmxlbmd0aCk7XG5cdGZyb21JbmRleCA9IGFyZ3VtZW50c1sxXTtcblx0aWYgKGlzTmFOKGZyb21JbmRleCkpIGZyb21JbmRleCA9IDA7XG5cdGVsc2UgaWYgKGZyb21JbmRleCA+PSAwKSBmcm9tSW5kZXggPSBmbG9vcihmcm9tSW5kZXgpO1xuXHRlbHNlIGZyb21JbmRleCA9IHRvUG9zSW50KHRoaXMubGVuZ3RoKSAtIGZsb29yKGFicyhmcm9tSW5kZXgpKTtcblxuXHRmb3IgKGkgPSBmcm9tSW5kZXg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdGlmIChvYmpIYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpKSB7XG5cdFx0XHR2YWwgPSB0aGlzW2ldO1xuXHRcdFx0aWYgKG51bWJlcklzTmFOKHZhbCkpIHJldHVybiBpOyAvLyBKc2xpbnQ6IGlnbm9yZVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG59LHtcIi4uLy4uL251bWJlci9pcy1uYW5cIjozMCxcIi4uLy4uL251bWJlci90by1wb3MtaW50ZWdlclwiOjM0LFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCI6NTV9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpXG5cdD8gQXJyYXkuZnJvbVxuXHQ6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG5cbn0se1wiLi9pcy1pbXBsZW1lbnRlZFwiOjIyLFwiLi9zaGltXCI6MjN9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBmcm9tID0gQXJyYXkuZnJvbSwgYXJyLCByZXN1bHQ7XG5cdGlmICh0eXBlb2YgZnJvbSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdGFyciA9IFtcInJhelwiLCBcImR3YVwiXTtcblx0cmVzdWx0ID0gZnJvbShhcnIpO1xuXHRyZXR1cm4gQm9vbGVhbihyZXN1bHQgJiYgKHJlc3VsdCAhPT0gYXJyKSAmJiAocmVzdWx0WzFdID09PSBcImR3YVwiKSk7XG59O1xuXG59LHt9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIikuaXRlcmF0b3JcbiAgLCBpc0FyZ3VtZW50cyAgICA9IHJlcXVpcmUoXCIuLi8uLi9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIilcbiAgLCBpc0Z1bmN0aW9uICAgICA9IHJlcXVpcmUoXCIuLi8uLi9mdW5jdGlvbi9pcy1mdW5jdGlvblwiKVxuICAsIHRvUG9zSW50ICAgICAgID0gcmVxdWlyZShcIi4uLy4uL251bWJlci90by1wb3MtaW50ZWdlclwiKVxuICAsIGNhbGxhYmxlICAgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC1jYWxsYWJsZVwiKVxuICAsIHZhbGlkVmFsdWUgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC12YWx1ZVwiKVxuICAsIGlzVmFsdWUgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC9pcy12YWx1ZVwiKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZShcIi4uLy4uL3N0cmluZy9pcy1zdHJpbmdcIilcbiAgLCBpc0FycmF5ICAgICAgICA9IEFycmF5LmlzQXJyYXlcbiAgLCBjYWxsICAgICAgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgZGVzYyAgICAgICAgICAgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBudWxsIH1cbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycmF5TGlrZSAvKiwgbWFwRm4sIHRoaXNBcmcqLykge1xuXHR2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV1cblx0ICAsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl1cblx0ICAsIENvbnRleHRcblx0ICAsIGlcblx0ICAsIGpcblx0ICAsIGFyclxuXHQgICwgbGVuZ3RoXG5cdCAgLCBjb2RlXG5cdCAgLCBpdGVyYXRvclxuXHQgICwgcmVzdWx0XG5cdCAgLCBnZXRJdGVyYXRvclxuXHQgICwgdmFsdWU7XG5cblx0YXJyYXlMaWtlID0gT2JqZWN0KHZhbGlkVmFsdWUoYXJyYXlMaWtlKSk7XG5cblx0aWYgKGlzVmFsdWUobWFwRm4pKSBjYWxsYWJsZShtYXBGbik7XG5cdGlmICghdGhpcyB8fCB0aGlzID09PSBBcnJheSB8fCAhaXNGdW5jdGlvbih0aGlzKSkge1xuXHRcdC8vIFJlc3VsdDogUGxhaW4gYXJyYXlcblx0XHRpZiAoIW1hcEZuKSB7XG5cdFx0XHRpZiAoaXNBcmd1bWVudHMoYXJyYXlMaWtlKSkge1xuXHRcdFx0XHQvLyBTb3VyY2U6IEFyZ3VtZW50c1xuXHRcdFx0XHRsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuXHRcdFx0XHRpZiAobGVuZ3RoICE9PSAxKSByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwgYXJyYXlMaWtlKTtcblx0XHRcdFx0YXJyID0gbmV3IEFycmF5KDEpO1xuXHRcdFx0XHRhcnJbMF0gPSBhcnJheUxpa2VbMF07XG5cdFx0XHRcdHJldHVybiBhcnI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBcnJheShhcnJheUxpa2UpKSB7XG5cdFx0XHRcdC8vIFNvdXJjZTogQXJyYXlcblx0XHRcdFx0YXJyID0gbmV3IEFycmF5KGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGgpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIGFycltpXSA9IGFycmF5TGlrZVtpXTtcblx0XHRcdFx0cmV0dXJuIGFycjtcblx0XHRcdH1cblx0XHR9XG5cdFx0YXJyID0gW107XG5cdH0gZWxzZSB7XG5cdFx0Ly8gUmVzdWx0OiBOb24gcGxhaW4gYXJyYXlcblx0XHRDb250ZXh0ID0gdGhpcztcblx0fVxuXG5cdGlmICghaXNBcnJheShhcnJheUxpa2UpKSB7XG5cdFx0aWYgKChnZXRJdGVyYXRvciA9IGFycmF5TGlrZVtpdGVyYXRvclN5bWJvbF0pICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIFNvdXJjZTogSXRlcmF0b3Jcblx0XHRcdGl0ZXJhdG9yID0gY2FsbGFibGUoZ2V0SXRlcmF0b3IpLmNhbGwoYXJyYXlMaWtlKTtcblx0XHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dCgpO1xuXHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0aSA9IDA7XG5cdFx0XHR3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdHZhbHVlID0gbWFwRm4gPyBjYWxsLmNhbGwobWFwRm4sIHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgaSkgOiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdFx0ZGVzYy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KGFyciwgaSwgZGVzYyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXJyW2ldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0XHRsZW5ndGggPSBpO1xuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoYXJyYXlMaWtlKSkge1xuXHRcdFx0Ly8gU291cmNlOiBTdHJpbmdcblx0XHRcdGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XG5cdFx0XHRpZiAoQ29udGV4dCkgYXJyID0gbmV3IENvbnRleHQoKTtcblx0XHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dmFsdWUgPSBhcnJheUxpa2VbaV07XG5cdFx0XHRcdGlmIChpICsgMSA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcblx0XHRcdFx0XHRpZiAoY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmYpIHZhbHVlICs9IGFycmF5TGlrZVsrK2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gbWFwRm4gPyBjYWxsLmNhbGwobWFwRm4sIHRoaXNBcmcsIHZhbHVlLCBqKSA6IHZhbHVlO1xuXHRcdFx0XHRpZiAoQ29udGV4dCkge1xuXHRcdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnIsIGosIGRlc2MpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFycltqXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCsrajtcblx0XHRcdH1cblx0XHRcdGxlbmd0aCA9IGo7XG5cdFx0fVxuXHR9XG5cdGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIFNvdXJjZTogYXJyYXkgb3IgYXJyYXktbGlrZVxuXHRcdGxlbmd0aCA9IHRvUG9zSW50KGFycmF5TGlrZS5sZW5ndGgpO1xuXHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dChsZW5ndGgpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0dmFsdWUgPSBtYXBGbiA/IGNhbGwuY2FsbChtYXBGbiwgdGhpc0FyZywgYXJyYXlMaWtlW2ldLCBpKSA6IGFycmF5TGlrZVtpXTtcblx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyLCBpLCBkZXNjKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFycltpXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoQ29udGV4dCkge1xuXHRcdGRlc2MudmFsdWUgPSBudWxsO1xuXHRcdGFyci5sZW5ndGggPSBsZW5ndGg7XG5cdH1cblx0cmV0dXJuIGFycjtcbn07XG5cbn0se1wiLi4vLi4vZnVuY3Rpb24vaXMtYXJndW1lbnRzXCI6MjQsXCIuLi8uLi9mdW5jdGlvbi9pcy1mdW5jdGlvblwiOjI1LFwiLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyXCI6MzQsXCIuLi8uLi9vYmplY3QvaXMtdmFsdWVcIjo0NCxcIi4uLy4uL29iamVjdC92YWxpZC1jYWxsYWJsZVwiOjU0LFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCI6NTUsXCIuLi8uLi9zdHJpbmcvaXMtc3RyaW5nXCI6NTksXCJlczYtc3ltYm9sXCI6NzN9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAsIGlkID0gb2JqVG9TdHJpbmcuY2FsbChcblx0KGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzO1xuXHR9KSgpXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IGlkO1xufTtcblxufSx7fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsIGlkID0gb2JqVG9TdHJpbmcuY2FsbChyZXF1aXJlKFwiLi9ub29wXCIpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBpZDtcbn07XG5cbn0se1wiLi9ub29wXCI6MjZ9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHt9O1xuXG59LHt9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpXG5cdD8gTWF0aC5zaWduXG5cdDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6MjgsXCIuL3NoaW1cIjoyOX1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNpZ24gPSBNYXRoLnNpZ247XG5cdGlmICh0eXBlb2Ygc2lnbiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoc2lnbigxMCkgPT09IDEpICYmIChzaWduKC0yMCkgPT09IC0xKTtcbn07XG5cbn0se31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdGlmIChpc05hTih2YWx1ZSkgfHwgKHZhbHVlID09PSAwKSkgcmV0dXJuIHZhbHVlO1xuXHRyZXR1cm4gdmFsdWUgPiAwID8gMSA6IC0xO1xufTtcblxufSx7fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKVxuXHQ/IE51bWJlci5pc05hTlxuXHQ6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG5cbn0se1wiLi9pcy1pbXBsZW1lbnRlZFwiOjMxLFwiLi9zaGltXCI6MzJ9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBudW1iZXJJc05hTiA9IE51bWJlci5pc05hTjtcblx0aWYgKHR5cGVvZiBudW1iZXJJc05hTiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAhbnVtYmVySXNOYU4oe30pICYmIG51bWJlcklzTmFOKE5hTikgJiYgIW51bWJlcklzTmFOKDM0KTtcbn07XG5cbn0se31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cdHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59O1xuXG59LHt9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHNpZ24gPSByZXF1aXJlKFwiLi4vbWF0aC9zaWduXCIpXG5cbiAgLCBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gMDtcblx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRpZiAoKHZhbHVlID09PSAwKSB8fCAhaXNGaW5pdGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiBzaWduKHZhbHVlKSAqIGZsb29yKGFicyh2YWx1ZSkpO1xufTtcblxufSx7XCIuLi9tYXRoL3NpZ25cIjoyN31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZShcIi4vdG8taW50ZWdlclwiKVxuXG4gICwgbWF4ID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gcmV0dXJuIG1heCgwLCB0b0ludGVnZXIodmFsdWUpKTtcbn07XG5cbn0se1wiLi90by1pbnRlZ2VyXCI6MzN9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBJbnRlcm5hbCBtZXRob2QsIHVzZWQgYnkgaXRlcmF0aW9uIGZ1bmN0aW9ucy5cbi8vIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2gga2V5LXZhbHVlIHBhaXIgZm91bmQgaW4gb2JqZWN0XG4vLyBPcHRpb25hbGx5IHRha2VzIGNvbXBhcmVGbiB0byBpdGVyYXRlIG9iamVjdCBpbiBzcGVjaWZpYyBvcmRlclxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNhbGxhYmxlICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWQtY2FsbGFibGVcIilcbiAgLCB2YWx1ZSAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3ZhbGlkLXZhbHVlXCIpXG4gICwgYmluZCAgICAgICAgICAgICAgICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICAsIGNhbGwgICAgICAgICAgICAgICAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBrZXlzICAgICAgICAgICAgICAgICAgICA9IE9iamVjdC5rZXlzXG4gICwgb2JqUHJvcGVydHlJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGRlZlZhbCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKG9iaiwgY2IgLyosIHRoaXNBcmcsIGNvbXBhcmVGbiovKSB7XG5cdFx0dmFyIGxpc3QsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIGNvbXBhcmVGbiA9IGFyZ3VtZW50c1szXTtcblx0XHRvYmogPSBPYmplY3QodmFsdWUob2JqKSk7XG5cdFx0Y2FsbGFibGUoY2IpO1xuXG5cdFx0bGlzdCA9IGtleXMob2JqKTtcblx0XHRpZiAoY29tcGFyZUZuKSB7XG5cdFx0XHRsaXN0LnNvcnQodHlwZW9mIGNvbXBhcmVGbiA9PT0gXCJmdW5jdGlvblwiID8gYmluZC5jYWxsKGNvbXBhcmVGbiwgb2JqKSA6IHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIG1ldGhvZCA9IGxpc3RbbWV0aG9kXTtcblx0XHRyZXR1cm4gY2FsbC5jYWxsKG1ldGhvZCwgbGlzdCwgZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcblx0XHRcdGlmICghb2JqUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSkpIHJldHVybiBkZWZWYWw7XG5cdFx0XHRyZXR1cm4gY2FsbC5jYWxsKGNiLCB0aGlzQXJnLCBvYmpba2V5XSwga2V5LCBvYmosIGluZGV4KTtcblx0XHR9KTtcblx0fTtcbn07XG5cbn0se1wiLi92YWxpZC1jYWxsYWJsZVwiOjU0LFwiLi92YWxpZC12YWx1ZVwiOjU1fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKVxuXHQ/IE9iamVjdC5hc3NpZ25cblx0OiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjozNyxcIi4vc2hpbVwiOjM4fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiwgb2JqO1xuXHRpZiAodHlwZW9mIGFzc2lnbiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdG9iaiA9IHsgZm9vOiBcInJhelwiIH07XG5cdGFzc2lnbihvYmosIHsgYmFyOiBcImR3YVwiIH0sIHsgdHJ6eTogXCJ0cnp5XCIgfSk7XG5cdHJldHVybiAob2JqLmZvbyArIG9iai5iYXIgKyBvYmoudHJ6eSkgPT09IFwicmF6ZHdhdHJ6eVwiO1xufTtcblxufSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlzICA9IHJlcXVpcmUoXCIuLi9rZXlzXCIpXG4gICwgdmFsdWUgPSByZXF1aXJlKFwiLi4vdmFsaWQtdmFsdWVcIilcbiAgLCBtYXggICA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZXN0LCBzcmMgLyosIOKApnNyY24qLykge1xuXHR2YXIgZXJyb3IsIGksIGxlbmd0aCA9IG1heChhcmd1bWVudHMubGVuZ3RoLCAyKSwgYXNzaWduO1xuXHRkZXN0ID0gT2JqZWN0KHZhbHVlKGRlc3QpKTtcblx0YXNzaWduID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdHRyeSB7XG5cdFx0XHRkZXN0W2tleV0gPSBzcmNba2V5XTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGU7XG5cdFx0fVxuXHR9O1xuXHRmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0a2V5cyhzcmMpLmZvckVhY2goYXNzaWduKTtcblx0fVxuXHRpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgZXJyb3I7XG5cdHJldHVybiBkZXN0O1xufTtcblxufSx7XCIuLi9rZXlzXCI6NDUsXCIuLi92YWxpZC12YWx1ZVwiOjU1fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhRnJvbSAgPSByZXF1aXJlKFwiLi4vYXJyYXkvZnJvbVwiKVxuICAsIGFzc2lnbiA9IHJlcXVpcmUoXCIuL2Fzc2lnblwiKVxuICAsIHZhbHVlICA9IHJlcXVpcmUoXCIuL3ZhbGlkLXZhbHVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmovKiwgcHJvcGVydHlOYW1lcywgb3B0aW9ucyovKSB7XG5cdHZhciBjb3B5ID0gT2JqZWN0KHZhbHVlKG9iaikpLCBwcm9wZXJ0eU5hbWVzID0gYXJndW1lbnRzWzFdLCBvcHRpb25zID0gT2JqZWN0KGFyZ3VtZW50c1syXSk7XG5cdGlmIChjb3B5ICE9PSBvYmogJiYgIXByb3BlcnR5TmFtZXMpIHJldHVybiBjb3B5O1xuXHR2YXIgcmVzdWx0ID0ge307XG5cdGlmIChwcm9wZXJ0eU5hbWVzKSB7XG5cdFx0YUZyb20ocHJvcGVydHlOYW1lcywgZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuXHRcdFx0aWYgKG9wdGlvbnMuZW5zdXJlIHx8IHByb3BlcnR5TmFtZSBpbiBvYmopIHJlc3VsdFtwcm9wZXJ0eU5hbWVdID0gb2JqW3Byb3BlcnR5TmFtZV07XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0YXNzaWduKHJlc3VsdCwgb2JqKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxufSx7XCIuLi9hcnJheS9mcm9tXCI6MjEsXCIuL2Fzc2lnblwiOjM2LFwiLi92YWxpZC12YWx1ZVwiOjU1fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gV29ya2Fyb3VuZCBmb3IgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjgwNFxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIHNoaW07XG5cbmlmICghcmVxdWlyZShcIi4vc2V0LXByb3RvdHlwZS1vZi9pcy1pbXBsZW1lbnRlZFwiKSgpKSB7XG5cdHNoaW0gPSByZXF1aXJlKFwiLi9zZXQtcHJvdG90eXBlLW9mL3NoaW1cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIG51bGxPYmplY3QsIHBvbHlQcm9wcywgZGVzYztcblx0aWYgKCFzaGltKSByZXR1cm4gY3JlYXRlO1xuXHRpZiAoc2hpbS5sZXZlbCAhPT0gMSkgcmV0dXJuIGNyZWF0ZTtcblxuXHRudWxsT2JqZWN0ID0ge307XG5cdHBvbHlQcm9wcyA9IHt9O1xuXHRkZXNjID0ge1xuXHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0dmFsdWU6IHVuZGVmaW5lZFxuXHR9O1xuXHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIpIHtcblx0XHRcdHBvbHlQcm9wc1tuYW1lXSA9IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB1bmRlZmluZWRcblx0XHRcdH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHBvbHlQcm9wc1tuYW1lXSA9IGRlc2M7XG5cdH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhudWxsT2JqZWN0LCBwb2x5UHJvcHMpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaGltLCBcIm51bGxQb2x5ZmlsbFwiLCB7XG5cdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0dmFsdWU6IG51bGxPYmplY3Rcblx0fSk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BzKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZShwcm90b3R5cGUgPT09IG51bGwgPyBudWxsT2JqZWN0IDogcHJvdG90eXBlLCBwcm9wcyk7XG5cdH07XG59KCkpO1xuXG59LHtcIi4vc2V0LXByb3RvdHlwZS1vZi9pcy1pbXBsZW1lbnRlZFwiOjUyLFwiLi9zZXQtcHJvdG90eXBlLW9mL3NoaW1cIjo1M31dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL19pdGVyYXRlXCIpKFwiZm9yRWFjaFwiKTtcblxufSx7XCIuL19pdGVyYXRlXCI6MzV9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBEZXByZWNhdGVkXG5cblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxufSx7fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4vaXMtdmFsdWVcIik7XG5cbnZhciBtYXAgPSB7IGZ1bmN0aW9uOiB0cnVlLCBvYmplY3Q6IHRydWUgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIChpc1ZhbHVlKHZhbHVlKSAmJiBtYXBbdHlwZW9mIHZhbHVlXSkgfHwgZmFsc2U7XG59O1xuXG59LHtcIi4vaXMtdmFsdWVcIjo0NH1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX3VuZGVmaW5lZCA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvbi9ub29wXCIpKCk7IC8vIFN1cHBvcnQgRVMzIGVuZ2luZXNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsKSB7XG4gcmV0dXJuICh2YWwgIT09IF91bmRlZmluZWQpICYmICh2YWwgIT09IG51bGwpO1xufTtcblxufSx7XCIuLi9mdW5jdGlvbi9ub29wXCI6MjZ9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gT2JqZWN0LmtleXMgOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjo0NixcIi4vc2hpbVwiOjQ3fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR0cnkge1xuXHRcdE9iamVjdC5rZXlzKFwicHJpbWl0aXZlXCIpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG59LHt9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi4vaXMtdmFsdWVcIik7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4ga2V5cyhpc1ZhbHVlKG9iamVjdCkgPyBPYmplY3Qob2JqZWN0KSA6IG9iamVjdCk7IH07XG5cbn0se1wiLi4vaXMtdmFsdWVcIjo0NH1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FsbGFibGUgPSByZXF1aXJlKFwiLi92YWxpZC1jYWxsYWJsZVwiKVxuICAsIGZvckVhY2ggID0gcmVxdWlyZShcIi4vZm9yLWVhY2hcIilcbiAgLCBjYWxsICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGNiIC8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIHJlc3VsdCA9IHt9LCB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuXHRjYWxsYWJsZShjYik7XG5cdGZvckVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSwgdGFyZ2V0T2JqLCBpbmRleCkge1xuXHRcdHJlc3VsdFtrZXldID0gY2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB2YWx1ZSwga2V5LCB0YXJnZXRPYmosIGluZGV4KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG59LHtcIi4vZm9yLWVhY2hcIjo0MSxcIi4vdmFsaWQtY2FsbGFibGVcIjo1NH1dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuL2lzLXZhbHVlXCIpO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG52YXIgcHJvY2VzcyA9IGZ1bmN0aW9uIChzcmMsIG9iaikge1xuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBzcmMpIG9ialtrZXldID0gc3JjW2tleV07XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMxIC8qLCDigKZvcHRpb25zKi8pIHtcblx0dmFyIHJlc3VsdCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRpZiAoIWlzVmFsdWUob3B0aW9ucykpIHJldHVybjtcblx0XHRwcm9jZXNzKE9iamVjdChvcHRpb25zKSwgcmVzdWx0KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG59LHtcIi4vaXMtdmFsdWVcIjo0NH1dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZyAvKiwg4oCmYXJncyovKSB7XG5cdHZhciBzZXQgPSBjcmVhdGUobnVsbCk7XG5cdGZvckVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0c2V0W25hbWVdID0gdHJ1ZTtcblx0fSk7XG5cdHJldHVybiBzZXQ7XG59O1xuXG59LHt9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpXG5cdD8gT2JqZWN0LnNldFByb3RvdHlwZU9mXG5cdDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6NTIsXCIuL3NoaW1cIjo1M31dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIHBsYWluT2JqZWN0ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qIEN1c3RvbUNyZWF0ZSovKSB7XG5cdHZhciBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiwgY3VzdG9tQ3JlYXRlID0gYXJndW1lbnRzWzBdIHx8IGNyZWF0ZTtcblx0aWYgKHR5cGVvZiBzZXRQcm90b3R5cGVPZiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBnZXRQcm90b3R5cGVPZihzZXRQcm90b3R5cGVPZihjdXN0b21DcmVhdGUobnVsbCksIHBsYWluT2JqZWN0KSkgPT09IHBsYWluT2JqZWN0O1xufTtcblxufSx7fV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50IG5vLXByb3RvOiBcIm9mZlwiICovXG5cbi8vIEJpZyB0aGFua3MgdG8gQFdlYlJlZmxlY3Rpb24gZm9yIHNvcnRpbmcgdGhpcyBvdXRcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vNTU5MzU1NFxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoXCIuLi9pcy1vYmplY3RcIilcbiAgLCB2YWx1ZSAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vdmFsaWQtdmFsdWVcIilcbiAgLCBvYmpJc1Byb3RvdHlwZU9mID0gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mXG4gICwgZGVmaW5lUHJvcGVydHkgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgbnVsbERlc2MgICAgICAgID0ge1xuXHRjb25maWd1cmFibGU6IHRydWUsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHR3cml0YWJsZTogdHJ1ZSxcblx0dmFsdWU6IHVuZGVmaW5lZFxufVxuICAsIHZhbGlkYXRlO1xuXG52YWxpZGF0ZSA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHR2YWx1ZShvYmopO1xuXHRpZiAocHJvdG90eXBlID09PSBudWxsIHx8IGlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiBvYmo7XG5cdHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm90b3R5cGUgbXVzdCBiZSBudWxsIG9yIGFuIG9iamVjdFwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0dmFyIGZuLCBzZXQ7XG5cdGlmICghc3RhdHVzKSByZXR1cm4gbnVsbDtcblx0aWYgKHN0YXR1cy5sZXZlbCA9PT0gMikge1xuXHRcdGlmIChzdGF0dXMuc2V0KSB7XG5cdFx0XHRzZXQgPSBzdGF0dXMuc2V0O1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0c2V0LmNhbGwodmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLCBwcm90b3R5cGUpO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0dmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZuID0gZnVuY3Rpb24gc2VsZihvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0dmFyIGlzTnVsbEJhc2U7XG5cdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSk7XG5cdFx0XHRpc051bGxCYXNlID0gb2JqSXNQcm90b3R5cGVPZi5jYWxsKHNlbGYubnVsbFBvbHlmaWxsLCBvYmopO1xuXHRcdFx0aWYgKGlzTnVsbEJhc2UpIGRlbGV0ZSBzZWxmLm51bGxQb2x5ZmlsbC5fX3Byb3RvX187XG5cdFx0XHRpZiAocHJvdG90eXBlID09PSBudWxsKSBwcm90b3R5cGUgPSBzZWxmLm51bGxQb2x5ZmlsbDtcblx0XHRcdG9iai5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG5cdFx0XHRpZiAoaXNOdWxsQmFzZSkgZGVmaW5lUHJvcGVydHkoc2VsZi5udWxsUG9seWZpbGwsIFwiX19wcm90b19fXCIsIG51bGxEZXNjKTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBcImxldmVsXCIsIHtcblx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHR2YWx1ZTogc3RhdHVzLmxldmVsXG5cdH0pO1xufShcblx0KGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdG1wT2JqMSA9IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHQgICwgdG1wT2JqMiA9IHt9XG5cdFx0ICAsIHNldFxuXHRcdCAgLCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCBcIl9fcHJvdG9fX1wiKTtcblxuXHRcdGlmIChkZXNjKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzZXQgPSBkZXNjLnNldDsgLy8gT3BlcmEgY3Jhc2hlcyBhdCB0aGlzIHBvaW50XG5cdFx0XHRcdHNldC5jYWxsKHRtcE9iajEsIHRtcE9iajIpO1xuXHRcdFx0fSBjYXRjaCAoaWdub3JlKSB7fVxuXHRcdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0bXBPYmoxKSA9PT0gdG1wT2JqMikgcmV0dXJuIHsgc2V0OiBzZXQsIGxldmVsOiAyIH07XG5cdFx0fVxuXG5cdFx0dG1wT2JqMS5fX3Byb3RvX18gPSB0bXBPYmoyO1xuXHRcdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodG1wT2JqMSkgPT09IHRtcE9iajIpIHJldHVybiB7IGxldmVsOiAyIH07XG5cblx0XHR0bXBPYmoxID0ge307XG5cdFx0dG1wT2JqMS5fX3Byb3RvX18gPSB0bXBPYmoyO1xuXHRcdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodG1wT2JqMSkgPT09IHRtcE9iajIpIHJldHVybiB7IGxldmVsOiAxIH07XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pKClcbikpO1xuXG5yZXF1aXJlKFwiLi4vY3JlYXRlXCIpO1xuXG59LHtcIi4uL2NyZWF0ZVwiOjQwLFwiLi4vaXMtb2JqZWN0XCI6NDMsXCIuLi92YWxpZC12YWx1ZVwiOjU1fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRyZXR1cm4gZm47XG59O1xuXG59LHt9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi9pcy12YWx1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1ZhbHVlKHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgbnVsbCBvciB1bmRlZmluZWRcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbn0se1wiLi9pcy12YWx1ZVwiOjQ0fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKVxuXHQ/IFN0cmluZy5wcm90b3R5cGUuY29udGFpbnNcblx0OiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjo1NyxcIi4vc2hpbVwiOjU4fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHIgPSBcInJhemR3YXRyenlcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc3RyLmNvbnRhaW5zICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIChzdHIuY29udGFpbnMoXCJkd2FcIikgPT09IHRydWUpICYmIChzdHIuY29udGFpbnMoXCJmb29cIikgPT09IGZhbHNlKTtcbn07XG5cbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW5kZXhPZiA9IFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nLyosIHBvc2l0aW9uKi8pIHtcblx0cmV0dXJuIGluZGV4T2YuY2FsbCh0aGlzLCBzZWFyY2hTdHJpbmcsIGFyZ3VtZW50c1sxXSkgPiAtMTtcbn07XG5cbn0se31dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCBpZCA9IG9ialRvU3RyaW5nLmNhbGwoXCJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8XG5cdFx0KHZhbHVlICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcblx0XHRcdCh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gaWQpKSB8fFxuXHRcdGZhbHNlXG5cdCk7XG59O1xuXG59LHt9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIilcbiAgLCBjb250YWlucyAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zXCIpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIFN5bWJvbCAgICAgICAgID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIilcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoXCIuL1wiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBBcnJheUl0ZXJhdG9yO1xuXG5BcnJheUl0ZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyLCBraW5kKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBBcnJheUl0ZXJhdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIHJlcXVpcmVzICduZXcnXCIpO1xuXHRJdGVyYXRvci5jYWxsKHRoaXMsIGFycik7XG5cdGlmICgha2luZCkga2luZCA9IFwidmFsdWVcIjtcblx0ZWxzZSBpZiAoY29udGFpbnMuY2FsbChraW5kLCBcImtleSt2YWx1ZVwiKSkga2luZCA9IFwia2V5K3ZhbHVlXCI7XG5cdGVsc2UgaWYgKGNvbnRhaW5zLmNhbGwoa2luZCwgXCJrZXlcIikpIGtpbmQgPSBcImtleVwiO1xuXHRlbHNlIGtpbmQgPSBcInZhbHVlXCI7XG5cdGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX19raW5kX19cIiwgZChcIlwiLCBraW5kKSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihBcnJheUl0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbi8vIEludGVybmFsICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSBkb2Vzbid0IGV4cG9zZSBpdHMgY29uc3RydWN0b3JcbmRlbGV0ZSBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuQXJyYXlJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSBcInZhbHVlXCIpIHJldHVybiB0aGlzLl9fbGlzdF9fW2ldO1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSBcImtleSt2YWx1ZVwiKSByZXR1cm4gW2ksIHRoaXMuX19saXN0X19baV1dO1xuXHRcdHJldHVybiBpO1xuXHR9KVxufSk7XG5kZWZpbmVQcm9wZXJ0eShBcnJheUl0ZXJhdG9yLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkKFwiY1wiLCBcIkFycmF5IEl0ZXJhdG9yXCIpKTtcblxufSx7XCIuL1wiOjYzLFwiZFwiOjE2LFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiOjUxLFwiZXM1LWV4dC9zdHJpbmcvIy9jb250YWluc1wiOjU2LFwiZXM2LXN5bWJvbFwiOjczfV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoXCJlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGNhbGxhYmxlICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgaXNTdHJpbmcgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nXCIpXG4gICwgZ2V0ICAgICAgICAgPSByZXF1aXJlKFwiLi9nZXRcIik7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLCBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBjYiAvKiwgdGhpc0FyZyovKSB7XG5cdHZhciBtb2RlLCB0aGlzQXJnID0gYXJndW1lbnRzWzJdLCByZXN1bHQsIGRvQnJlYWssIGJyb2tlbiwgaSwgbGVuZ3RoLCBjaGFyLCBjb2RlO1xuXHRpZiAoaXNBcnJheShpdGVyYWJsZSkgfHwgaXNBcmd1bWVudHMoaXRlcmFibGUpKSBtb2RlID0gXCJhcnJheVwiO1xuXHRlbHNlIGlmIChpc1N0cmluZyhpdGVyYWJsZSkpIG1vZGUgPSBcInN0cmluZ1wiO1xuXHRlbHNlIGl0ZXJhYmxlID0gZ2V0KGl0ZXJhYmxlKTtcblxuXHRjYWxsYWJsZShjYik7XG5cdGRvQnJlYWsgPSBmdW5jdGlvbiAoKSB7XG5cdFx0YnJva2VuID0gdHJ1ZTtcblx0fTtcblx0aWYgKG1vZGUgPT09IFwiYXJyYXlcIikge1xuXHRcdHNvbWUuY2FsbChpdGVyYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHZhbHVlLCBkb0JyZWFrKTtcblx0XHRcdHJldHVybiBicm9rZW47XG5cdFx0fSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGlmIChtb2RlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0bGVuZ3RoID0gaXRlcmFibGUubGVuZ3RoO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0Y2hhciA9IGl0ZXJhYmxlW2ldO1xuXHRcdFx0aWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRcdGlmIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZikgY2hhciArPSBpdGVyYWJsZVsrK2ldO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCBjaGFyLCBkb0JyZWFrKTtcblx0XHRcdGlmIChicm9rZW4pIGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblx0cmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuXG5cdHdoaWxlICghcmVzdWx0LmRvbmUpIHtcblx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgZG9CcmVhayk7XG5cdFx0aWYgKGJyb2tlbikgcmV0dXJuO1xuXHRcdHJlc3VsdCA9IGl0ZXJhYmxlLm5leHQoKTtcblx0fVxufTtcblxufSx7XCIuL2dldFwiOjYyLFwiZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIjoyNCxcImVzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCI6NTQsXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIjo1OX1dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNBcmd1bWVudHMgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIilcbiAgLCBpc1N0cmluZyAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIilcbiAgLCBBcnJheUl0ZXJhdG9yICA9IHJlcXVpcmUoXCIuL2FycmF5XCIpXG4gICwgU3RyaW5nSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9zdHJpbmdcIilcbiAgLCBpdGVyYWJsZSAgICAgICA9IHJlcXVpcmUoXCIuL3ZhbGlkLWl0ZXJhYmxlXCIpXG4gICwgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKS5pdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG5cdGlmICh0eXBlb2YgaXRlcmFibGUob2JqKVtpdGVyYXRvclN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG9ialtpdGVyYXRvclN5bWJvbF0oKTtcblx0aWYgKGlzQXJndW1lbnRzKG9iaikpIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xuXHRpZiAoaXNTdHJpbmcob2JqKSkgcmV0dXJuIG5ldyBTdHJpbmdJdGVyYXRvcihvYmopO1xuXHRyZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqKTtcbn07XG5cbn0se1wiLi9hcnJheVwiOjYwLFwiLi9zdHJpbmdcIjo2NSxcIi4vdmFsaWQtaXRlcmFibGVcIjo2NixcImVzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzXCI6MjQsXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIjo1OSxcImVzNi1zeW1ib2xcIjo3M31dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2xlYXIgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9hcnJheS8jL2NsZWFyXCIpXG4gICwgYXNzaWduICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvYXNzaWduXCIpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIilcbiAgLCB2YWx1ZSAgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZVwiKVxuICAsIGQgICAgICAgID0gcmVxdWlyZShcImRcIilcbiAgLCBhdXRvQmluZCA9IHJlcXVpcmUoXCJkL2F1dG8tYmluZFwiKVxuICAsIFN5bWJvbCAgID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIik7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBJdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVyYXRvciA9IGZ1bmN0aW9uIChsaXN0LCBjb250ZXh0KSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBJdGVyYXRvcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJ1Y3RvciByZXF1aXJlcyAnbmV3J1wiKTtcblx0ZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG5cdFx0X19saXN0X186IGQoXCJ3XCIsIHZhbHVlKGxpc3QpKSxcblx0XHRfX2NvbnRleHRfXzogZChcIndcIiwgY29udGV4dCksXG5cdFx0X19uZXh0SW5kZXhfXzogZChcIndcIiwgMClcblx0fSk7XG5cdGlmICghY29udGV4dCkgcmV0dXJuO1xuXHRjYWxsYWJsZShjb250ZXh0Lm9uKTtcblx0Y29udGV4dC5vbihcIl9hZGRcIiwgdGhpcy5fb25BZGQpO1xuXHRjb250ZXh0Lm9uKFwiX2RlbGV0ZVwiLCB0aGlzLl9vbkRlbGV0ZSk7XG5cdGNvbnRleHQub24oXCJfY2xlYXJcIiwgdGhpcy5fb25DbGVhcik7XG59O1xuXG4vLyBJbnRlcm5hbCAlSXRlcmF0b3JQcm90b3R5cGUlIGRvZXNuJ3QgZXhwb3NlIGl0cyBjb25zdHJ1Y3RvclxuZGVsZXRlIEl0ZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuZGVmaW5lUHJvcGVydGllcyhcblx0SXRlcmF0b3IucHJvdG90eXBlLFxuXHRhc3NpZ24oXG5cdFx0e1xuXHRcdFx0X25leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0aWYgKCF0aGlzLl9fbGlzdF9fKSByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlZG9fXykge1xuXHRcdFx0XHRcdGkgPSB0aGlzLl9fcmVkb19fLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKGkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA8IHRoaXMuX19saXN0X18ubGVuZ3RoKSByZXR1cm4gdGhpcy5fX25leHRJbmRleF9fKys7XG5cdFx0XHRcdHRoaXMuX3VuQmluZCgpO1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fSksXG5cdFx0XHRuZXh0OiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZVJlc3VsdCh0aGlzLl9uZXh0KCkpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlUmVzdWx0OiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdGlmIChpID09PSB1bmRlZmluZWQpIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcblx0XHRcdFx0cmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLl9yZXNvbHZlKGkpIH07XG5cdFx0XHR9KSxcblx0XHRcdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9fbGlzdF9fW2ldO1xuXHRcdFx0fSksXG5cdFx0XHRfdW5CaW5kOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5fX2xpc3RfXyA9IG51bGw7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9fcmVkb19fO1xuXHRcdFx0XHRpZiAoIXRoaXMuX19jb250ZXh0X18pIHJldHVybjtcblx0XHRcdFx0dGhpcy5fX2NvbnRleHRfXy5vZmYoXCJfYWRkXCIsIHRoaXMuX29uQWRkKTtcblx0XHRcdFx0dGhpcy5fX2NvbnRleHRfXy5vZmYoXCJfZGVsZXRlXCIsIHRoaXMuX29uRGVsZXRlKTtcblx0XHRcdFx0dGhpcy5fX2NvbnRleHRfXy5vZmYoXCJfY2xlYXJcIiwgdGhpcy5fb25DbGVhcik7XG5cdFx0XHRcdHRoaXMuX19jb250ZXh0X18gPSBudWxsO1xuXHRcdFx0fSksXG5cdFx0XHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBcIltvYmplY3QgXCIgKyAodGhpc1tTeW1ib2wudG9TdHJpbmdUYWddIHx8IFwiT2JqZWN0XCIpICsgXCJdXCI7XG5cdFx0XHR9KVxuXHRcdH0sXG5cdFx0YXV0b0JpbmQoe1xuXHRcdFx0X29uQWRkOiBkKGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdFx0XHRpZiAoaW5kZXggPj0gdGhpcy5fX25leHRJbmRleF9fKSByZXR1cm47XG5cdFx0XHRcdCsrdGhpcy5fX25leHRJbmRleF9fO1xuXHRcdFx0XHRpZiAoIXRoaXMuX19yZWRvX18pIHtcblx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fcmVkb19fXCIsIGQoXCJjXCIsIFtpbmRleF0pKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fX3JlZG9fXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWRvLCBpKSB7XG5cdFx0XHRcdFx0aWYgKHJlZG8gPj0gaW5kZXgpIHRoaXMuX19yZWRvX19baV0gPSArK3JlZG87XG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9fcmVkb19fLnB1c2goaW5kZXgpO1xuXHRcdFx0fSksXG5cdFx0XHRfb25EZWxldGU6IGQoZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRpZiAoaW5kZXggPj0gdGhpcy5fX25leHRJbmRleF9fKSByZXR1cm47XG5cdFx0XHRcdC0tdGhpcy5fX25leHRJbmRleF9fO1xuXHRcdFx0XHRpZiAoIXRoaXMuX19yZWRvX18pIHJldHVybjtcblx0XHRcdFx0aSA9IHRoaXMuX19yZWRvX18uaW5kZXhPZihpbmRleCk7XG5cdFx0XHRcdGlmIChpICE9PSAtMSkgdGhpcy5fX3JlZG9fXy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdHRoaXMuX19yZWRvX18uZm9yRWFjaChmdW5jdGlvbiAocmVkbywgaikge1xuXHRcdFx0XHRcdGlmIChyZWRvID4gaW5kZXgpIHRoaXMuX19yZWRvX19bal0gPSAtLXJlZG87XG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0fSksXG5cdFx0XHRfb25DbGVhcjogZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVkb19fKSBjbGVhci5jYWxsKHRoaXMuX19yZWRvX18pO1xuXHRcdFx0XHR0aGlzLl9fbmV4dEluZGV4X18gPSAwO1xuXHRcdFx0fSlcblx0XHR9KVxuXHQpXG4pO1xuXG5kZWZpbmVQcm9wZXJ0eShcblx0SXRlcmF0b3IucHJvdG90eXBlLFxuXHRTeW1ib2wuaXRlcmF0b3IsXG5cdGQoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9KVxuKTtcblxufSx7XCJkXCI6MTYsXCJkL2F1dG8tYmluZFwiOjE1LFwiZXM1LWV4dC9hcnJheS8jL2NsZWFyXCI6MTksXCJlczUtZXh0L29iamVjdC9hc3NpZ25cIjozNixcImVzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCI6NTQsXCJlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZVwiOjU1LFwiZXM2LXN5bWJvbFwiOjczfV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoXCJlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGlzVmFsdWUgICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L2lzLXZhbHVlXCIpXG4gICwgaXNTdHJpbmcgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nXCIpO1xuXG52YXIgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKS5pdGVyYXRvclxuICAsIGlzQXJyYXkgICAgICAgID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1ZhbHVlKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoaXNBcnJheSh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAoaXNTdHJpbmcodmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGlzQXJndW1lbnRzKHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiB0eXBlb2YgdmFsdWVbaXRlcmF0b3JTeW1ib2xdID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG59LHtcImVzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzXCI6MjQsXCJlczUtZXh0L29iamVjdC9pcy12YWx1ZVwiOjQ0LFwiZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nXCI6NTksXCJlczYtc3ltYm9sXCI6NzN9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGFua3MgQG1hdGhpYXNieW5lbnNcbi8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSNpdGVyYXRpbmctb3Zlci1zeW1ib2xzXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZShcImRcIilcbiAgLCBTeW1ib2wgICAgICAgICA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKFwiLi9cIik7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgU3RyaW5nSXRlcmF0b3I7XG5cblN0cmluZ0l0ZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJpbmdJdGVyYXRvcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJ1Y3RvciByZXF1aXJlcyAnbmV3J1wiKTtcblx0c3RyID0gU3RyaW5nKHN0cik7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgc3RyKTtcblx0ZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX2xlbmd0aF9fXCIsIGQoXCJcIiwgc3RyLmxlbmd0aCkpO1xufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoU3RyaW5nSXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuLy8gSW50ZXJuYWwgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlIGRvZXNuJ3QgZXhwb3NlIGl0cyBjb25zdHJ1Y3RvclxuZGVsZXRlIFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0X25leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fX2xpc3RfXykgcmV0dXJuIHVuZGVmaW5lZDtcblx0XHRpZiAodGhpcy5fX25leHRJbmRleF9fIDwgdGhpcy5fX2xlbmd0aF9fKSByZXR1cm4gdGhpcy5fX25leHRJbmRleF9fKys7XG5cdFx0dGhpcy5fdW5CaW5kKCk7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fSksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0dmFyIGNoYXIgPSB0aGlzLl9fbGlzdF9fW2ldLCBjb2RlO1xuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPT09IHRoaXMuX19sZW5ndGhfXykgcmV0dXJuIGNoYXI7XG5cdFx0Y29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRpZiAoY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmYpIHJldHVybiBjaGFyICsgdGhpcy5fX2xpc3RfX1t0aGlzLl9fbmV4dEluZGV4X18rK107XG5cdFx0cmV0dXJuIGNoYXI7XG5cdH0pXG59KTtcbmRlZmluZVByb3BlcnR5KFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkKFwiY1wiLCBcIlN0cmluZyBJdGVyYXRvclwiKSk7XG5cbn0se1wiLi9cIjo2MyxcImRcIjoxNixcImVzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIjo1MSxcImVzNi1zeW1ib2xcIjo3M31dLDY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNJdGVyYWJsZSA9IHJlcXVpcmUoXCIuL2lzLWl0ZXJhYmxlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzSXRlcmFibGUodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgXCIgaXMgbm90IGl0ZXJhYmxlXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG59LHtcIi4vaXMtaXRlcmFibGVcIjo2NH1dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKSA/IE1hcCA6IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6NjgsXCIuL3BvbHlmaWxsXCI6NzJ9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbWFwLCBpdGVyYXRvciwgcmVzdWx0O1xuXHRpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHR0cnkge1xuXHRcdC8vIFdlYktpdCBkb2Vzbid0IHN1cHBvcnQgYXJndW1lbnRzIGFuZCBjcmFzaGVzXG5cdFx0bWFwID0gbmV3IE1hcChbWydyYXonLCAnb25lJ10sIFsnZHdhJywgJ3R3byddLCBbJ3RyenknLCAndGhyZWUnXV0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChTdHJpbmcobWFwKSAhPT0gJ1tvYmplY3QgTWFwXScpIHJldHVybiBmYWxzZTtcblx0aWYgKG1hcC5zaXplICE9PSAzKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmNsZWFyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmRlbGV0ZSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5lbnRyaWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZ2V0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmhhcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5rZXlzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLnNldCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC52YWx1ZXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblxuXHRpdGVyYXRvciA9IG1hcC5lbnRyaWVzKCk7XG5cdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0aWYgKHJlc3VsdC5kb25lICE9PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXJlc3VsdC52YWx1ZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAocmVzdWx0LnZhbHVlWzBdICE9PSAncmF6JykgcmV0dXJuIGZhbHNlO1xuXHRpZiAocmVzdWx0LnZhbHVlWzFdICE9PSAnb25lJykgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiB0cnVlO1xufTtcblxufSx7fV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gRXhwb3J0cyB0cnVlIGlmIGVudmlyb25tZW50IHByb3ZpZGVzIG5hdGl2ZSBgTWFwYCBpbXBsZW1lbnRhdGlvbixcbi8vIHdoYXRldmVyIHRoYXQgaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IE1hcCgpKSA9PT0gJ1tvYmplY3QgTWFwXScpO1xufSgpKTtcblxufSx7fV0sNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ByaW1pdGl2ZS1zZXQnKSgna2V5Jyxcblx0J3ZhbHVlJywgJ2tleSt2YWx1ZScpO1xuXG59LHtcImVzNS1leHQvb2JqZWN0L3ByaW1pdGl2ZS1zZXRcIjo1MH1dLDcxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHNldFByb3RvdHlwZU9mICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgZCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBJdGVyYXRvciAgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvcicpXG4gICwgdG9TdHJpbmdUYWdTeW1ib2wgPSByZXF1aXJlKCdlczYtc3ltYm9sJykudG9TdHJpbmdUYWdcbiAgLCBraW5kcyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vaXRlcmF0b3Ita2luZHMnKVxuXG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgdW5CaW5kID0gSXRlcmF0b3IucHJvdG90eXBlLl91bkJpbmRcbiAgLCBNYXBJdGVyYXRvcjtcblxuTWFwSXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXAsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hcEl0ZXJhdG9yKSkgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcihtYXAsIGtpbmQpO1xuXHRJdGVyYXRvci5jYWxsKHRoaXMsIG1hcC5fX21hcEtleXNEYXRhX18sIG1hcCk7XG5cdGlmICgha2luZCB8fCAha2luZHNba2luZF0pIGtpbmQgPSAna2V5K3ZhbHVlJztcblx0ZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG5cdFx0X19raW5kX186IGQoJycsIGtpbmQpLFxuXHRcdF9fdmFsdWVzX186IGQoJ3cnLCBtYXAuX19tYXBWYWx1ZXNEYXRhX18pXG5cdH0pO1xufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoTWFwSXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuTWFwSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoTWFwSXRlcmF0b3IpLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAndmFsdWUnKSByZXR1cm4gdGhpcy5fX3ZhbHVlc19fW2ldO1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSAna2V5JykgcmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0cmV0dXJuIFt0aGlzLl9fbGlzdF9fW2ldLCB0aGlzLl9fdmFsdWVzX19baV1dO1xuXHR9KSxcblx0X3VuQmluZDogZChmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fX3ZhbHVlc19fID0gbnVsbDtcblx0XHR1bkJpbmQuY2FsbCh0aGlzKTtcblx0fSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nOyB9KVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwSXRlcmF0b3IucHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCxcblx0ZCgnYycsICdNYXAgSXRlcmF0b3InKSk7XG5cbn0se1wiLi9pdGVyYXRvci1raW5kc1wiOjcwLFwiZFwiOjE2LFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiOjUxLFwiZXM2LWl0ZXJhdG9yXCI6NjMsXCJlczYtc3ltYm9sXCI6NzN9XSw3MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjbGVhciAgICAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvYXJyYXkvIy9jbGVhcicpXG4gICwgZUluZGV4T2YgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L2FycmF5LyMvZS1pbmRleC1vZicpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBjYWxsYWJsZSAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcbiAgLCB2YWxpZFZhbHVlICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlJylcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIGVlICAgICAgICAgICAgID0gcmVxdWlyZSgnZXZlbnQtZW1pdHRlcicpXG4gICwgU3ltYm9sICAgICAgICAgPSByZXF1aXJlKCdlczYtc3ltYm9sJylcbiAgLCBpdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZScpXG4gICwgZm9yT2YgICAgICAgICAgPSByZXF1aXJlKCdlczYtaXRlcmF0b3IvZm9yLW9mJylcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoJy4vbGliL2l0ZXJhdG9yJylcbiAgLCBpc05hdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vaXMtbmF0aXZlLWltcGxlbWVudGVkJylcblxuICAsIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgLCBNYXBQb2x5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcFBvbHkgPSBmdW5jdGlvbiAoLyppdGVyYWJsZSovKSB7XG5cdHZhciBpdGVyYWJsZSA9IGFyZ3VtZW50c1swXSwga2V5cywgdmFsdWVzLCBzZWxmO1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFwUG9seSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnN0cnVjdG9yIHJlcXVpcmVzIFxcJ25ld1xcJycpO1xuXHRpZiAoaXNOYXRpdmUgJiYgc2V0UHJvdG90eXBlT2YgJiYgKE1hcCAhPT0gTWFwUG9seSkpIHtcblx0XHRzZWxmID0gc2V0UHJvdG90eXBlT2YobmV3IE1hcCgpLCBnZXRQcm90b3R5cGVPZih0aGlzKSk7XG5cdH0gZWxzZSB7XG5cdFx0c2VsZiA9IHRoaXM7XG5cdH1cblx0aWYgKGl0ZXJhYmxlICE9IG51bGwpIGl0ZXJhdG9yKGl0ZXJhYmxlKTtcblx0ZGVmaW5lUHJvcGVydGllcyhzZWxmLCB7XG5cdFx0X19tYXBLZXlzRGF0YV9fOiBkKCdjJywga2V5cyA9IFtdKSxcblx0XHRfX21hcFZhbHVlc0RhdGFfXzogZCgnYycsIHZhbHVlcyA9IFtdKVxuXHR9KTtcblx0aWYgKCFpdGVyYWJsZSkgcmV0dXJuIHNlbGY7XG5cdGZvck9mKGl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR2YXIga2V5ID0gdmFsaWRWYWx1ZSh2YWx1ZSlbMF07XG5cdFx0dmFsdWUgPSB2YWx1ZVsxXTtcblx0XHRpZiAoZUluZGV4T2YuY2FsbChrZXlzLCBrZXkpICE9PSAtMSkgcmV0dXJuO1xuXHRcdGtleXMucHVzaChrZXkpO1xuXHRcdHZhbHVlcy5wdXNoKHZhbHVlKTtcblx0fSwgc2VsZik7XG5cdHJldHVybiBzZWxmO1xufTtcblxuaWYgKGlzTmF0aXZlKSB7XG5cdGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoTWFwUG9seSwgTWFwKTtcblx0TWFwUG9seS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1hcC5wcm90b3R5cGUsIHtcblx0XHRjb25zdHJ1Y3RvcjogZChNYXBQb2x5KVxuXHR9KTtcbn1cblxuZWUoZGVmaW5lUHJvcGVydGllcyhNYXBQb2x5LnByb3RvdHlwZSwge1xuXHRjbGVhcjogZChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9fbWFwS2V5c0RhdGFfXy5sZW5ndGgpIHJldHVybjtcblx0XHRjbGVhci5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fKTtcblx0XHRjbGVhci5jYWxsKHRoaXMuX19tYXBWYWx1ZXNEYXRhX18pO1xuXHRcdHRoaXMuZW1pdCgnX2NsZWFyJyk7XG5cdH0pLFxuXHRkZWxldGU6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSk7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXHRcdHRoaXMuX19tYXBLZXlzRGF0YV9fLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5fX21hcFZhbHVlc0RhdGFfXy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdHRoaXMuZW1pdCgnX2RlbGV0ZScsIGluZGV4LCBrZXkpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9KSxcblx0ZW50cmllczogZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgJ2tleSt2YWx1ZScpOyB9KSxcblx0Zm9yRWFjaDogZChmdW5jdGlvbiAoY2IvKiwgdGhpc0FyZyovKSB7XG5cdFx0dmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV0sIGl0ZXJhdG9yLCByZXN1bHQ7XG5cdFx0Y2FsbGFibGUoY2IpO1xuXHRcdGl0ZXJhdG9yID0gdGhpcy5lbnRyaWVzKCk7XG5cdFx0cmVzdWx0ID0gaXRlcmF0b3IuX25leHQoKTtcblx0XHR3aGlsZSAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdGhpcy5fX21hcFZhbHVlc0RhdGFfX1tyZXN1bHRdLFxuXHRcdFx0XHR0aGlzLl9fbWFwS2V5c0RhdGFfX1tyZXN1bHRdLCB0aGlzKTtcblx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLl9uZXh0KCk7XG5cdFx0fVxuXHR9KSxcblx0Z2V0OiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgaW5kZXggPSBlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpO1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHJldHVybjtcblx0XHRyZXR1cm4gdGhpcy5fX21hcFZhbHVlc0RhdGFfX1tpbmRleF07XG5cdH0pLFxuXHRoYXM6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHJldHVybiAoZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KSAhPT0gLTEpO1xuXHR9KSxcblx0a2V5czogZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgJ2tleScpOyB9KSxcblx0c2V0OiBkKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0dmFyIGluZGV4ID0gZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KSwgZW1pdDtcblx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0XHRpbmRleCA9IHRoaXMuX19tYXBLZXlzRGF0YV9fLnB1c2goa2V5KSAtIDE7XG5cdFx0XHRlbWl0ID0gdHJ1ZTtcblx0XHR9XG5cdFx0dGhpcy5fX21hcFZhbHVlc0RhdGFfX1tpbmRleF0gPSB2YWx1ZTtcblx0XHRpZiAoZW1pdCkgdGhpcy5lbWl0KCdfYWRkJywgaW5kZXgsIGtleSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0pLFxuXHRzaXplOiBkLmdzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19tYXBLZXlzRGF0YV9fLmxlbmd0aDsgfSksXG5cdHZhbHVlczogZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3IodGhpcywgJ3ZhbHVlJyk7IH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBNYXBdJzsgfSlcbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBQb2x5LnByb3RvdHlwZSwgU3ltYm9sLml0ZXJhdG9yLCBkKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZW50cmllcygpO1xufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFBvbHkucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoJ2MnLCAnTWFwJykpO1xuXG59LHtcIi4vaXMtbmF0aXZlLWltcGxlbWVudGVkXCI6NjksXCIuL2xpYi9pdGVyYXRvclwiOjcxLFwiZFwiOjE2LFwiZXM1LWV4dC9hcnJheS8jL2NsZWFyXCI6MTksXCJlczUtZXh0L2FycmF5LyMvZS1pbmRleC1vZlwiOjIwLFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiOjUxLFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIjo1NCxcImVzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlXCI6NTUsXCJlczYtaXRlcmF0b3IvZm9yLW9mXCI6NjEsXCJlczYtaXRlcmF0b3IvdmFsaWQtaXRlcmFibGVcIjo2NixcImVzNi1zeW1ib2xcIjo3MyxcImV2ZW50LWVtaXR0ZXJcIjo3OH1dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2lzLWltcGxlbWVudGVkJykoKSA/IFN5bWJvbCA6IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6NzQsXCIuL3BvbHlmaWxsXCI6NzZ9XSw3NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZFR5cGVzID0geyBvYmplY3Q6IHRydWUsIHN5bWJvbDogdHJ1ZSB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHN5bWJvbDtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0c3ltYm9sID0gU3ltYm9sKCd0ZXN0IHN5bWJvbCcpO1xuXHR0cnkgeyBTdHJpbmcoc3ltYm9sKTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBSZXR1cm4gJ3RydWUnIGFsc28gZm9yIHBvbHlmaWxsc1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC5pdGVyYXRvcl0pIHJldHVybiBmYWxzZTtcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wudG9QcmltaXRpdmVdKSByZXR1cm4gZmFsc2U7XG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnXSkgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiB0cnVlO1xufTtcblxufSx7fV0sNzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdGlmICgheCkgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIHggPT09ICdzeW1ib2wnKSByZXR1cm4gdHJ1ZTtcblx0aWYgKCF4LmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cdGlmICh4LmNvbnN0cnVjdG9yLm5hbWUgIT09ICdTeW1ib2wnKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoeFt4LmNvbnN0cnVjdG9yLnRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCcpO1xufTtcblxufSx7fV0sNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gRVMyMDE1IFN5bWJvbCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IChvciBwYXJ0aWFsbHkpIHN1cHBvcnQgaXRcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCB2YWxpZGF0ZVN5bWJvbCA9IHJlcXVpcmUoJy4vdmFsaWRhdGUtc3ltYm9sJylcblxuICAsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBvYmpQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlXG4gICwgTmF0aXZlU3ltYm9sLCBTeW1ib2xQb2x5ZmlsbCwgSGlkZGVuU3ltYm9sLCBnbG9iYWxTeW1ib2xzID0gY3JlYXRlKG51bGwpXG4gICwgaXNOYXRpdmVTYWZlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHROYXRpdmVTeW1ib2wgPSBTeW1ib2w7XG5cdHRyeSB7XG5cdFx0U3RyaW5nKE5hdGl2ZVN5bWJvbCgpKTtcblx0XHRpc05hdGl2ZVNhZmUgPSB0cnVlO1xuXHR9IGNhdGNoIChpZ25vcmUpIHt9XG59XG5cbnZhciBnZW5lcmF0ZU5hbWUgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgY3JlYXRlZCA9IGNyZWF0ZShudWxsKTtcblx0cmV0dXJuIGZ1bmN0aW9uIChkZXNjKSB7XG5cdFx0dmFyIHBvc3RmaXggPSAwLCBuYW1lLCBpZTExQnVnV29ya2Fyb3VuZDtcblx0XHR3aGlsZSAoY3JlYXRlZFtkZXNjICsgKHBvc3RmaXggfHwgJycpXSkgKytwb3N0Zml4O1xuXHRcdGRlc2MgKz0gKHBvc3RmaXggfHwgJycpO1xuXHRcdGNyZWF0ZWRbZGVzY10gPSB0cnVlO1xuXHRcdG5hbWUgPSAnQEAnICsgZGVzYztcblx0XHRkZWZpbmVQcm9wZXJ0eShvYmpQcm90b3R5cGUsIG5hbWUsIGQuZ3MobnVsbCwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHQvLyBGb3IgSUUxMSBpc3N1ZSBzZWU6XG5cdFx0XHQvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFja2RldGFpbC92aWV3LzE5Mjg1MDgvXG5cdFx0XHQvLyAgICBpZTExLWJyb2tlbi1nZXR0ZXJzLW9uLWRvbS1vYmplY3RzXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWtvby9lczYtc3ltYm9sL2lzc3Vlcy8xMlxuXHRcdFx0aWYgKGllMTFCdWdXb3JrYXJvdW5kKSByZXR1cm47XG5cdFx0XHRpZTExQnVnV29ya2Fyb3VuZCA9IHRydWU7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCBkKHZhbHVlKSk7XG5cdFx0XHRpZTExQnVnV29ya2Fyb3VuZCA9IGZhbHNlO1xuXHRcdH0pKTtcblx0XHRyZXR1cm4gbmFtZTtcblx0fTtcbn0oKSk7XG5cbi8vIEludGVybmFsIGNvbnN0cnVjdG9yIChub3Qgb25lIGV4cG9zZWQpIGZvciBjcmVhdGluZyBTeW1ib2wgaW5zdGFuY2VzLlxuLy8gVGhpcyBvbmUgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBgc29tZVN5bWJvbCBpbnN0YW5jZW9mIFN5bWJvbGAgYWx3YXlzIHJldHVybiBmYWxzZVxuSGlkZGVuU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG5cdGlmICh0aGlzIGluc3RhbmNlb2YgSGlkZGVuU3ltYm9sKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcblx0cmV0dXJuIFN5bWJvbFBvbHlmaWxsKGRlc2NyaXB0aW9uKTtcbn07XG5cbi8vIEV4cG9zZWQgYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIChyZXR1cm5zIGluc3RhbmNlcyBvZiBIaWRkZW5TeW1ib2wpXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbFBvbHlmaWxsID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG5cdHZhciBzeW1ib2w7XG5cdGlmICh0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcblx0aWYgKGlzTmF0aXZlU2FmZSkgcmV0dXJuIE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG5cdHN5bWJvbCA9IGNyZWF0ZShIaWRkZW5TeW1ib2wucHJvdG90eXBlKTtcblx0ZGVzY3JpcHRpb24gPSAoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKGRlc2NyaXB0aW9uKSk7XG5cdHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzKHN5bWJvbCwge1xuXHRcdF9fZGVzY3JpcHRpb25fXzogZCgnJywgZGVzY3JpcHRpb24pLFxuXHRcdF9fbmFtZV9fOiBkKCcnLCBnZW5lcmF0ZU5hbWUoZGVzY3JpcHRpb24pKVxuXHR9KTtcbn07XG5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLCB7XG5cdGZvcjogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0aWYgKGdsb2JhbFN5bWJvbHNba2V5XSkgcmV0dXJuIGdsb2JhbFN5bWJvbHNba2V5XTtcblx0XHRyZXR1cm4gKGdsb2JhbFN5bWJvbHNba2V5XSA9IFN5bWJvbFBvbHlmaWxsKFN0cmluZyhrZXkpKSk7XG5cdH0pLFxuXHRrZXlGb3I6IGQoZnVuY3Rpb24gKHMpIHtcblx0XHR2YXIga2V5O1xuXHRcdHZhbGlkYXRlU3ltYm9sKHMpO1xuXHRcdGZvciAoa2V5IGluIGdsb2JhbFN5bWJvbHMpIGlmIChnbG9iYWxTeW1ib2xzW2tleV0gPT09IHMpIHJldHVybiBrZXk7XG5cdH0pLFxuXG5cdC8vIFRvIGVuc3VyZSBwcm9wZXIgaW50ZXJvcGVyYWJpbGl0eSB3aXRoIG90aGVyIG5hdGl2ZSBmdW5jdGlvbnMgKGUuZy4gQXJyYXkuZnJvbSlcblx0Ly8gZmFsbGJhY2sgdG8gZXZlbnR1YWwgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIGdpdmVuIHN5bWJvbFxuXHRoYXNJbnN0YW5jZTogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaGFzSW5zdGFuY2UpIHx8IFN5bWJvbFBvbHlmaWxsKCdoYXNJbnN0YW5jZScpKSxcblx0aXNDb25jYXRTcHJlYWRhYmxlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUpIHx8XG5cdFx0U3ltYm9sUG9seWZpbGwoJ2lzQ29uY2F0U3ByZWFkYWJsZScpKSxcblx0aXRlcmF0b3I6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLml0ZXJhdG9yKSB8fCBTeW1ib2xQb2x5ZmlsbCgnaXRlcmF0b3InKSksXG5cdG1hdGNoOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5tYXRjaCkgfHwgU3ltYm9sUG9seWZpbGwoJ21hdGNoJykpLFxuXHRyZXBsYWNlOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5yZXBsYWNlKSB8fCBTeW1ib2xQb2x5ZmlsbCgncmVwbGFjZScpKSxcblx0c2VhcmNoOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zZWFyY2gpIHx8IFN5bWJvbFBvbHlmaWxsKCdzZWFyY2gnKSksXG5cdHNwZWNpZXM6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNwZWNpZXMpIHx8IFN5bWJvbFBvbHlmaWxsKCdzcGVjaWVzJykpLFxuXHRzcGxpdDogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc3BsaXQpIHx8IFN5bWJvbFBvbHlmaWxsKCdzcGxpdCcpKSxcblx0dG9QcmltaXRpdmU6IGQoJycsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnRvUHJpbWl0aXZlKSB8fCBTeW1ib2xQb2x5ZmlsbCgndG9QcmltaXRpdmUnKSksXG5cdHRvU3RyaW5nVGFnOiBkKCcnLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC50b1N0cmluZ1RhZykgfHwgU3ltYm9sUG9seWZpbGwoJ3RvU3RyaW5nVGFnJykpLFxuXHR1bnNjb3BhYmxlczogZCgnJywgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudW5zY29wYWJsZXMpIHx8IFN5bWJvbFBvbHlmaWxsKCd1bnNjb3BhYmxlcycpKVxufSk7XG5cbi8vIEludGVybmFsIHR3ZWFrcyBmb3IgcmVhbCBzeW1ib2wgcHJvZHVjZXJcbmRlZmluZVByb3BlcnRpZXMoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChTeW1ib2xQb2x5ZmlsbCksXG5cdHRvU3RyaW5nOiBkKCcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fbmFtZV9fOyB9KVxufSk7XG5cbi8vIFByb3BlciBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGV4cG9zZWQgb24gU3ltYm9sLnByb3RvdHlwZVxuLy8gVGhleSB3b24ndCBiZSBhY2Nlc3NpYmxlIG9uIHByb2R1Y2VkIHN5bWJvbCBpbnN0YW5jZXMgYXMgdGhleSBkZXJpdmUgZnJvbSBIaWRkZW5TeW1ib2wucHJvdG90eXBlXG5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwge1xuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnU3ltYm9sICgnICsgdmFsaWRhdGVTeW1ib2wodGhpcykuX19kZXNjcmlwdGlvbl9fICsgJyknOyB9KSxcblx0dmFsdWVPZjogZChmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZVN5bWJvbCh0aGlzKTsgfSlcbn0pO1xuZGVmaW5lUHJvcGVydHkoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZSwgZCgnJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgc3ltYm9sID0gdmFsaWRhdGVTeW1ib2wodGhpcyk7XG5cdGlmICh0eXBlb2Ygc3ltYm9sID09PSAnc3ltYm9sJykgcmV0dXJuIHN5bWJvbDtcblx0cmV0dXJuIHN5bWJvbC50b1N0cmluZygpO1xufSkpO1xuZGVmaW5lUHJvcGVydHkoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywgZCgnYycsICdTeW1ib2wnKSk7XG5cbi8vIFByb3BlciBpbXBsZW1lbnRhdG9uIG9mIHRvUHJpbWl0aXZlIGFuZCB0b1N0cmluZ1RhZyBmb3IgcmV0dXJuZWQgc3ltYm9sIGluc3RhbmNlc1xuZGVmaW5lUHJvcGVydHkoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsXG5cdGQoJ2MnLCBTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGVbU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWddKSk7XG5cbi8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRvIGRlZmluZSBgdG9QcmltaXRpdmVgIGFzIGxhc3Qgb25lLCBhcyBzb21lIGltcGxlbWVudGF0aW9uc1xuLy8gaW1wbGVtZW50IGB0b1ByaW1pdGl2ZWAgbmF0aXZlbHkgd2l0aG91dCBpbXBsZW1lbnRpbmcgYHRvU3RyaW5nVGFnYCAob3Igb3RoZXIgc3BlY2lmaWVkIHN5bWJvbHMpXG4vLyBBbmQgdGhhdCBtYXkgaW52b2tlIGVycm9yIGluIGRlZmluaXRpb24gZmxvdzpcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlrb28vZXM2LXN5bWJvbC9pc3N1ZXMvMTMjaXNzdWVjb21tZW50LTE2NDE0NjE0OVxuZGVmaW5lUHJvcGVydHkoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmUsXG5cdGQoJ2MnLCBTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGVbU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmVdKSk7XG5cbn0se1wiLi92YWxpZGF0ZS1zeW1ib2xcIjo3NyxcImRcIjoxNn1dLDc3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pcy1zeW1ib2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgYSBzeW1ib2xcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbn0se1wiLi9pcy1zeW1ib2xcIjo3NX1dLDc4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGQgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG5cbiAgLCBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBkZXNjcmlwdG9yID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9XG5cbiAgLCBvbiwgb25jZSwgb2ZmLCBlbWl0LCBtZXRob2RzLCBkZXNjcmlwdG9ycywgYmFzZTtcblxub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGE7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHtcblx0XHRkYXRhID0gZGVzY3JpcHRvci52YWx1ZSA9IGNyZWF0ZShudWxsKTtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX19lZV9fJywgZGVzY3JpcHRvcik7XG5cdFx0ZGVzY3JpcHRvci52YWx1ZSA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHR9XG5cdGlmICghZGF0YVt0eXBlXSkgZGF0YVt0eXBlXSA9IGxpc3RlbmVyO1xuXHRlbHNlIGlmICh0eXBlb2YgZGF0YVt0eXBlXSA9PT0gJ29iamVjdCcpIGRhdGFbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG5cdGVsc2UgZGF0YVt0eXBlXSA9IFtkYXRhW3R5cGVdLCBsaXN0ZW5lcl07XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBvbmNlLCBzZWxmO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblx0c2VsZiA9IHRoaXM7XG5cdG9uLmNhbGwodGhpcywgdHlwZSwgb25jZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRvZmYuY2FsbChzZWxmLCB0eXBlLCBvbmNlKTtcblx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmd1bWVudHMpO1xuXHR9KTtcblxuXHRvbmNlLl9fZWVPbmNlTGlzdGVuZXJfXyA9IGxpc3RlbmVyO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YSwgbGlzdGVuZXJzLCBjYW5kaWRhdGUsIGk7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybiB0aGlzO1xuXHRkYXRhID0gdGhpcy5fX2VlX187XG5cdGlmICghZGF0YVt0eXBlXSkgcmV0dXJuIHRoaXM7XG5cdGxpc3RlbmVycyA9IGRhdGFbdHlwZV07XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0Zm9yIChpID0gMDsgKGNhbmRpZGF0ZSA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0aWYgKChjYW5kaWRhdGUgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHRcdChjYW5kaWRhdGUuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDIpIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcnNbaSA/IDAgOiAxXTtcblx0XHRcdFx0ZWxzZSBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoKGxpc3RlbmVycyA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdChsaXN0ZW5lcnMuX19lZU9uY2VMaXN0ZW5lcl9fID09PSBsaXN0ZW5lcikpIHtcblx0XHRcdGRlbGV0ZSBkYXRhW3R5cGVdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdHZhciBpLCBsLCBsaXN0ZW5lciwgbGlzdGVuZXJzLCBhcmdzO1xuXG5cdGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX19lZV9fJykpIHJldHVybjtcblx0bGlzdGVuZXJzID0gdGhpcy5fX2VlX19bdHlwZV07XG5cdGlmICghbGlzdGVuZXJzKSByZXR1cm47XG5cblx0aWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdvYmplY3QnKSB7XG5cdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cblx0XHRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblx0XHRmb3IgKGkgPSAwOyAobGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0bCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0YXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9XG59O1xuXG5tZXRob2RzID0ge1xuXHRvbjogb24sXG5cdG9uY2U6IG9uY2UsXG5cdG9mZjogb2ZmLFxuXHRlbWl0OiBlbWl0XG59O1xuXG5kZXNjcmlwdG9ycyA9IHtcblx0b246IGQob24pLFxuXHRvbmNlOiBkKG9uY2UpLFxuXHRvZmY6IGQob2ZmKSxcblx0ZW1pdDogZChlbWl0KVxufTtcblxuYmFzZSA9IGRlZmluZVByb3BlcnRpZXMoe30sIGRlc2NyaXB0b3JzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gKG8pIHtcblx0cmV0dXJuIChvID09IG51bGwpID8gY3JlYXRlKGJhc2UpIDogZGVmaW5lUHJvcGVydGllcyhPYmplY3QobyksIGRlc2NyaXB0b3JzKTtcbn07XG5leHBvcnRzLm1ldGhvZHMgPSBtZXRob2RzO1xuXG59LHtcImRcIjoxNixcImVzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCI6NTR9XSw3OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cbn0se31dLDgwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59LHt9XSw4MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cblxufSx7fV0sODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vKiBQcm90b2NvbCAtIHByb3RvY29sIGNvbnN0YW50cyAqL1xudmFyIHByb3RvY29sID0gbW9kdWxlLmV4cG9ydHNcblxuLyogQ29tbWFuZCBjb2RlID0+IG1uZW1vbmljICovXG5wcm90b2NvbC50eXBlcyA9IHtcbiAgMDogJ3Jlc2VydmVkJyxcbiAgMTogJ2Nvbm5lY3QnLFxuICAyOiAnY29ubmFjaycsXG4gIDM6ICdwdWJsaXNoJyxcbiAgNDogJ3B1YmFjaycsXG4gIDU6ICdwdWJyZWMnLFxuICA2OiAncHVicmVsJyxcbiAgNzogJ3B1YmNvbXAnLFxuICA4OiAnc3Vic2NyaWJlJyxcbiAgOTogJ3N1YmFjaycsXG4gIDEwOiAndW5zdWJzY3JpYmUnLFxuICAxMTogJ3Vuc3ViYWNrJyxcbiAgMTI6ICdwaW5ncmVxJyxcbiAgMTM6ICdwaW5ncmVzcCcsXG4gIDE0OiAnZGlzY29ubmVjdCcsXG4gIDE1OiAnYXV0aCdcbn1cblxuLyogTW5lbW9uaWMgPT4gQ29tbWFuZCBjb2RlICovXG5wcm90b2NvbC5jb2RlcyA9IHt9XG5mb3IgKHZhciBrIGluIHByb3RvY29sLnR5cGVzKSB7XG4gIHZhciB2ID0gcHJvdG9jb2wudHlwZXNba11cbiAgcHJvdG9jb2wuY29kZXNbdl0gPSBrXG59XG5cbi8qIEhlYWRlciAqL1xucHJvdG9jb2wuQ01EX1NISUZUID0gNFxucHJvdG9jb2wuQ01EX01BU0sgPSAweEYwXG5wcm90b2NvbC5EVVBfTUFTSyA9IDB4MDhcbnByb3RvY29sLlFPU19NQVNLID0gMHgwM1xucHJvdG9jb2wuUU9TX1NISUZUID0gMVxucHJvdG9jb2wuUkVUQUlOX01BU0sgPSAweDAxXG5cbi8qIExlbmd0aCAqL1xucHJvdG9jb2wuTEVOR1RIX01BU0sgPSAweDdGXG5wcm90b2NvbC5MRU5HVEhfRklOX01BU0sgPSAweDgwXG5cbi8qIENvbm5hY2sgKi9cbnByb3RvY29sLlNFU1NJT05QUkVTRU5UX01BU0sgPSAweDAxXG5wcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9IRUFERVIgPSBCdWZmZXIuZnJvbShbcHJvdG9jb2wuU0VTU0lPTlBSRVNFTlRfTUFTS10pXG5wcm90b2NvbC5DT05OQUNLX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snY29ubmFjayddIDw8IHByb3RvY29sLkNNRF9TSElGVF0pXG5cbi8qIENvbm5lY3QgKi9cbnByb3RvY29sLlVTRVJOQU1FX01BU0sgPSAweDgwXG5wcm90b2NvbC5QQVNTV09SRF9NQVNLID0gMHg0MFxucHJvdG9jb2wuV0lMTF9SRVRBSU5fTUFTSyA9IDB4MjBcbnByb3RvY29sLldJTExfUU9TX01BU0sgPSAweDE4XG5wcm90b2NvbC5XSUxMX1FPU19TSElGVCA9IDNcbnByb3RvY29sLldJTExfRkxBR19NQVNLID0gMHgwNFxucHJvdG9jb2wuQ0xFQU5fU0VTU0lPTl9NQVNLID0gMHgwMlxucHJvdG9jb2wuQ09OTkVDVF9IRUFERVIgPSBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ2Nvbm5lY3QnXSA8PCBwcm90b2NvbC5DTURfU0hJRlRdKVxuXG4vKiBQcm9wZXJ0aWVzICovXG5wcm90b2NvbC5wcm9wZXJ0aWVzID0ge1xuICBzZXNzaW9uRXhwaXJ5SW50ZXJ2YWw6IDE3LFxuICB3aWxsRGVsYXlJbnRlcnZhbDogMjQsXG4gIHJlY2VpdmVNYXhpbXVtOiAzMyxcbiAgbWF4aW11bVBhY2tldFNpemU6IDM5LFxuICB0b3BpY0FsaWFzTWF4aW11bTogMzQsXG4gIHJlcXVlc3RSZXNwb25zZUluZm9ybWF0aW9uOiAyNSxcbiAgcmVxdWVzdFByb2JsZW1JbmZvcm1hdGlvbjogMjMsXG4gIHVzZXJQcm9wZXJ0aWVzOiAzOCxcbiAgYXV0aGVudGljYXRpb25NZXRob2Q6IDIxLFxuICBhdXRoZW50aWNhdGlvbkRhdGE6IDIyLFxuICBwYXlsb2FkRm9ybWF0SW5kaWNhdG9yOiAxLFxuICBtZXNzYWdlRXhwaXJ5SW50ZXJ2YWw6IDIsXG4gIGNvbnRlbnRUeXBlOiAzLFxuICByZXNwb25zZVRvcGljOiA4LFxuICBjb3JyZWxhdGlvbkRhdGE6IDksXG4gIG1heGltdW1Rb1M6IDM2LFxuICByZXRhaW5BdmFpbGFibGU6IDM3LFxuICBhc3NpZ25lZENsaWVudElkZW50aWZpZXI6IDE4LFxuICByZWFzb25TdHJpbmc6IDMxLFxuICB3aWxkY2FyZFN1YnNjcmlwdGlvbkF2YWlsYWJsZTogNDAsXG4gIHN1YnNjcmlwdGlvbklkZW50aWZpZXJzQXZhaWxhYmxlOiA0MSxcbiAgc2hhcmVkU3Vic2NyaXB0aW9uQXZhaWxhYmxlOiA0MixcbiAgc2VydmVyS2VlcEFsaXZlOiAxOSxcbiAgcmVzcG9uc2VJbmZvcm1hdGlvbjogMjYsXG4gIHNlcnZlclJlZmVyZW5jZTogMjgsXG4gIHRvcGljQWxpYXM6IDM1LFxuICBzdWJzY3JpcHRpb25JZGVudGlmaWVyOiAxMVxufVxucHJvdG9jb2wucHJvcGVydGllc0NvZGVzID0ge31cbmZvciAodmFyIHByb3AgaW4gcHJvdG9jb2wucHJvcGVydGllcykge1xuICB2YXIgaWQgPSBwcm90b2NvbC5wcm9wZXJ0aWVzW3Byb3BdXG4gIHByb3RvY29sLnByb3BlcnRpZXNDb2Rlc1tpZF0gPSBwcm9wXG59XG5wcm90b2NvbC5wcm9wZXJ0aWVzVHlwZXMgPSB7XG4gIHNlc3Npb25FeHBpcnlJbnRlcnZhbDogJ2ludDMyJyxcbiAgd2lsbERlbGF5SW50ZXJ2YWw6ICdpbnQzMicsXG4gIHJlY2VpdmVNYXhpbXVtOiAnaW50MTYnLFxuICBtYXhpbXVtUGFja2V0U2l6ZTogJ2ludDMyJyxcbiAgdG9waWNBbGlhc01heGltdW06ICdpbnQxNicsXG4gIHJlcXVlc3RSZXNwb25zZUluZm9ybWF0aW9uOiAnYnl0ZScsXG4gIHJlcXVlc3RQcm9ibGVtSW5mb3JtYXRpb246ICdieXRlJyxcbiAgdXNlclByb3BlcnRpZXM6ICdwYWlyJyxcbiAgYXV0aGVudGljYXRpb25NZXRob2Q6ICdzdHJpbmcnLFxuICBhdXRoZW50aWNhdGlvbkRhdGE6ICdiaW5hcnknLFxuICBwYXlsb2FkRm9ybWF0SW5kaWNhdG9yOiAnYnl0ZScsXG4gIG1lc3NhZ2VFeHBpcnlJbnRlcnZhbDogJ2ludDMyJyxcbiAgY29udGVudFR5cGU6ICdzdHJpbmcnLFxuICByZXNwb25zZVRvcGljOiAnc3RyaW5nJyxcbiAgY29ycmVsYXRpb25EYXRhOiAnYmluYXJ5JyxcbiAgbWF4aW11bVFvUzogJ2ludDgnLFxuICByZXRhaW5BdmFpbGFibGU6ICdieXRlJyxcbiAgYXNzaWduZWRDbGllbnRJZGVudGlmaWVyOiAnc3RyaW5nJyxcbiAgcmVhc29uU3RyaW5nOiAnc3RyaW5nJyxcbiAgd2lsZGNhcmRTdWJzY3JpcHRpb25BdmFpbGFibGU6ICdieXRlJyxcbiAgc3Vic2NyaXB0aW9uSWRlbnRpZmllcnNBdmFpbGFibGU6ICdieXRlJyxcbiAgc2hhcmVkU3Vic2NyaXB0aW9uQXZhaWxhYmxlOiAnYnl0ZScsXG4gIHNlcnZlcktlZXBBbGl2ZTogJ2ludDMyJyxcbiAgcmVzcG9uc2VJbmZvcm1hdGlvbjogJ3N0cmluZycsXG4gIHNlcnZlclJlZmVyZW5jZTogJ3N0cmluZycsXG4gIHRvcGljQWxpYXM6ICdpbnQxNicsXG4gIHN1YnNjcmlwdGlvbklkZW50aWZpZXI6ICd2YXInXG59XG5cbmZ1bmN0aW9uIGdlbkhlYWRlciAodHlwZSkge1xuICByZXR1cm4gWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAocW9zKSB7XG4gICAgcmV0dXJuIFswLCAxXS5tYXAoZnVuY3Rpb24gKGR1cCkge1xuICAgICAgcmV0dXJuIFswLCAxXS5tYXAoZnVuY3Rpb24gKHJldGFpbikge1xuICAgICAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxKVxuICAgICAgICBidWYud3JpdGVVSW50OChcbiAgICAgICAgICBwcm90b2NvbC5jb2Rlc1t0eXBlXSA8PCBwcm90b2NvbC5DTURfU0hJRlQgfFxuICAgICAgICAgIChkdXAgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDApIHxcbiAgICAgICAgICBxb3MgPDwgcHJvdG9jb2wuUU9TX1NISUZUIHwgcmV0YWluLCAwLCB0cnVlKVxuICAgICAgICByZXR1cm4gYnVmXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8qIFB1Ymxpc2ggKi9cbnByb3RvY29sLlBVQkxJU0hfSEVBREVSID0gZ2VuSGVhZGVyKCdwdWJsaXNoJylcblxuLyogU3Vic2NyaWJlICovXG5wcm90b2NvbC5TVUJTQ1JJQkVfSEVBREVSID0gZ2VuSGVhZGVyKCdzdWJzY3JpYmUnKVxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUU9TX01BU0sgPSAweDAzXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19OTF9NQVNLID0gMHgwMVxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfTkxfU0hJRlQgPSAyXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19SQVBfTUFTSyA9IDB4MDFcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JBUF9TSElGVCA9IDNcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JIX01BU0sgPSAweDAzXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19SSF9TSElGVCA9IDRcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JIID0gWzB4MDAsIDB4MTAsIDB4MjBdXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19OTCA9IDB4MDRcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JBUCA9IDB4MDhcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1FPUyA9IFsweDAwLCAweDAxLCAweDAyXVxuXG4vKiBVbnN1YnNjcmliZSAqL1xucHJvdG9jb2wuVU5TVUJTQ1JJQkVfSEVBREVSID0gZ2VuSGVhZGVyKCd1bnN1YnNjcmliZScpXG5cbi8qIENvbmZpcm1hdGlvbnMgKi9cbnByb3RvY29sLkFDS1MgPSB7XG4gIHVuc3ViYWNrOiBnZW5IZWFkZXIoJ3Vuc3ViYWNrJyksXG4gIHB1YmFjazogZ2VuSGVhZGVyKCdwdWJhY2snKSxcbiAgcHViY29tcDogZ2VuSGVhZGVyKCdwdWJjb21wJyksXG4gIHB1YnJlbDogZ2VuSGVhZGVyKCdwdWJyZWwnKSxcbiAgcHVicmVjOiBnZW5IZWFkZXIoJ3B1YnJlYycpXG59XG5cbnByb3RvY29sLlNVQkFDS19IRUFERVIgPSBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ3N1YmFjayddIDw8IHByb3RvY29sLkNNRF9TSElGVF0pXG5cbi8qIFByb3RvY29sIHZlcnNpb25zICovXG5wcm90b2NvbC5WRVJTSU9OMyA9IEJ1ZmZlci5mcm9tKFszXSlcbnByb3RvY29sLlZFUlNJT040ID0gQnVmZmVyLmZyb20oWzRdKVxucHJvdG9jb2wuVkVSU0lPTjUgPSBCdWZmZXIuZnJvbShbNV0pXG5cbi8qIFFvUyAqL1xucHJvdG9jb2wuUU9TID0gWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAocW9zKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShbcW9zXSlcbn0pXG5cbi8qIEVtcHR5IHBhY2tldHMgKi9cbnByb3RvY29sLkVNUFRZID0ge1xuICBwaW5ncmVxOiBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ3BpbmdyZXEnXSA8PCA0LCAwXSksXG4gIHBpbmdyZXNwOiBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ3BpbmdyZXNwJ10gPDwgNCwgMF0pLFxuICBkaXNjb25uZWN0OiBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ2Rpc2Nvbm5lY3QnXSA8PCA0LCAwXSlcbn1cblxufSx7XCJzYWZlLWJ1ZmZlclwiOjExMH1dLDgzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciB3cml0ZVRvU3RyZWFtID0gcmVxdWlyZSgnLi93cml0ZVRvU3RyZWFtJylcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAocGFja2V0LCBvcHRzKSB7XG4gIHZhciBzdHJlYW0gPSBuZXcgQWNjdW11bGF0b3IoKVxuICB3cml0ZVRvU3RyZWFtKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICByZXR1cm4gc3RyZWFtLmNvbmNhdCgpXG59XG5cbmZ1bmN0aW9uIEFjY3VtdWxhdG9yICgpIHtcbiAgdGhpcy5fYXJyYXkgPSBuZXcgQXJyYXkoMjApXG4gIHRoaXMuX2kgPSAwXG59XG5cbmluaGVyaXRzKEFjY3VtdWxhdG9yLCBFRSlcblxuQWNjdW11bGF0b3IucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuX2FycmF5W3RoaXMuX2krK10gPSBjaHVua1xuICByZXR1cm4gdHJ1ZVxufVxuXG5BY2N1bXVsYXRvci5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gMFxuICB2YXIgbGVuZ3RocyA9IG5ldyBBcnJheSh0aGlzLl9hcnJheS5sZW5ndGgpXG4gIHZhciBsaXN0ID0gdGhpcy5fYXJyYXlcbiAgdmFyIHBvcyA9IDBcbiAgdmFyIGlcbiAgdmFyIHJlc3VsdFxuXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aCAmJiBsaXN0W2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgIGlmICh0eXBlb2YgbGlzdFtpXSAhPT0gJ3N0cmluZycpIGxlbmd0aHNbaV0gPSBsaXN0W2ldLmxlbmd0aFxuICAgIGVsc2UgbGVuZ3Roc1tpXSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGxpc3RbaV0pXG5cbiAgICBsZW5ndGggKz0gbGVuZ3Roc1tpXVxuICB9XG5cbiAgcmVzdWx0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcblxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGggJiYgbGlzdFtpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIGxpc3RbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBsaXN0W2ldLmNvcHkocmVzdWx0LCBwb3MpXG4gICAgICBwb3MgKz0gbGVuZ3Roc1tpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQud3JpdGUobGlzdFtpXSwgcG9zKVxuICAgICAgcG9zICs9IGxlbmd0aHNbaV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVcblxufSx7XCIuL3dyaXRlVG9TdHJlYW1cIjo4OSxcImV2ZW50c1wiOjEzLFwiaW5oZXJpdHNcIjo4MCxcInNhZmUtYnVmZmVyXCI6MTEwfV0sODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKVxuZXhwb3J0cy5nZW5lcmF0ZSA9IHJlcXVpcmUoJy4vZ2VuZXJhdGUnKVxuZXhwb3J0cy53cml0ZVRvU3RyZWFtID0gcmVxdWlyZSgnLi93cml0ZVRvU3RyZWFtJylcblxufSx7XCIuL2dlbmVyYXRlXCI6ODMsXCIuL3BhcnNlclwiOjg4LFwiLi93cml0ZVRvU3RyZWFtXCI6ODl9XSw4NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRHVwbGV4U3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleCcpXG4gICwgdXRpbCAgICAgICAgID0gcmVxdWlyZSgndXRpbCcpXG4gICwgQnVmZmVyICAgICAgID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuXG5mdW5jdGlvbiBCdWZmZXJMaXN0IChjYWxsYmFjaykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyTGlzdCkpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0KGNhbGxiYWNrKVxuXG4gIHRoaXMuX2J1ZnMgID0gW11cbiAgdGhpcy5sZW5ndGggPSAwXG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFja1xuXG4gICAgdmFyIHBpcGVyID0gZnVuY3Rpb24gcGlwZXIgKGVycikge1xuICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKGVycilcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLm9uKCdwaXBlJywgZnVuY3Rpb24gb25QaXBlIChzcmMpIHtcbiAgICAgIHNyYy5vbignZXJyb3InLCBwaXBlcilcbiAgICB9KVxuICAgIHRoaXMub24oJ3VucGlwZScsIGZ1bmN0aW9uIG9uVW5waXBlIChzcmMpIHtcbiAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBwaXBlcilcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYXBwZW5kKGNhbGxiYWNrKVxuICB9XG5cbiAgRHVwbGV4U3RyZWFtLmNhbGwodGhpcylcbn1cblxuXG51dGlsLmluaGVyaXRzKEJ1ZmZlckxpc3QsIER1cGxleFN0cmVhbSlcblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fb2Zmc2V0ID0gZnVuY3Rpb24gX29mZnNldCAob2Zmc2V0KSB7XG4gIHZhciB0b3QgPSAwLCBpID0gMCwgX3RcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIFsgMCwgMCBdXG4gIGZvciAoOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIF90ID0gdG90ICsgdGhpcy5fYnVmc1tpXS5sZW5ndGhcbiAgICBpZiAob2Zmc2V0IDwgX3QgfHwgaSA9PSB0aGlzLl9idWZzLmxlbmd0aCAtIDEpXG4gICAgICByZXR1cm4gWyBpLCBvZmZzZXQgLSB0b3QgXVxuICAgIHRvdCA9IF90XG4gIH1cbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKGJ1Zikge1xuICB2YXIgaSA9IDBcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICB0aGlzLl9hcHBlbmRCdWZmZXIoYnVmKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJ1ZikpIHtcbiAgICBmb3IgKDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuYXBwZW5kKGJ1ZltpXSlcbiAgfSBlbHNlIGlmIChidWYgaW5zdGFuY2VvZiBCdWZmZXJMaXN0KSB7XG4gICAgLy8gdW53cmFwIGFyZ3VtZW50IGludG8gaW5kaXZpZHVhbCBCdWZmZXJMaXN0c1xuICAgIGZvciAoOyBpIDwgYnVmLl9idWZzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5hcHBlbmQoYnVmLl9idWZzW2ldKVxuICB9IGVsc2UgaWYgKGJ1ZiAhPSBudWxsKSB7XG4gICAgLy8gY29lcmNlIG51bWJlciBhcmd1bWVudHMgdG8gc3RyaW5ncywgc2luY2UgQnVmZmVyKG51bWJlcikgZG9lc1xuICAgIC8vIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IGFsbG9jYXRpb25cbiAgICBpZiAodHlwZW9mIGJ1ZiA9PSAnbnVtYmVyJylcbiAgICAgIGJ1ZiA9IGJ1Zi50b1N0cmluZygpXG5cbiAgICB0aGlzLl9hcHBlbmRCdWZmZXIoQnVmZmVyLmZyb20oYnVmKSk7XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9hcHBlbmRCdWZmZXIgPSBmdW5jdGlvbiBhcHBlbmRCdWZmZXIgKGJ1Zikge1xuICB0aGlzLl9idWZzLnB1c2goYnVmKVxuICB0aGlzLmxlbmd0aCArPSBidWYubGVuZ3RoXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlIChidWYsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB0aGlzLl9hcHBlbmRCdWZmZXIoYnVmKVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJylcbiAgICBjYWxsYmFjaygpXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiBfcmVhZCAoc2l6ZSkge1xuICBpZiAoIXRoaXMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLnB1c2gobnVsbClcblxuICBzaXplID0gTWF0aC5taW4oc2l6ZSwgdGhpcy5sZW5ndGgpXG4gIHRoaXMucHVzaCh0aGlzLnNsaWNlKDAsIHNpemUpKVxuICB0aGlzLmNvbnN1bWUoc2l6ZSlcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQgKGNodW5rKSB7XG4gIER1cGxleFN0cmVhbS5wcm90b3R5cGUuZW5kLmNhbGwodGhpcywgY2h1bmspXG5cbiAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sobnVsbCwgdGhpcy5zbGljZSgpKVxuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuICB9XG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCkge1xuICByZXR1cm4gdGhpcy5zbGljZShpbmRleCwgaW5kZXggKyAxKVswXVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAnbnVtYmVyJyAmJiBzdGFydCA8IDApXG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ251bWJlcicgJiYgZW5kIDwgMClcbiAgICBlbmQgKz0gdGhpcy5sZW5ndGhcbiAgcmV0dXJuIHRoaXMuY29weShudWxsLCAwLCBzdGFydCwgZW5kKVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkc3QsIGRzdFN0YXJ0LCBzcmNTdGFydCwgc3JjRW5kKSB7XG4gIGlmICh0eXBlb2Ygc3JjU3RhcnQgIT0gJ251bWJlcicgfHwgc3JjU3RhcnQgPCAwKVxuICAgIHNyY1N0YXJ0ID0gMFxuICBpZiAodHlwZW9mIHNyY0VuZCAhPSAnbnVtYmVyJyB8fCBzcmNFbmQgPiB0aGlzLmxlbmd0aClcbiAgICBzcmNFbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoc3JjU3RhcnQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuIGRzdCB8fCBCdWZmZXIuYWxsb2MoMClcbiAgaWYgKHNyY0VuZCA8PSAwKVxuICAgIHJldHVybiBkc3QgfHwgQnVmZmVyLmFsbG9jKDApXG5cbiAgdmFyIGNvcHkgICA9ICEhZHN0XG4gICAgLCBvZmYgICAgPSB0aGlzLl9vZmZzZXQoc3JjU3RhcnQpXG4gICAgLCBsZW4gICAgPSBzcmNFbmQgLSBzcmNTdGFydFxuICAgICwgYnl0ZXMgID0gbGVuXG4gICAgLCBidWZvZmYgPSAoY29weSAmJiBkc3RTdGFydCkgfHwgMFxuICAgICwgc3RhcnQgID0gb2ZmWzFdXG4gICAgLCBsXG4gICAgLCBpXG5cbiAgLy8gY29weS9zbGljZSBldmVyeXRoaW5nXG4gIGlmIChzcmNTdGFydCA9PT0gMCAmJiBzcmNFbmQgPT0gdGhpcy5sZW5ndGgpIHtcbiAgICBpZiAoIWNvcHkpIHsgLy8gc2xpY2UsIGJ1dCBmdWxsIGNvbmNhdCBpZiBtdWx0aXBsZSBidWZmZXJzXG4gICAgICByZXR1cm4gdGhpcy5fYnVmcy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB0aGlzLl9idWZzWzBdXG4gICAgICAgIDogQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZzLCB0aGlzLmxlbmd0aClcbiAgICB9XG5cbiAgICAvLyBjb3B5LCBuZWVkIHRvIGNvcHkgaW5kaXZpZHVhbCBidWZmZXJzXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2J1ZnNbaV0uY29weShkc3QsIGJ1Zm9mZilcbiAgICAgIGJ1Zm9mZiArPSB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiBkc3RcbiAgfVxuXG4gIC8vIGVhc3ksIGNoZWFwIGNhc2Ugd2hlcmUgaXQncyBhIHN1YnNldCBvZiBvbmUgb2YgdGhlIGJ1ZmZlcnNcbiAgaWYgKGJ5dGVzIDw9IHRoaXMuX2J1ZnNbb2ZmWzBdXS5sZW5ndGggLSBzdGFydCkge1xuICAgIHJldHVybiBjb3B5XG4gICAgICA/IHRoaXMuX2J1ZnNbb2ZmWzBdXS5jb3B5KGRzdCwgZHN0U3RhcnQsIHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICAgICAgOiB0aGlzLl9idWZzW29mZlswXV0uc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gIH1cblxuICBpZiAoIWNvcHkpIC8vIGEgc2xpY2UsIHdlIG5lZWQgc29tZXRoaW5nIHRvIGNvcHkgaW4gdG9cbiAgICBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuXG4gIGZvciAoaSA9IG9mZlswXTsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBsID0gdGhpcy5fYnVmc1tpXS5sZW5ndGggLSBzdGFydFxuXG4gICAgaWYgKGJ5dGVzID4gbCkge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmLCBzdGFydClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmLCBzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgYnVmb2ZmICs9IGxcbiAgICBieXRlcyAtPSBsXG5cbiAgICBpZiAoc3RhcnQpXG4gICAgICBzdGFydCA9IDBcbiAgfVxuXG4gIHJldHVybiBkc3Rcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hhbGxvd1NsaWNlID0gZnVuY3Rpb24gc2hhbGxvd1NsaWNlIChzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMFxuICBlbmQgPSBlbmQgfHwgdGhpcy5sZW5ndGhcblxuICBpZiAoc3RhcnQgPCAwKVxuICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPCAwKVxuICAgIGVuZCArPSB0aGlzLmxlbmd0aFxuXG4gIHZhciBzdGFydE9mZnNldCA9IHRoaXMuX29mZnNldChzdGFydClcbiAgICAsIGVuZE9mZnNldCA9IHRoaXMuX29mZnNldChlbmQpXG4gICAgLCBidWZmZXJzID0gdGhpcy5fYnVmcy5zbGljZShzdGFydE9mZnNldFswXSwgZW5kT2Zmc2V0WzBdICsgMSlcblxuICBpZiAoZW5kT2Zmc2V0WzFdID09IDApXG4gICAgYnVmZmVycy5wb3AoKVxuICBlbHNlXG4gICAgYnVmZmVyc1tidWZmZXJzLmxlbmd0aC0xXSA9IGJ1ZmZlcnNbYnVmZmVycy5sZW5ndGgtMV0uc2xpY2UoMCwgZW5kT2Zmc2V0WzFdKVxuXG4gIGlmIChzdGFydE9mZnNldFsxXSAhPSAwKVxuICAgIGJ1ZmZlcnNbMF0gPSBidWZmZXJzWzBdLnNsaWNlKHN0YXJ0T2Zmc2V0WzFdKVxuXG4gIHJldHVybiBuZXcgQnVmZmVyTGlzdChidWZmZXJzKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZylcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIGNvbnN1bWUgKGJ5dGVzKSB7XG4gIHdoaWxlICh0aGlzLl9idWZzLmxlbmd0aCkge1xuICAgIGlmIChieXRlcyA+PSB0aGlzLl9idWZzWzBdLmxlbmd0aCkge1xuICAgICAgYnl0ZXMgLT0gdGhpcy5fYnVmc1swXS5sZW5ndGhcbiAgICAgIHRoaXMubGVuZ3RoIC09IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoXG4gICAgICB0aGlzLl9idWZzLnNoaWZ0KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmc1swXSA9IHRoaXMuX2J1ZnNbMF0uc2xpY2UoYnl0ZXMpXG4gICAgICB0aGlzLmxlbmd0aCAtPSBieXRlc1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbiBkdXBsaWNhdGUgKCkge1xuICB2YXIgaSA9IDBcbiAgICAsIGNvcHkgPSBuZXcgQnVmZmVyTGlzdCgpXG5cbiAgZm9yICg7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKVxuICAgIGNvcHkuYXBwZW5kKHRoaXMuX2J1ZnNbaV0pXG5cbiAgcmV0dXJuIGNvcHlcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHRoaXMuX2J1ZnMubGVuZ3RoID0gMFxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5wdXNoKG51bGwpXG59XG5cblxuOyhmdW5jdGlvbiAoKSB7XG4gIHZhciBtZXRob2RzID0ge1xuICAgICAgJ3JlYWREb3VibGVCRScgOiA4XG4gICAgLCAncmVhZERvdWJsZUxFJyA6IDhcbiAgICAsICdyZWFkRmxvYXRCRScgIDogNFxuICAgICwgJ3JlYWRGbG9hdExFJyAgOiA0XG4gICAgLCAncmVhZEludDMyQkUnICA6IDRcbiAgICAsICdyZWFkSW50MzJMRScgIDogNFxuICAgICwgJ3JlYWRVSW50MzJCRScgOiA0XG4gICAgLCAncmVhZFVJbnQzMkxFJyA6IDRcbiAgICAsICdyZWFkSW50MTZCRScgIDogMlxuICAgICwgJ3JlYWRJbnQxNkxFJyAgOiAyXG4gICAgLCAncmVhZFVJbnQxNkJFJyA6IDJcbiAgICAsICdyZWFkVUludDE2TEUnIDogMlxuICAgICwgJ3JlYWRJbnQ4JyAgICAgOiAxXG4gICAgLCAncmVhZFVJbnQ4JyAgICA6IDFcbiAgfVxuXG4gIGZvciAodmFyIG0gaW4gbWV0aG9kcykge1xuICAgIChmdW5jdGlvbiAobSkge1xuICAgICAgQnVmZmVyTGlzdC5wcm90b3R5cGVbbV0gPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbWV0aG9kc1ttXSlbbV0oMClcbiAgICAgIH1cbiAgICB9KG0pKVxuICB9XG59KCkpXG5cblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0XG5cbn0se1wicmVhZGFibGUtc3RyZWFtL2R1cGxleFwiOjk3LFwic2FmZS1idWZmZXJcIjoxMTAsXCJ1dGlsXCI6MTE3fV0sODY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIG1heCA9IDY1NTM2XG52YXIgY2FjaGUgPSB7fVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJ1ZmZlciAoaSkge1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gIGJ1ZmZlci53cml0ZVVJbnQ4KGkgPj4gOCwgMClcbiAgYnVmZmVyLndyaXRlVUludDgoaSAmIDB4MDBGRiwgMCArIDEpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNhY2hlICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGNhY2hlW2ldID0gZ2VuZXJhdGVCdWZmZXIoaSlcbiAgfVxufVxuXG4vKipcbiAqIGNhbGNWYXJpYWJsZUJ5dGVJbnRMZW5ndGggLSBjYWxjdWxhdGUgdGhlIHZhcmlhYmxlIGJ5dGUgaW50ZWdlclxuICogbGVuZ3RoIGZpZWxkXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGNWYXJpYWJsZUJ5dGVJbnRMZW5ndGggKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID49IDAgJiYgbGVuZ3RoIDwgMTI4KSByZXR1cm4gMVxuICBlbHNlIGlmIChsZW5ndGggPj0gMTI4ICYmIGxlbmd0aCA8IDE2Mzg0KSByZXR1cm4gMlxuICBlbHNlIGlmIChsZW5ndGggPj0gMTYzODQgJiYgbGVuZ3RoIDwgMjA5NzE1MikgcmV0dXJuIDNcbiAgZWxzZSBpZiAobGVuZ3RoID49IDIwOTcxNTIgJiYgbGVuZ3RoIDwgMjY4NDM1NDU2KSByZXR1cm4gNFxuICBlbHNlIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGdlbkJ1ZlZhcmlhYmxlQnl0ZUludCAobnVtKSB7XG4gIHZhciBkaWdpdCA9IDBcbiAgdmFyIHBvcyA9IDBcbiAgdmFyIGxlbmd0aCA9IGNhbGNWYXJpYWJsZUJ5dGVJbnRMZW5ndGgobnVtKVxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcblxuICBkbyB7XG4gICAgZGlnaXQgPSBudW0gJSAxMjggfCAwXG4gICAgbnVtID0gbnVtIC8gMTI4IHwgMFxuICAgIGlmIChudW0gPiAwKSBkaWdpdCA9IGRpZ2l0IHwgMHg4MFxuXG4gICAgYnVmZmVyLndyaXRlVUludDgoZGlnaXQsIHBvcysrKVxuICB9IHdoaWxlIChudW0gPiAwKVxuXG4gIHJldHVybiB7XG4gICAgZGF0YTogYnVmZmVyLFxuICAgIGxlbmd0aDogbGVuZ3RoXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGU0Qnl0ZUJ1ZmZlciAobnVtKSB7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobnVtLCAwKVxuICByZXR1cm4gYnVmZmVyXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWNoZTogY2FjaGUsXG4gIGdlbmVyYXRlQ2FjaGU6IGdlbmVyYXRlQ2FjaGUsXG4gIGdlbmVyYXRlTnVtYmVyOiBnZW5lcmF0ZUJ1ZmZlcixcbiAgZ2VuQnVmVmFyaWFibGVCeXRlSW50OiBnZW5CdWZWYXJpYWJsZUJ5dGVJbnQsXG4gIGdlbmVyYXRlNEJ5dGVCdWZmZXI6IGdlbmVyYXRlNEJ5dGVCdWZmZXJcbn1cblxufSx7XCJzYWZlLWJ1ZmZlclwiOjExMH1dLDg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuZnVuY3Rpb24gUGFja2V0ICgpIHtcbiAgdGhpcy5jbWQgPSBudWxsXG4gIHRoaXMucmV0YWluID0gZmFsc2VcbiAgdGhpcy5xb3MgPSAwXG4gIHRoaXMuZHVwID0gZmFsc2VcbiAgdGhpcy5sZW5ndGggPSAtMVxuICB0aGlzLnRvcGljID0gbnVsbFxuICB0aGlzLnBheWxvYWQgPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFja2V0XG5cbn0se31dLDg4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgYmwgPSByZXF1aXJlKCdibCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBQYWNrZXQgPSByZXF1aXJlKCcuL3BhY2tldCcpXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG5mdW5jdGlvbiBQYXJzZXIgKG9wdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFyc2VyKSkgcmV0dXJuIG5ldyBQYXJzZXIob3B0KVxuXG4gIHRoaXMuc2V0dGluZ3MgPSBvcHQgfHwge31cblxuICB0aGlzLl9zdGF0ZXMgPSBbXG4gICAgJ19wYXJzZUhlYWRlcicsXG4gICAgJ19wYXJzZUxlbmd0aCcsXG4gICAgJ19wYXJzZVBheWxvYWQnLFxuICAgICdfbmV3UGFja2V0J1xuICBdXG5cbiAgdGhpcy5fcmVzZXRTdGF0ZSgpXG59XG5cbmluaGVyaXRzKFBhcnNlciwgRUUpXG5cblBhcnNlci5wcm90b3R5cGUuX3Jlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGFja2V0ID0gbmV3IFBhY2tldCgpXG4gIHRoaXMuZXJyb3IgPSBudWxsXG4gIHRoaXMuX2xpc3QgPSBibCgpXG4gIHRoaXMuX3N0YXRlQ291bnRlciA9IDBcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMuZXJyb3IpIHRoaXMuX3Jlc2V0U3RhdGUoKVxuXG4gIHRoaXMuX2xpc3QuYXBwZW5kKGJ1ZilcblxuICB3aGlsZSAoKHRoaXMucGFja2V0Lmxlbmd0aCAhPT0gLTEgfHwgdGhpcy5fbGlzdC5sZW5ndGggPiAwKSAmJlxuICB0aGlzW3RoaXMuX3N0YXRlc1t0aGlzLl9zdGF0ZUNvdW50ZXJdXSgpICYmXG4gICF0aGlzLmVycm9yKSB7XG4gICAgdGhpcy5fc3RhdGVDb3VudGVyKytcblxuICAgIGlmICh0aGlzLl9zdGF0ZUNvdW50ZXIgPj0gdGhpcy5fc3RhdGVzLmxlbmd0aCkgdGhpcy5fc3RhdGVDb3VudGVyID0gMFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RoXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgYnl0ZSBpbiB0aGUgYnVmZmVyXG4gIHZhciB6ZXJvID0gdGhpcy5fbGlzdC5yZWFkVUludDgoMClcbiAgdGhpcy5wYWNrZXQuY21kID0gY29uc3RhbnRzLnR5cGVzW3plcm8gPj4gY29uc3RhbnRzLkNNRF9TSElGVF1cbiAgdGhpcy5wYWNrZXQucmV0YWluID0gKHplcm8gJiBjb25zdGFudHMuUkVUQUlOX01BU0spICE9PSAwXG4gIHRoaXMucGFja2V0LnFvcyA9ICh6ZXJvID4+IGNvbnN0YW50cy5RT1NfU0hJRlQpICYgY29uc3RhbnRzLlFPU19NQVNLXG4gIHRoaXMucGFja2V0LmR1cCA9ICh6ZXJvICYgY29uc3RhbnRzLkRVUF9NQVNLKSAhPT0gMFxuXG4gIHRoaXMuX2xpc3QuY29uc3VtZSgxKVxuXG4gIHJldHVybiB0cnVlXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgYnl0ZSBpbiB0aGUgbGlzdFxuICB2YXIgcmVzdWx0ID0gdGhpcy5fcGFyc2VWYXJCeXRlTnVtKHRydWUpXG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIHRoaXMucGFja2V0Lmxlbmd0aCA9IHJlc3VsdC52YWx1ZVxuICAgIHRoaXMuX2xpc3QuY29uc3VtZShyZXN1bHQuYnl0ZXMpXG4gIH1cblxuICByZXR1cm4gISFyZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzdWx0ID0gZmFsc2VcblxuICAvLyBEbyB3ZSBoYXZlIGEgcGF5bG9hZD8gRG8gd2UgaGF2ZSBlbm91Z2ggZGF0YSB0byBjb21wbGV0ZSB0aGUgcGF5bG9hZD9cbiAgLy8gUElOR3MgaGF2ZSBubyBwYXlsb2FkXG4gIGlmICh0aGlzLnBhY2tldC5sZW5ndGggPT09IDAgfHwgdGhpcy5fbGlzdC5sZW5ndGggPj0gdGhpcy5wYWNrZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5fcG9zID0gMFxuXG4gICAgc3dpdGNoICh0aGlzLnBhY2tldC5jbWQpIHtcbiAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICB0aGlzLl9wYXJzZUNvbm5lY3QoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnY29ubmFjayc6XG4gICAgICAgIHRoaXMuX3BhcnNlQ29ubmFjaygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwdWJsaXNoJzpcbiAgICAgICAgdGhpcy5fcGFyc2VQdWJsaXNoKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgICBjYXNlICdwdWJyZWMnOlxuICAgICAgY2FzZSAncHVicmVsJzpcbiAgICAgIGNhc2UgJ3B1YmNvbXAnOlxuICAgICAgICB0aGlzLl9wYXJzZUNvbmZpcm1hdGlvbigpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdWJzY3JpYmUnOlxuICAgICAgICB0aGlzLl9wYXJzZVN1YnNjcmliZSgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdWJhY2snOlxuICAgICAgICB0aGlzLl9wYXJzZVN1YmFjaygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnN1YnNjcmliZSc6XG4gICAgICAgIHRoaXMuX3BhcnNlVW5zdWJzY3JpYmUoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgICB0aGlzLl9wYXJzZVVuc3ViYWNrKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BpbmdyZXEnOlxuICAgICAgY2FzZSAncGluZ3Jlc3AnOlxuICAgICAgICAvLyBUaGVzZSBhcmUgZW1wdHksIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICB0aGlzLl9wYXJzZURpc2Nvbm5lY3QoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnYXV0aCc6XG4gICAgICAgIHRoaXMuX3BhcnNlQXV0aCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuXG4gICAgcmVzdWx0ID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm90b2NvbElkIC8vIFByb3RvY29sIElEXG4gIHZhciBjbGllbnRJZCAvLyBDbGllbnQgSURcbiAgdmFyIHRvcGljIC8vIFdpbGwgdG9waWNcbiAgdmFyIHBheWxvYWQgLy8gV2lsbCBwYXlsb2FkXG4gIHZhciBwYXNzd29yZCAvLyBQYXNzd29yZFxuICB2YXIgdXNlcm5hbWUgLy8gVXNlcm5hbWVcbiAgdmFyIGZsYWdzID0ge31cbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgLy8gUGFyc2UgcHJvdG9jb2xJZFxuICBwcm90b2NvbElkID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuXG4gIGlmIChwcm90b2NvbElkID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHByb3RvY29sSWQnKSlcbiAgaWYgKHByb3RvY29sSWQgIT09ICdNUVRUJyAmJiBwcm90b2NvbElkICE9PSAnTVFJc2RwJykge1xuICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sSWQnKSlcbiAgfVxuXG4gIHBhY2tldC5wcm90b2NvbElkID0gcHJvdG9jb2xJZFxuXG4gIC8vIFBhcnNlIGNvbnN0YW50cyB2ZXJzaW9uIG51bWJlclxuICBpZiAodGhpcy5fcG9zID49IHRoaXMuX2xpc3QubGVuZ3RoKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignUGFja2V0IHRvbyBzaG9ydCcpKVxuXG4gIHBhY2tldC5wcm90b2NvbFZlcnNpb24gPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpXG5cbiAgaWYgKHBhY2tldC5wcm90b2NvbFZlcnNpb24gIT09IDMgJiYgcGFja2V0LnByb3RvY29sVmVyc2lvbiAhPT0gNCAmJiBwYWNrZXQucHJvdG9jb2xWZXJzaW9uICE9PSA1KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgdmVyc2lvbicpKVxuICB9XG5cbiAgdGhpcy5fcG9zKytcblxuICBpZiAodGhpcy5fcG9zID49IHRoaXMuX2xpc3QubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcbiAgfVxuXG4gIC8vIFBhcnNlIGNvbm5lY3QgZmxhZ3NcbiAgZmxhZ3MudXNlcm5hbWUgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5VU0VSTkFNRV9NQVNLKVxuICBmbGFncy5wYXNzd29yZCA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLlBBU1NXT1JEX01BU0spXG4gIGZsYWdzLndpbGwgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5XSUxMX0ZMQUdfTUFTSylcblxuICBpZiAoZmxhZ3Mud2lsbCkge1xuICAgIHBhY2tldC53aWxsID0ge31cbiAgICBwYWNrZXQud2lsbC5yZXRhaW4gPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5XSUxMX1JFVEFJTl9NQVNLKSAhPT0gMFxuICAgIHBhY2tldC53aWxsLnFvcyA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLldJTExfUU9TX01BU0spID4+IGNvbnN0YW50cy5XSUxMX1FPU19TSElGVFxuICB9XG5cbiAgcGFja2V0LmNsZWFuID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuQ0xFQU5fU0VTU0lPTl9NQVNLKSAhPT0gMFxuICB0aGlzLl9wb3MrK1xuXG4gIC8vIFBhcnNlIGtlZXBhbGl2ZVxuICBwYWNrZXQua2VlcGFsaXZlID0gdGhpcy5fcGFyc2VOdW0oKVxuICBpZiAocGFja2V0LmtlZXBhbGl2ZSA9PT0gLTEpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdQYWNrZXQgdG9vIHNob3J0JykpXG5cbiAgLy8gcGFyc2UgcHJvcGVydGllc1xuICBpZiAocGFja2V0LnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cbiAgLy8gUGFyc2UgY2xpZW50SWRcbiAgY2xpZW50SWQgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gIGlmIChjbGllbnRJZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcbiAgcGFja2V0LmNsaWVudElkID0gY2xpZW50SWRcblxuICBpZiAoZmxhZ3Mud2lsbCkge1xuICAgIGlmIChwYWNrZXQucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICB2YXIgd2lsbFByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbGxQcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0LndpbGwucHJvcGVydGllcyA9IHdpbGxQcm9wZXJ0aWVzXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlIHdpbGwgdG9waWNcbiAgICB0b3BpYyA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICBpZiAodG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2Ugd2lsbCB0b3BpYycpKVxuICAgIHBhY2tldC53aWxsLnRvcGljID0gdG9waWNcblxuICAgIC8vIFBhcnNlIHdpbGwgcGF5bG9hZFxuICAgIHBheWxvYWQgPSB0aGlzLl9wYXJzZUJ1ZmZlcigpXG4gICAgaWYgKHBheWxvYWQgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2Ugd2lsbCBwYXlsb2FkJykpXG4gICAgcGFja2V0LndpbGwucGF5bG9hZCA9IHBheWxvYWRcbiAgfVxuXG4gIC8vIFBhcnNlIHVzZXJuYW1lXG4gIGlmIChmbGFncy51c2VybmFtZSkge1xuICAgIHVzZXJuYW1lID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmICh1c2VybmFtZSA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB1c2VybmFtZScpKVxuICAgIHBhY2tldC51c2VybmFtZSA9IHVzZXJuYW1lXG4gIH1cblxuICAvLyBQYXJzZSBwYXNzd29yZFxuICBpZiAoZmxhZ3MucGFzc3dvcmQpIHtcbiAgICBwYXNzd29yZCA9IHRoaXMuX3BhcnNlQnVmZmVyKClcbiAgICBpZiAocGFzc3dvcmQgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgcGFzc3dvcmQnKSlcbiAgICBwYWNrZXQucGFzc3dvcmQgPSBwYXNzd29yZFxuICB9XG4gIC8vIG5lZWQgZm9yIHJpZ2h0IHBhcnNlIGF1dGggcGFja2V0IGFuZCBzZWxmIHNldCB1cFxuICB0aGlzLnNldHRpbmdzID0gcGFja2V0XG5cbiAgcmV0dXJuIHBhY2tldFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUNvbm5hY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA8IDIpIHJldHVybiBudWxsXG5cbiAgcGFja2V0LnNlc3Npb25QcmVzZW50ID0gISEodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspICYgY29uc3RhbnRzLlNFU1NJT05QUkVTRU5UX01BU0spXG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHBhY2tldC5yZWFzb25Db2RlID0gdGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspXG4gIH0gZWxzZSB7XG4gICAgcGFja2V0LnJldHVybkNvZGUgPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKylcbiAgfVxuXG4gIGlmIChwYWNrZXQucmV0dXJuQ29kZSA9PT0gLTEgfHwgcGFja2V0LnJlYXNvbkNvZGUgPT09IC0xKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHJldHVybiBjb2RlJykpXG4gIC8vIG1xdHQgNSBwcm9wZXJ0aWVzXG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQdWJsaXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcbiAgcGFja2V0LnRvcGljID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuXG4gIGlmIChwYWNrZXQudG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdG9waWMnKSlcblxuICAvLyBQYXJzZSBtZXNzYWdlSWRcbiAgaWYgKHBhY2tldC5xb3MgPiAwKSBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgfVxuICB9XG5cbiAgcGFja2V0LnBheWxvYWQgPSB0aGlzLl9saXN0LnNsaWNlKHRoaXMuX3BvcywgcGFja2V0Lmxlbmd0aClcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VTdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuICB2YXIgdG9waWNcbiAgdmFyIG9wdGlvbnNcbiAgdmFyIHFvc1xuICB2YXIgcmhcbiAgdmFyIHJhcFxuICB2YXIgbmxcbiAgdmFyIHN1YnNjcmlwdGlvblxuXG4gIGlmIChwYWNrZXQucW9zICE9PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1dyb25nIHN1YnNjcmliZSBoZWFkZXInKSlcbiAgfVxuXG4gIHBhY2tldC5zdWJzY3JpcHRpb25zID0gW11cblxuICBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHRoaXMuX3BvcyA8IHBhY2tldC5sZW5ndGgpIHtcbiAgICAvLyBQYXJzZSB0b3BpY1xuICAgIHRvcGljID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmICh0b3BpYyA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB0b3BpYycpKVxuXG4gICAgb3B0aW9ucyA9IHRoaXMuX3BhcnNlQnl0ZSgpXG4gICAgcW9zID0gb3B0aW9ucyAmIGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19RT1NfTUFTS1xuICAgIG5sID0gKChvcHRpb25zID4+IGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19OTF9TSElGVCkgJiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfTkxfTUFTSykgIT09IDBcbiAgICByYXAgPSAoKG9wdGlvbnMgPj4gY29uc3RhbnRzLlNVQlNDUklCRV9PUFRJT05TX1JBUF9TSElGVCkgJiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfUkFQX01BU0spICE9PSAwXG4gICAgcmggPSAob3B0aW9ucyA+PiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfUkhfU0hJRlQpICYgY29uc3RhbnRzLlNVQlNDUklCRV9PUFRJT05TX1JIX01BU0tcblxuICAgIHN1YnNjcmlwdGlvbiA9IHsgdG9waWM6IHRvcGljLCBxb3M6IHFvcyB9XG5cbiAgICAvLyBtcXR0IDUgb3B0aW9uc1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm5sID0gbmxcbiAgICAgIHN1YnNjcmlwdGlvbi5yYXAgPSByYXBcbiAgICAgIHN1YnNjcmlwdGlvbi5yaCA9IHJoXG4gICAgfVxuXG4gICAgLy8gUHVzaCBwYWlyIHRvIHN1YnNjcmlwdGlvbnNcbiAgICBwYWNrZXQuc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbilcbiAgfVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN1YmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG4gIHRoaXMucGFja2V0LmdyYW50ZWQgPSBbXVxuXG4gIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gIC8vIFByb3BlcnRpZXMgbXF0dCA1XG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBncmFudGVkIFFvU2VzXG4gIHdoaWxlICh0aGlzLl9wb3MgPCB0aGlzLnBhY2tldC5sZW5ndGgpIHtcbiAgICB0aGlzLnBhY2tldC5ncmFudGVkLnB1c2godGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspKVxuICB9XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlVW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIHBhY2tldC51bnN1YnNjcmlwdGlvbnMgPSBbXVxuXG4gIC8vIFBhcnNlIG1lc3NhZ2VJZFxuICBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHRoaXMuX3BvcyA8IHBhY2tldC5sZW5ndGgpIHtcbiAgICB2YXIgdG9waWNcblxuICAgIC8vIFBhcnNlIHRvcGljXG4gICAgdG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgaWYgKHRvcGljID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHRvcGljJykpXG5cbiAgICAvLyBQdXNoIHRvcGljIHRvIHVuc3Vic2NyaXB0aW9uc1xuICAgIHBhY2tldC51bnN1YnNjcmlwdGlvbnMucHVzaCh0b3BpYylcbiAgfVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVVuc3ViYWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcbiAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIG1lc3NhZ2VJZCcpKVxuICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgfVxuICAgIC8vIFBhcnNlIGdyYW50ZWQgUW9TZXNcbiAgICBwYWNrZXQuZ3JhbnRlZCA9IFtdXG4gICAgd2hpbGUgKHRoaXMuX3BvcyA8IHRoaXMucGFja2V0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5wYWNrZXQuZ3JhbnRlZC5wdXNoKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKSlcbiAgICB9XG4gIH1cbn1cblxuLy8gcGFyc2UgcGFja2V0cyBsaWtlIHB1YmFjaywgcHVicmVjLCBwdWJyZWwsIHB1YmNvbXBcblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQ29uZmlybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICB0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpXG5cbiAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgaWYgKHBhY2tldC5sZW5ndGggPiAyKSB7XG4gICAgICAvLyByZXNwb25zZSBjb2RlXG4gICAgICBwYWNrZXQucmVhc29uQ29kZSA9IHRoaXMuX3BhcnNlQnl0ZSgpXG4gICAgICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIHBhcnNlIGRpc2Nvbm5lY3QgcGFja2V0XG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZURpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIC8vIHJlc3BvbnNlIGNvZGVcbiAgICBwYWNrZXQucmVhc29uQ29kZSA9IHRoaXMuX3BhcnNlQnl0ZSgpXG4gICAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBwYXJzZSBhdXRoIHBhY2tldFxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VBdXRoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gIT09IDUpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBhdXRoIHBhY2tldCBmb3IgdGhpcyB2ZXJzaW9uIE1RVFQnKSlcbiAgfVxuXG4gIC8vIHJlc3BvbnNlIGNvZGVcbiAgcGFja2V0LnJlYXNvbkNvZGUgPSB0aGlzLl9wYXJzZUJ5dGUoKVxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VNZXNzYWdlSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIHBhY2tldC5tZXNzYWdlSWQgPSB0aGlzLl9wYXJzZU51bSgpXG5cbiAgaWYgKHBhY2tldC5tZXNzYWdlSWQgPT09IG51bGwpIHtcbiAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIChtYXliZUJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5fcGFyc2VOdW0oKVxuICB2YXIgcmVzdWx0XG4gIHZhciBlbmQgPSBsZW5ndGggKyB0aGlzLl9wb3NcblxuICBpZiAobGVuZ3RoID09PSAtMSB8fCBlbmQgPiB0aGlzLl9saXN0Lmxlbmd0aCB8fCBlbmQgPiB0aGlzLnBhY2tldC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgcmVzdWx0ID0gdGhpcy5fbGlzdC50b1N0cmluZygndXRmOCcsIHRoaXMuX3BvcywgZW5kKVxuICB0aGlzLl9wb3MgKz0gbGVuZ3RoXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN0cmluZ1BhaXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogdGhpcy5fcGFyc2VTdHJpbmcoKSxcbiAgICB2YWx1ZTogdGhpcy5fcGFyc2VTdHJpbmcoKVxuICB9XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5fcGFyc2VOdW0oKVxuICB2YXIgcmVzdWx0XG4gIHZhciBlbmQgPSBsZW5ndGggKyB0aGlzLl9wb3NcblxuICBpZiAobGVuZ3RoID09PSAtMSB8fCBlbmQgPiB0aGlzLl9saXN0Lmxlbmd0aCB8fCBlbmQgPiB0aGlzLnBhY2tldC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgcmVzdWx0ID0gdGhpcy5fbGlzdC5zbGljZSh0aGlzLl9wb3MsIGVuZClcblxuICB0aGlzLl9wb3MgKz0gbGVuZ3RoXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZU51bSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIC0gdGhpcy5fcG9zIDwgMikgcmV0dXJuIC0xXG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2xpc3QucmVhZFVJbnQxNkJFKHRoaXMuX3BvcylcbiAgdGhpcy5fcG9zICs9IDJcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlNEJ5dGVOdW0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9saXN0Lmxlbmd0aCAtIHRoaXMuX3BvcyA8IDQpIHJldHVybiAtMVxuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9saXN0LnJlYWRVSW50MzJCRSh0aGlzLl9wb3MpXG4gIHRoaXMuX3BvcyArPSA0XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVZhckJ5dGVOdW0gPSBmdW5jdGlvbiAoZnVsbEluZm9GbGFnKSB7XG4gIHZhciBieXRlcyA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIGxlbmd0aCA9IDBcbiAgdmFyIHJlc3VsdCA9IHRydWVcbiAgdmFyIGN1cnJlbnRcbiAgdmFyIHBhZGRpbmcgPSB0aGlzLl9wb3MgPyB0aGlzLl9wb3MgOiAwXG5cbiAgd2hpbGUgKGJ5dGVzIDwgNSkge1xuICAgIGN1cnJlbnQgPSB0aGlzLl9saXN0LnJlYWRVSW50OChwYWRkaW5nICsgYnl0ZXMrKylcbiAgICBsZW5ndGggKz0gbXVsICogKGN1cnJlbnQgJiBjb25zdGFudHMuTEVOR1RIX01BU0spXG4gICAgbXVsICo9IDB4ODBcblxuICAgIGlmICgoY3VycmVudCAmIGNvbnN0YW50cy5MRU5HVEhfRklOX01BU0spID09PSAwKSBicmVha1xuICAgIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA8PSBieXRlcykge1xuICAgICAgcmVzdWx0ID0gZmFsc2VcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHBhZGRpbmcpIHtcbiAgICB0aGlzLl9wb3MgKz0gYnl0ZXNcbiAgfVxuXG4gIHJlc3VsdCA9IHJlc3VsdFxuICAgID8gZnVsbEluZm9GbGFnID8ge1xuICAgICAgYnl0ZXM6IGJ5dGVzLFxuICAgICAgdmFsdWU6IGxlbmd0aFxuICAgIH0gOiBsZW5ndGhcbiAgICA6IGZhbHNlXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUJ5dGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpXG4gIHRoaXMuX3BvcysrXG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdieXRlJzoge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQnl0ZSgpICE9PSAwXG4gICAgfVxuICAgIGNhc2UgJ2ludDgnOiB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VCeXRlKClcbiAgICB9XG4gICAgY2FzZSAnaW50MTYnOiB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VOdW0oKVxuICAgIH1cbiAgICBjYXNlICdpbnQzMic6IHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZTRCeXRlTnVtKClcbiAgICB9XG4gICAgY2FzZSAndmFyJzoge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVmFyQnl0ZU51bSgpXG4gICAgfVxuICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgfVxuICAgIGNhc2UgJ3BhaXInOiB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VTdHJpbmdQYWlyKClcbiAgICB9XG4gICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQnVmZmVyKClcbiAgICB9XG4gIH1cbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5fcGFyc2VWYXJCeXRlTnVtKClcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fcG9zXG4gIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aFxuICB2YXIgcmVzdWx0ID0ge31cbiAgd2hpbGUgKHRoaXMuX3BvcyA8IGVuZCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fcGFyc2VCeXRlKClcbiAgICB2YXIgbmFtZSA9IGNvbnN0YW50cy5wcm9wZXJ0aWVzQ29kZXNbdHlwZV1cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1Vua25vd24gcHJvcGVydHknKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyB1c2VyIHByb3BlcnRpZXMgcHJvY2Vzc1xuICAgIGlmIChuYW1lID09PSAndXNlclByb3BlcnRpZXMnKSB7XG4gICAgICBpZiAoIXJlc3VsdFtuYW1lXSkge1xuICAgICAgICByZXN1bHRbbmFtZV0gPSB7fVxuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRVc2VyUHJvcGVydHkgPSB0aGlzLl9wYXJzZUJ5VHlwZShjb25zdGFudHMucHJvcGVydGllc1R5cGVzW25hbWVdKVxuICAgICAgcmVzdWx0W25hbWVdW2N1cnJlbnRVc2VyUHJvcGVydHkubmFtZV0gPSBjdXJyZW50VXNlclByb3BlcnR5LnZhbHVlXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICByZXN1bHRbbmFtZV0gPSB0aGlzLl9wYXJzZUJ5VHlwZShjb25zdGFudHMucHJvcGVydGllc1R5cGVzW25hbWVdKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fbmV3UGFja2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXQpIHtcbiAgICB0aGlzLl9saXN0LmNvbnN1bWUodGhpcy5wYWNrZXQubGVuZ3RoKVxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgdGhpcy5wYWNrZXQpXG4gIH1cblxuICB0aGlzLnBhY2tldCA9IG5ldyBQYWNrZXQoKVxuXG4gIHRoaXMuX3BvcyA9IDBcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9lbWl0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZXJyb3IgPSBlcnJcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJcblxufSx7XCIuL2NvbnN0YW50c1wiOjgyLFwiLi9wYWNrZXRcIjo4NyxcImJsXCI6ODUsXCJldmVudHNcIjoxMyxcImluaGVyaXRzXCI6ODB9XSw4OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxudmFyIHByb3RvY29sID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgZW1wdHkgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbnZhciB6ZXJvQnVmID0gQnVmZmVyLmZyb20oWzBdKVxudmFyIG51bWJlcnMgPSByZXF1aXJlKCcuL251bWJlcnMnKVxudmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKS5uZXh0VGlja1xuXG52YXIgbnVtQ2FjaGUgPSBudW1iZXJzLmNhY2hlXG52YXIgZ2VuZXJhdGVOdW1iZXIgPSBudW1iZXJzLmdlbmVyYXRlTnVtYmVyXG52YXIgZ2VuZXJhdGVDYWNoZSA9IG51bWJlcnMuZ2VuZXJhdGVDYWNoZVxudmFyIGdlbkJ1ZlZhcmlhYmxlQnl0ZUludCA9IG51bWJlcnMuZ2VuQnVmVmFyaWFibGVCeXRlSW50XG52YXIgZ2VuZXJhdGU0Qnl0ZUJ1ZmZlciA9IG51bWJlcnMuZ2VuZXJhdGU0Qnl0ZUJ1ZmZlclxudmFyIHdyaXRlTnVtYmVyID0gd3JpdGVOdW1iZXJDYWNoZWRcbnZhciB0b0dlbmVyYXRlID0gdHJ1ZVxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgaWYgKHN0cmVhbS5jb3JrKSB7XG4gICAgc3RyZWFtLmNvcmsoKVxuICAgIG5leHRUaWNrKHVuY29yaywgc3RyZWFtKVxuICB9XG5cbiAgaWYgKHRvR2VuZXJhdGUpIHtcbiAgICB0b0dlbmVyYXRlID0gZmFsc2VcbiAgICBnZW5lcmF0ZUNhY2hlKClcbiAgfVxuXG4gIHN3aXRjaCAocGFja2V0LmNtZCkge1xuICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgcmV0dXJuIGNvbm5lY3QocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgY2FzZSAnY29ubmFjayc6XG4gICAgICByZXR1cm4gY29ubmFjayhwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdwdWJsaXNoJzpcbiAgICAgIHJldHVybiBwdWJsaXNoKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgY2FzZSAncHVicmVjJzpcbiAgICBjYXNlICdwdWJyZWwnOlxuICAgIGNhc2UgJ3B1YmNvbXAnOlxuICAgICAgcmV0dXJuIGNvbmZpcm1hdGlvbihwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdzdWJzY3JpYmUnOlxuICAgICAgcmV0dXJuIHN1YnNjcmliZShwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdzdWJhY2snOlxuICAgICAgcmV0dXJuIHN1YmFjayhwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICd1bnN1YnNjcmliZSc6XG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmUocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgcmV0dXJuIHVuc3ViYWNrKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3BpbmdyZXEnOlxuICAgIGNhc2UgJ3BpbmdyZXNwJzpcbiAgICAgIHJldHVybiBlbXB0eVBhY2tldChwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgIHJldHVybiBkaXNjb25uZWN0KHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ2F1dGgnOlxuICAgICAgcmV0dXJuIGF1dGgocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignVW5rbm93biBjb21tYW5kJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuLyoqXG4gKiBDb250cm9scyBudW1iZXJzIGNhY2hlLlxuICogU2V0IHRvIFwiZmFsc2VcIiB0byBhbGxvY2F0ZSBidWZmZXJzIG9uLXRoZS1mbGlnaHQgaW5zdGVhZCBvZiBwcmUtZ2VuZXJhdGVkIGNhY2hlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZW5lcmF0ZSwgJ2NhY2hlTnVtYmVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdyaXRlTnVtYmVyID09PSB3cml0ZU51bWJlckNhY2hlZFxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCFudW1DYWNoZSB8fCBPYmplY3Qua2V5cyhudW1DYWNoZSkubGVuZ3RoID09PSAwKSB0b0dlbmVyYXRlID0gdHJ1ZVxuICAgICAgd3JpdGVOdW1iZXIgPSB3cml0ZU51bWJlckNhY2hlZFxuICAgIH0gZWxzZSB7XG4gICAgICB0b0dlbmVyYXRlID0gZmFsc2VcbiAgICAgIHdyaXRlTnVtYmVyID0gd3JpdGVOdW1iZXJHZW5lcmF0ZWRcbiAgICB9XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIHVuY29yayAoc3RyZWFtKSB7XG4gIHN0cmVhbS51bmNvcmsoKVxufVxuXG5mdW5jdGlvbiBjb25uZWN0IChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIHByb3RvY29sSWQgPSBzZXR0aW5ncy5wcm90b2NvbElkIHx8ICdNUVRUJ1xuICB2YXIgcHJvdG9jb2xWZXJzaW9uID0gc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uIHx8IDRcbiAgdmFyIHdpbGwgPSBzZXR0aW5ncy53aWxsXG4gIHZhciBjbGVhbiA9IHNldHRpbmdzLmNsZWFuXG4gIHZhciBrZWVwYWxpdmUgPSBzZXR0aW5ncy5rZWVwYWxpdmUgfHwgMFxuICB2YXIgY2xpZW50SWQgPSBzZXR0aW5ncy5jbGllbnRJZCB8fCAnJ1xuICB2YXIgdXNlcm5hbWUgPSBzZXR0aW5ncy51c2VybmFtZVxuICB2YXIgcGFzc3dvcmQgPSBzZXR0aW5ncy5wYXNzd29yZFxuICAvKiBtcXR0NSBuZXcgb3ByaW9ucyAqL1xuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcblxuICBpZiAoY2xlYW4gPT09IHVuZGVmaW5lZCkgY2xlYW4gPSB0cnVlXG5cbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBNdXN0IGJlIGEgc3RyaW5nIGFuZCBub24tZmFsc3lcbiAgaWYgKCFwcm90b2NvbElkIHx8XG4gICAgICh0eXBlb2YgcHJvdG9jb2xJZCAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihwcm90b2NvbElkKSkpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2xJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IHByb3RvY29sSWQubGVuZ3RoICsgMlxuXG4gIC8vIE11c3QgYmUgMyBvciA0IG9yIDVcbiAgaWYgKHByb3RvY29sVmVyc2lvbiAhPT0gMyAmJiBwcm90b2NvbFZlcnNpb24gIT09IDQgJiYgcHJvdG9jb2xWZXJzaW9uICE9PSA1KSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sIHZlcnNpb24nKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSAxXG5cbiAgLy8gQ2xpZW50SWQgbWlnaHQgYmUgb21pdHRlZCBpbiAzLjEuMSwgYnV0IG9ubHkgaWYgY2xlYW5TZXNzaW9uIGlzIHNldCB0byAxXG4gIGlmICgodHlwZW9mIGNsaWVudElkID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIoY2xpZW50SWQpKSAmJlxuICAgICAoY2xpZW50SWQgfHwgcHJvdG9jb2xWZXJzaW9uID09PSA0KSAmJiAoY2xpZW50SWQgfHwgY2xlYW4pKSB7XG4gICAgbGVuZ3RoICs9IGNsaWVudElkLmxlbmd0aCArIDJcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvdG9jb2xWZXJzaW9uIDwgNCkge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdjbGllbnRJZCBtdXN0IGJlIHN1cHBsaWVkIGJlZm9yZSAzLjEuMScpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICgoY2xlYW4gKiAxKSA9PT0gMCkge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdjbGllbnRJZCBtdXN0IGJlIGdpdmVuIGlmIGNsZWFuU2Vzc2lvbiBzZXQgdG8gMCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gTXVzdCBiZSBhIHR3byBieXRlIG51bWJlclxuICBpZiAodHlwZW9mIGtlZXBhbGl2ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgIGtlZXBhbGl2ZSA8IDAgfHxcbiAgICAgIGtlZXBhbGl2ZSA+IDY1NTM1IHx8XG4gICAgICBrZWVwYWxpdmUgJSAxICE9PSAwKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIGtlZXBhbGl2ZScpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDJcblxuICAvLyBDb25uZWN0IGZsYWdzXG4gIGxlbmd0aCArPSAxXG5cbiAgLy8gUHJvcGVydGllc1xuICBpZiAocHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgdmFyIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllcyhzdHJlYW0sIHByb3BlcnRpZXMpXG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgLy8gSWYgd2lsbCBleGlzdHMuLi5cbiAgaWYgKHdpbGwpIHtcbiAgICAvLyBJdCBtdXN0IGJlIGFuIG9iamVjdFxuICAgIGlmICh0eXBlb2Ygd2lsbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB3aWxsJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gSXQgbXVzdCBoYXZlIHRvcGljIHR5cGVvZiBzdHJpbmdcbiAgICBpZiAoIXdpbGwudG9waWMgfHwgdHlwZW9mIHdpbGwudG9waWMgIT09ICdzdHJpbmcnKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgd2lsbCB0b3BpYycpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh3aWxsLnRvcGljKSArIDJcbiAgICB9XG5cbiAgICAvLyBQYXlsb2FkXG4gICAgaWYgKHdpbGwucGF5bG9hZCkge1xuICAgICAgaWYgKHdpbGwucGF5bG9hZC5sZW5ndGggPj0gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbGwucGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgod2lsbC5wYXlsb2FkKSArIDJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggKz0gd2lsbC5wYXlsb2FkLmxlbmd0aCArIDJcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHdpbGwgcGF5bG9hZCcpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gd2lsbCBwcm9wZXJ0aWVzXG4gICAgICB2YXIgd2lsbFByb3BlcnRpZXMgPSB7fVxuICAgICAgaWYgKHByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgICB3aWxsUHJvcGVydGllcyA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCB3aWxsLnByb3BlcnRpZXMpXG4gICAgICAgIGxlbmd0aCArPSB3aWxsUHJvcGVydGllcy5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBVc2VybmFtZVxuICB2YXIgcHJvdmlkZWRVc2VybmFtZSA9IGZhbHNlXG4gIGlmICh1c2VybmFtZSAhPSBudWxsKSB7XG4gICAgaWYgKGlzU3RyaW5nT3JCdWZmZXIodXNlcm5hbWUpKSB7XG4gICAgICBwcm92aWRlZFVzZXJuYW1lID0gdHJ1ZVxuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHVzZXJuYW1lKSArIDJcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXJuYW1lJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBQYXNzd29yZFxuICBpZiAocGFzc3dvcmQgIT0gbnVsbCkge1xuICAgIGlmICghcHJvdmlkZWRVc2VybmFtZSkge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdVc2VybmFtZSBpcyByZXF1aXJlZCB0byB1c2UgcGFzc3dvcmQnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChpc1N0cmluZ09yQnVmZmVyKHBhc3N3b3JkKSkge1xuICAgICAgbGVuZ3RoICs9IGJ5dGVMZW5ndGgocGFzc3dvcmQpICsgMlxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQ09OTkVDVF9IRUFERVIpXG5cbiAgLy8gR2VuZXJhdGUgbGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBHZW5lcmF0ZSBwcm90b2NvbCBJRFxuICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgcHJvdG9jb2xJZClcbiAgc3RyZWFtLndyaXRlKFxuICAgIHByb3RvY29sVmVyc2lvbiA9PT0gNFxuICAgICAgPyBwcm90b2NvbC5WRVJTSU9ONFxuICAgICAgOiBwcm90b2NvbFZlcnNpb24gPT09IDVcbiAgICAgICAgPyBwcm90b2NvbC5WRVJTSU9ONVxuICAgICAgICA6IHByb3RvY29sLlZFUlNJT04zXG4gIClcblxuICAvLyBDb25uZWN0IGZsYWdzXG4gIHZhciBmbGFncyA9IDBcbiAgZmxhZ3MgfD0gKHVzZXJuYW1lICE9IG51bGwpID8gcHJvdG9jb2wuVVNFUk5BTUVfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHBhc3N3b3JkICE9IG51bGwpID8gcHJvdG9jb2wuUEFTU1dPUkRfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHdpbGwgJiYgd2lsbC5yZXRhaW4pID8gcHJvdG9jb2wuV0lMTF9SRVRBSU5fTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHdpbGwgJiYgd2lsbC5xb3MpID8gd2lsbC5xb3MgPDwgcHJvdG9jb2wuV0lMTF9RT1NfU0hJRlQgOiAwXG4gIGZsYWdzIHw9IHdpbGwgPyBwcm90b2NvbC5XSUxMX0ZMQUdfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gY2xlYW4gPyBwcm90b2NvbC5DTEVBTl9TRVNTSU9OX01BU0sgOiAwXG5cbiAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtmbGFnc10pKVxuXG4gIC8vIEtlZXBhbGl2ZVxuICB3cml0ZU51bWJlcihzdHJlYW0sIGtlZXBhbGl2ZSlcblxuICAvLyBQcm9wZXJ0aWVzXG4gIGlmIChwcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICAvLyBDbGllbnQgSURcbiAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIGNsaWVudElkKVxuXG4gIC8vIFdpbGxcbiAgaWYgKHdpbGwpIHtcbiAgICBpZiAocHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICB3aWxsUHJvcGVydGllcy53cml0ZSgpXG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwgd2lsbC50b3BpYylcbiAgICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgd2lsbC5wYXlsb2FkKVxuICB9XG5cbiAgLy8gVXNlcm5hbWUgYW5kIHBhc3N3b3JkXG4gIGlmICh1c2VybmFtZSAhPSBudWxsKSB7XG4gICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHVzZXJuYW1lKVxuICB9XG4gIGlmIChwYXNzd29yZCAhPSBudWxsKSB7XG4gICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHBhc3N3b3JkKVxuICB9XG4gIC8vIFRoaXMgaXMgYSBzbWFsbCBwYWNrZXQgdGhhdCBoYXBwZW5zIG9ubHkgb25jZSBvbiBhIHN0cmVhbVxuICAvLyBXZSBhc3N1bWUgdGhlIHN0cmVhbSBpcyBhbHdheXMgZnJlZSB0byByZWNlaXZlIG1vcmUgZGF0YSBhZnRlciB0aGlzXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbm5hY2sgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIHJjID0gdmVyc2lvbiA9PT0gNSA/IHNldHRpbmdzLnJlYXNvbkNvZGUgOiBzZXR0aW5ncy5yZXR1cm5Db2RlXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICB2YXIgbGVuZ3RoID0gMiAvLyBsZW5ndGggb2YgcmMgYW5kIHNlc3Npb25IZWFkZXJcblxuICAvLyBDaGVjayByZXR1cm4gY29kZVxuICBpZiAodHlwZW9mIHJjICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCByZXR1cm4gY29kZScpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIC8vIG1xdHQ1IHByb3BlcnRpZXNcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllcyhzdHJlYW0sIHByb3BlcnRpZXMpXG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLkNPTk5BQ0tfSEVBREVSKVxuICAvLyBsZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuICBzdHJlYW0ud3JpdGUoc2V0dGluZ3Muc2Vzc2lvblByZXNlbnQgPyBwcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9IRUFERVIgOiB6ZXJvQnVmKVxuXG4gIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcmNdKSlcbiAgaWYgKHByb3BlcnRpZXNEYXRhICE9IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcHVibGlzaCAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgcW9zID0gc2V0dGluZ3MucW9zIHx8IDBcbiAgdmFyIHJldGFpbiA9IHNldHRpbmdzLnJldGFpbiA/IHByb3RvY29sLlJFVEFJTl9NQVNLIDogMFxuICB2YXIgdG9waWMgPSBzZXR0aW5ncy50b3BpY1xuICB2YXIgcGF5bG9hZCA9IHNldHRpbmdzLnBheWxvYWQgfHwgZW1wdHlcbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gVG9waWMgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgQnVmZmVyXG4gIGlmICh0eXBlb2YgdG9waWMgPT09ICdzdHJpbmcnKSBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgodG9waWMpICsgMlxuICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodG9waWMpKSBsZW5ndGggKz0gdG9waWMubGVuZ3RoICsgMlxuICBlbHNlIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdG9waWMnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEdldCB0aGUgcGF5bG9hZCBsZW5ndGhcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGF5bG9hZCkpIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXlsb2FkKVxuICBlbHNlIGxlbmd0aCArPSBwYXlsb2FkLmxlbmd0aFxuXG4gIC8vIE1lc3NhZ2UgSUQgbXVzdCBhIG51bWJlciBpZiBxb3MgPiAwXG4gIGlmIChxb3MgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChxb3MpIGxlbmd0aCArPSAyXG5cbiAgLy8gbXF0dDUgcHJvcGVydGllc1xuICB2YXIgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlBVQkxJU0hfSEVBREVSW3Fvc11bc2V0dGluZ3MuZHVwID8gMSA6IDBdW3JldGFpbiA/IDEgOiAwXSlcblxuICAvLyBSZW1haW5pbmcgbGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBUb3BpY1xuICB3cml0ZU51bWJlcihzdHJlYW0sIGJ5dGVMZW5ndGgodG9waWMpKVxuICBzdHJlYW0ud3JpdGUodG9waWMpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICBpZiAocW9zID4gMCkgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBQcm9wZXJ0aWVzXG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPSBudWxsKSB7XG4gICAgcHJvcGVydGllc0RhdGEud3JpdGUoKVxuICB9XG5cbiAgLy8gUGF5bG9hZFxuICByZXR1cm4gc3RyZWFtLndyaXRlKHBheWxvYWQpXG59XG5cbi8qIFB1YmFjaywgcHVicmVjLCBwdWJyZWwgYW5kIHB1YmNvbXAgKi9cbmZ1bmN0aW9uIGNvbmZpcm1hdGlvbiAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgdHlwZSA9IHNldHRpbmdzLmNtZCB8fCAncHViYWNrJ1xuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIGR1cCA9IChzZXR0aW5ncy5kdXAgJiYgdHlwZSA9PT0gJ3B1YnJlbCcpID8gcHJvdG9jb2wuRFVQX01BU0sgOiAwXG4gIHZhciBxb3MgPSAwXG4gIHZhciByZWFzb25Db2RlID0gc2V0dGluZ3MucmVhc29uQ29kZVxuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcbiAgdmFyIGxlbmd0aCA9IHZlcnNpb24gPT09IDUgPyAzIDogMlxuXG4gIGlmICh0eXBlID09PSAncHVicmVsJykgcW9zID0gMVxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIHZhciBwcm9wZXJ0aWVzRGF0YSA9IG51bGxcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXNCeU1heGltdW1QYWNrZXRTaXplKHN0cmVhbSwgcHJvcGVydGllcywgb3B0cywgbGVuZ3RoKVxuICAgIGlmICghcHJvcGVydGllc0RhdGEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLkFDS1NbdHlwZV1bcW9zXVtkdXBdWzBdKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxuXG4gIC8vIHJlYXNvbiBjb2RlIGluIGhlYWRlclxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcmVhc29uQ29kZV0pKVxuICB9XG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlIChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICB2YXIgdmVyc2lvbiA9IG9wdHMgPyBvcHRzLnByb3RvY29sVmVyc2lvbiA6IDRcbiAgdmFyIHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIHZhciBkdXAgPSBzZXR0aW5ncy5kdXAgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDBcbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBzdWJzID0gc2V0dGluZ3Muc3Vic2NyaXB0aW9uc1xuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcblxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gMlxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllcyhzdHJlYW0sIHByb3BlcnRpZXMpXG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgLy8gQ2hlY2sgc3Vic2NyaXB0aW9uc1xuICBpZiAodHlwZW9mIHN1YnMgPT09ICdvYmplY3QnICYmIHN1YnMubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgaXRvcGljID0gc3Vic1tpXS50b3BpY1xuICAgICAgdmFyIGlxb3MgPSBzdWJzW2ldLnFvc1xuXG4gICAgICBpZiAodHlwZW9mIGl0b3BpYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIHRvcGljJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpcW9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucyAtIGludmFsaWQgcW9zJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgICAgICB2YXIgbmwgPSBzdWJzW2ldLm5sIHx8IGZhbHNlXG4gICAgICAgIGlmICh0eXBlb2YgbmwgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCBObyBMb2NhbCcpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHZhciByYXAgPSBzdWJzW2ldLnJhcCB8fCBmYWxzZVxuICAgICAgICBpZiAodHlwZW9mIHJhcCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIFJldGFpbiBhcyBQdWJsaXNoZWQnKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmggPSBzdWJzW2ldLnJoIHx8IDBcbiAgICAgICAgaWYgKHR5cGVvZiByaCAhPT0gJ251bWJlcicgfHwgcmggPiAyKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIFJldGFpbiBIYW5kbGluZycpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChpdG9waWMpICsgMiArIDFcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuU1VCU0NSSUJFX0hFQURFUlsxXVtkdXAgPyAxIDogMF1bMF0pXG5cbiAgLy8gR2VuZXJhdGUgbGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBHZW5lcmF0ZSBtZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJ1ZVxuXG4gIC8vIEdlbmVyYXRlIHN1YnNcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIHN1YiA9IHN1YnNbal1cbiAgICB2YXIganRvcGljID0gc3ViLnRvcGljXG4gICAgdmFyIGpxb3MgPSBzdWIucW9zXG4gICAgdmFyIGpubCA9ICtzdWIubmxcbiAgICB2YXIganJhcCA9ICtzdWIucmFwXG4gICAgdmFyIGpyaCA9IHN1Yi5yaFxuICAgIHZhciBqb3B0aW9uc1xuXG4gICAgLy8gV3JpdGUgdG9waWMgc3RyaW5nXG4gICAgd3JpdGVTdHJpbmcoc3RyZWFtLCBqdG9waWMpXG5cbiAgICAvLyBvcHRpb25zIHByb2Nlc3NcbiAgICBqb3B0aW9ucyA9IHByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1FPU1tqcW9zXVxuICAgIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgICBqb3B0aW9ucyB8PSBqbmwgPyBwcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19OTCA6IDBcbiAgICAgIGpvcHRpb25zIHw9IGpyYXAgPyBwcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19SQVAgOiAwXG4gICAgICBqb3B0aW9ucyB8PSBqcmggPyBwcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19SSFtqcmhdIDogMFxuICAgIH1cbiAgICAvLyBXcml0ZSBvcHRpb25zXG4gICAgcmVzdWx0ID0gc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtqb3B0aW9uc10pKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBzdWJhY2sgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBncmFudGVkID0gc2V0dGluZ3MuZ3JhbnRlZFxuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBDaGVjayBtZXNzYWdlIElEXG4gIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDJcblxuICAvLyBDaGVjayBncmFudGVkIHFvcyB2ZWN0b3JcbiAgaWYgKHR5cGVvZiBncmFudGVkID09PSAnb2JqZWN0JyAmJiBncmFudGVkLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhbnRlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBncmFudGVkW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcW9zIHZlY3RvcicpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGxlbmd0aCArPSAxXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBxb3MgdmVjdG9yJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIHZhciBwcm9wZXJ0aWVzRGF0YSA9IG51bGxcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXNCeU1heGltdW1QYWNrZXRTaXplKHN0cmVhbSwgcHJvcGVydGllcywgb3B0cywgbGVuZ3RoKVxuICAgIGlmICghcHJvcGVydGllc0RhdGEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBoZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlNVQkFDS19IRUFERVIpXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICByZXR1cm4gc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKGdyYW50ZWQpKVxufVxuXG5mdW5jdGlvbiB1bnN1YnNjcmliZSAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIGR1cCA9IHNldHRpbmdzLmR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICB2YXIgdW5zdWJzID0gc2V0dGluZ3MudW5zdWJzY3JpcHRpb25zXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggKz0gMlxuICB9XG4gIC8vIENoZWNrIHVuc3Vic1xuICBpZiAodHlwZW9mIHVuc3VicyA9PT0gJ29iamVjdCcgJiYgdW5zdWJzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5zdWJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIHVuc3Vic1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHVuc3Vic2NyaXB0aW9ucycpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh1bnN1YnNbaV0pICsgMlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdW5zdWJzY3JpcHRpb25zJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICB2YXIgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlVOU1VCU0NSSUJFX0hFQURFUlsxXVtkdXAgPyAxIDogMF1bMF0pXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICAvLyBVbnN1YnNcbiAgdmFyIHJlc3VsdCA9IHRydWVcbiAgZm9yICh2YXIgaiA9IDA7IGogPCB1bnN1YnMubGVuZ3RoOyBqKyspIHtcbiAgICByZXN1bHQgPSB3cml0ZVN0cmluZyhzdHJlYW0sIHVuc3Vic1tqXSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdW5zdWJhY2sgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBkdXAgPSBzZXR0aW5ncy5kdXAgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDBcbiAgdmFyIGdyYW50ZWQgPSBzZXR0aW5ncy5ncmFudGVkXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICB2YXIgdHlwZSA9IHNldHRpbmdzLmNtZFxuICB2YXIgcW9zID0gMFxuXG4gIHZhciBsZW5ndGggPSAyXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIENoZWNrIGdyYW50ZWRcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBpZiAodHlwZW9mIGdyYW50ZWQgPT09ICdvYmplY3QnICYmIGdyYW50ZWQubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYW50ZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBncmFudGVkW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBxb3MgdmVjdG9yJykpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHFvcyB2ZWN0b3InKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpXG4gICAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQUNLU1t0eXBlXVtxb3NdW2R1cF1bMF0pXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICAvLyBwYXlsb2FkXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKGdyYW50ZWQpKVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGVtcHR5UGFja2V0IChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKHByb3RvY29sLkVNUFRZW3BhY2tldC5jbWRdKVxufVxuXG5mdW5jdGlvbiBkaXNjb25uZWN0IChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICB2YXIgdmVyc2lvbiA9IG9wdHMgPyBvcHRzLnByb3RvY29sVmVyc2lvbiA6IDRcbiAgdmFyIHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIHZhciByZWFzb25Db2RlID0gc2V0dGluZ3MucmVhc29uQ29kZVxuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcbiAgdmFyIGxlbmd0aCA9IHZlcnNpb24gPT09IDUgPyAxIDogMFxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpXG4gICAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydkaXNjb25uZWN0J10gPDwgNF0pKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gcmVhc29uIGNvZGUgaW4gaGVhZGVyXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtyZWFzb25Db2RlXSkpXG4gIH1cblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGF1dGggKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIHJlYXNvbkNvZGUgPSBzZXR0aW5ncy5yZWFzb25Db2RlXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICB2YXIgbGVuZ3RoID0gdmVyc2lvbiA9PT0gNSA/IDEgOiAwXG5cbiAgaWYgKHZlcnNpb24gIT09IDUpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtcXR0IHZlcnNpb24gZm9yIGF1dGggcGFja2V0JykpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICB2YXIgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzQnlNYXhpbXVtUGFja2V0U2l6ZShzdHJlYW0sIHByb3BlcnRpZXMsIG9wdHMsIGxlbmd0aClcbiAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG5cbiAgLy8gSGVhZGVyXG4gIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ2F1dGgnXSA8PCA0XSkpXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyByZWFzb24gY29kZSBpbiBoZWFkZXJcbiAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtyZWFzb25Db2RlXSkpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiB3cml0ZVZhckJ5dGVJbnQgLSB3cml0ZSBhbiBNUVRUIHN0eWxlIHZhcmlhYmxlIGJ5dGUgaW50ZWdlciB0byB0aGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPE51bWJlcj4gcG9zIC0gb2Zmc2V0XG4gKiBAcGFyYW0gPE51bWJlcj4gbGVuZ3RoIC0gbGVuZ3RoICg+MClcbiAqIEByZXR1cm5zIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHZhckJ5dGVJbnRDYWNoZSA9IHt9XG5mdW5jdGlvbiB3cml0ZVZhckJ5dGVJbnQgKHN0cmVhbSwgbnVtKSB7XG4gIHZhciBidWZmZXIgPSB2YXJCeXRlSW50Q2FjaGVbbnVtXVxuXG4gIGlmICghYnVmZmVyKSB7XG4gICAgYnVmZmVyID0gZ2VuQnVmVmFyaWFibGVCeXRlSW50KG51bSkuZGF0YVxuICAgIGlmIChudW0gPCAxNjM4NCkgdmFyQnl0ZUludENhY2hlW251bV0gPSBidWZmZXJcbiAgfVxuXG4gIHN0cmVhbS53cml0ZShidWZmZXIpXG59XG5cbi8qKlxuICogd3JpdGVTdHJpbmcgLSB3cml0ZSBhIHV0Zjggc3RyaW5nIHRvIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8U3RyaW5nPiBzdHJpbmcgLSBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm4gPE51bWJlcj4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB3cml0ZVN0cmluZyAoc3RyZWFtLCBzdHJpbmcpIHtcbiAgdmFyIHN0cmxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0cmluZylcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBzdHJsZW4pXG5cbiAgc3RyZWFtLndyaXRlKHN0cmluZywgJ3V0ZjgnKVxufVxuXG4vKipcbiAqIHdyaXRlU3RyaW5nUGFpciAtIHdyaXRlIGEgdXRmOCBzdHJpbmcgcGFpcnMgdG8gdGhlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxTdHJpbmc+IG5hbWUgLSBzdHJpbmcgbmFtZSB0byB3cml0ZVxuICogQHBhcmFtIDxTdHJpbmc+IHZhbHVlIC0gc3RyaW5nIHZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nUGFpciAoc3RyZWFtLCBuYW1lLCB2YWx1ZSkge1xuICB3cml0ZVN0cmluZyhzdHJlYW0sIG5hbWUpXG4gIHdyaXRlU3RyaW5nKHN0cmVhbSwgdmFsdWUpXG59XG5cbi8qKlxuICogd3JpdGVOdW1iZXIgLSB3cml0ZSBhIHR3byBieXRlIG51bWJlciB0byB0aGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPE51bWJlcj4gcG9zIC0gb2Zmc2V0XG4gKiBAcGFyYW0gPFN0cmluZz4gbnVtYmVyIC0gbnVtYmVyIHRvIHdyaXRlXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdyaXRlTnVtYmVyQ2FjaGVkIChzdHJlYW0sIG51bWJlcikge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKG51bUNhY2hlW251bWJlcl0pXG59XG5mdW5jdGlvbiB3cml0ZU51bWJlckdlbmVyYXRlZCAoc3RyZWFtLCBudW1iZXIpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShnZW5lcmF0ZU51bWJlcihudW1iZXIpKVxufVxuZnVuY3Rpb24gd3JpdGU0Qnl0ZU51bWJlciAoc3RyZWFtLCBudW1iZXIpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShnZW5lcmF0ZTRCeXRlQnVmZmVyKG51bWJlcikpXG59XG4vKipcbiAqIHdyaXRlU3RyaW5nT3JCdWZmZXIgLSB3cml0ZSBhIFN0cmluZyBvciBCdWZmZXIgd2l0aCB0aGUgaXRzIGxlbmd0aCBwcmVmaXhcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8U3RyaW5nPiB0b1dyaXRlIC0gU3RyaW5nIG9yIEJ1ZmZlclxuICogQHJldHVybiA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5mdW5jdGlvbiB3cml0ZVN0cmluZ09yQnVmZmVyIChzdHJlYW0sIHRvV3JpdGUpIHtcbiAgaWYgKHR5cGVvZiB0b1dyaXRlID09PSAnc3RyaW5nJykge1xuICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwgdG9Xcml0ZSlcbiAgfSBlbHNlIGlmICh0b1dyaXRlKSB7XG4gICAgd3JpdGVOdW1iZXIoc3RyZWFtLCB0b1dyaXRlLmxlbmd0aClcbiAgICBzdHJlYW0ud3JpdGUodG9Xcml0ZSlcbiAgfSBlbHNlIHdyaXRlTnVtYmVyKHN0cmVhbSwgMClcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllcyAoc3RyZWFtLCBwcm9wZXJ0aWVzKSB7XG4gIC8qIGNvbm5lY3QgcHJvcGVydGllcyAqL1xuICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT09ICdvYmplY3QnIHx8IHByb3BlcnRpZXMubGVuZ3RoICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVuZ3RoOiAxLFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd3JpdGVQcm9wZXJ0aWVzKHN0cmVhbSwge30sIDApXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBwcm9wZXJ0aWVzTGVuZ3RoID0gMFxuICBmdW5jdGlvbiBnZXRMZW5ndGhQcm9wZXJ0eSAobmFtZSkge1xuICAgIHZhciB0eXBlID0gcHJvdG9jb2wucHJvcGVydGllc1R5cGVzW25hbWVdXG4gICAgdmFyIHZhbHVlID0gcHJvcGVydGllc1tuYW1lXVxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdieXRlJzoge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgMVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnaW50OCc6IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgMVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpICsgMlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnaW50MTYnOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkICcgKyBuYW1lKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIDJcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2ludDMyJzoge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCAnICsgbmFtZSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDEgKyA0XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICd2YXInOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkICcgKyBuYW1lKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIGdlbkJ1ZlZhcmlhYmxlQnl0ZUludCh2YWx1ZSkubGVuZ3RoXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkICcgKyBuYW1lKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIDIgKyBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZS50b1N0cmluZygpKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAncGFpcic6IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIG5hbWUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gMSArIDIgKyBCdWZmZXIuYnl0ZUxlbmd0aChuYW1lLnRvU3RyaW5nKCkpICsgMiArIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlW25hbWVdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9LCAwKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgJyArIG5hbWUpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG4gIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcGVydGllcykge1xuICAgICAgdmFyIHByb3BMZW5ndGggPSBnZXRMZW5ndGhQcm9wZXJ0eShwcm9wTmFtZSlcbiAgICAgIGlmICghcHJvcExlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgICBwcm9wZXJ0aWVzTGVuZ3RoICs9IHByb3BMZW5ndGhcbiAgICB9XG4gIH1cbiAgdmFyIHByb3BlcnRpZXNMZW5ndGhMZW5ndGggPSBnZW5CdWZWYXJpYWJsZUJ5dGVJbnQocHJvcGVydGllc0xlbmd0aCkubGVuZ3RoXG5cbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IHByb3BlcnRpZXNMZW5ndGhMZW5ndGggKyBwcm9wZXJ0aWVzTGVuZ3RoLFxuICAgIHdyaXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB3cml0ZVByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzTGVuZ3RoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzQnlNYXhpbXVtUGFja2V0U2l6ZSAoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpIHtcbiAgdmFyIG1heUVtcHR5UHJvcHMgPSBbJ3JlYXNvblN0cmluZycsICd1c2VyUHJvcGVydGllcyddXG4gIHZhciBtYXhpbXVtUGFja2V0U2l6ZSA9IG9wdHMgJiYgb3B0cy5wcm9wZXJ0aWVzICYmIG9wdHMucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSA/IG9wdHMucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSA6IDBcblxuICB2YXIgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgaWYgKG1heGltdW1QYWNrZXRTaXplKSB7XG4gICAgd2hpbGUgKGxlbmd0aCArIHByb3BlcnRpZXNEYXRhLmxlbmd0aCA+IG1heGltdW1QYWNrZXRTaXplKSB7XG4gICAgICB2YXIgY3VycmVudE1heUVtcHR5UHJvcCA9IG1heUVtcHR5UHJvcHMuc2hpZnQoKVxuICAgICAgaWYgKGN1cnJlbnRNYXlFbXB0eVByb3AgJiYgcHJvcGVydGllc1tjdXJyZW50TWF5RW1wdHlQcm9wXSkge1xuICAgICAgICBkZWxldGUgcHJvcGVydGllc1tjdXJyZW50TWF5RW1wdHlQcm9wXVxuICAgICAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wZXJ0aWVzRGF0YVxufVxuXG5mdW5jdGlvbiB3cml0ZVByb3BlcnRpZXMgKHN0cmVhbSwgcHJvcGVydGllcywgcHJvcGVydGllc0xlbmd0aCkge1xuICAvKiB3cml0ZSBwcm9wZXJ0aWVzIHRvIHN0cmVhbSAqL1xuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBwcm9wZXJ0aWVzTGVuZ3RoKVxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmIHByb3BlcnRpZXNbcHJvcE5hbWVdICE9PSBudWxsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXVxuICAgICAgdmFyIHR5cGUgPSBwcm90b2NvbC5wcm9wZXJ0aWVzVHlwZXNbcHJvcE5hbWVdXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnYnl0ZSc6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFsrdmFsdWVdKSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ludDgnOiB7XG4gICAgICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5wcm9wZXJ0aWVzW3Byb3BOYW1lXV0pKVxuICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbdmFsdWVdKSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaW50MTYnOiB7XG4gICAgICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5wcm9wZXJ0aWVzW3Byb3BOYW1lXV0pKVxuICAgICAgICAgIHdyaXRlTnVtYmVyKHN0cmVhbSwgdmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpbnQzMic6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgd3JpdGU0Qnl0ZU51bWJlcihzdHJlYW0sIHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndmFyJzoge1xuICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgICAgICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCB2YWx1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgd3JpdGVTdHJpbmcoc3RyZWFtLCB2YWx1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3BhaXInOiB7XG4gICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgICAgICAgIHdyaXRlU3RyaW5nUGFpcihzdHJlYW0sIG5hbWUudG9TdHJpbmcoKSwgdmFsdWVbbmFtZV0udG9TdHJpbmcoKSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBwcm9wZXJ0eSAnICsgcHJvcE5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGJ1Zk9yU3RyaW5nKSB7XG4gIGlmICghYnVmT3JTdHJpbmcpIHJldHVybiAwXG4gIGVsc2UgaWYgKGJ1Zk9yU3RyaW5nIGluc3RhbmNlb2YgQnVmZmVyKSByZXR1cm4gYnVmT3JTdHJpbmcubGVuZ3RoXG4gIGVsc2UgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGJ1Zk9yU3RyaW5nKVxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ09yQnVmZmVyIChmaWVsZCkge1xuICByZXR1cm4gdHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyB8fCBmaWVsZCBpbnN0YW5jZW9mIEJ1ZmZlclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlXG5cbn0se1wiLi9jb25zdGFudHNcIjo4MixcIi4vbnVtYmVyc1wiOjg2LFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcIjo5MSxcInNhZmUtYnVmZmVyXCI6MTEwfV0sOTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxufSx7XCJ3cmFwcHlcIjoxMjB9XSw5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCJfcHJvY2Vzc1wiOjkyfV0sOTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxufSx7fV0sOTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSw5NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG59LHt9XSw5NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxufSx7fV0sOTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5cbn0se1wiLi9kZWNvZGVcIjo5NCxcIi4vZW5jb2RlXCI6OTV9XSw5NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5cbn0se1wiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIjo5OH1dLDk4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59O1xufSx7XCIuL19zdHJlYW1fcmVhZGFibGVcIjoxMDAsXCIuL19zdHJlYW1fd3JpdGFibGVcIjoxMDIsXCJjb3JlLXV0aWwtaXNcIjoxNCxcImluaGVyaXRzXCI6ODAsXCJwcm9jZXNzLW5leHRpY2stYXJnc1wiOjkxfV0sOTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG59LHtcIi4vX3N0cmVhbV90cmFuc2Zvcm1cIjoxMDEsXCJjb3JlLXV0aWwtaXNcIjoxNCxcImluaGVyaXRzXCI6ODB9XSwxMDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9fc3RyZWFtX2R1cGxleFwiOjk4LFwiLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3RcIjoxMDMsXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVwiOjEwNCxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cIjoxMDUsXCJfcHJvY2Vzc1wiOjkyLFwiY29yZS11dGlsLWlzXCI6MTQsXCJldmVudHNcIjoxMyxcImluaGVyaXRzXCI6ODAsXCJpc2FycmF5XCI6MTA2LFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcIjo5MSxcInNhZmUtYnVmZmVyXCI6MTEwLFwic3RyaW5nX2RlY29kZXIvXCI6MTA3LFwidXRpbFwiOjExfV0sMTAxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG59LHtcIi4vX3N0cmVhbV9kdXBsZXhcIjo5OCxcImNvcmUtdXRpbC1pc1wiOjE0LFwiaW5oZXJpdHNcIjo4MH1dLDEwMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLHNldEltbWVkaWF0ZSl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcInRpbWVyc1wiKS5zZXRJbW1lZGlhdGUpXG59LHtcIi4vX3N0cmVhbV9kdXBsZXhcIjo5OCxcIi4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95XCI6MTA0LFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVwiOjEwNSxcIl9wcm9jZXNzXCI6OTIsXCJjb3JlLXV0aWwtaXNcIjoxNCxcImluaGVyaXRzXCI6ODAsXCJwcm9jZXNzLW5leHRpY2stYXJnc1wiOjkxLFwic2FmZS1idWZmZXJcIjoxMTAsXCJ0aW1lcnNcIjoxMTIsXCJ1dGlsLWRlcHJlY2F0ZVwiOjExNX1dLDEwMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn1cbn0se1wic2FmZS1idWZmZXJcIjoxMTAsXCJ1dGlsXCI6MTF9XSwxMDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTtcbn0se1wicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcIjo5MX1dLDEwNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxufSx7XCJldmVudHNcIjoxM31dLDEwNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxufSx7fV0sMTA3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufVxufSx7XCJzYWZlLWJ1ZmZlclwiOjExMH1dLDEwODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuXG59LHtcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCI6OTgsXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCI6OTksXCIuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXCI6MTAwLFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIjoxMDEsXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCI6MTAyfV0sMTA5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBSZUludGVydmFsIChjYWxsYmFjaywgaW50ZXJ2YWwsIGFyZ3MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMuX2FyZ3MgPSBhcmdzO1xuXG4gIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIGludGVydmFsLCB0aGlzLl9hcmdzKTtcblxuICB0aGlzLnJlc2NoZWR1bGUgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAvLyBpZiBubyBpbnRlcnZhbCBlbnRlcmVkLCB1c2UgdGhlIGludGVydmFsIHBhc3NlZCBpbiBvbiBjcmVhdGlvblxuICAgIGlmICghaW50ZXJ2YWwpXG4gICAgICBpbnRlcnZhbCA9IHNlbGYuX2ludGVydmFsO1xuXG4gICAgaWYgKHNlbGYuX2ludGVydmFsKVxuICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbCk7XG4gICAgc2VsZi5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChzZWxmLl9jYWxsYmFjaywgaW50ZXJ2YWwsIHNlbGYuX2FyZ3MpO1xuICB9O1xuXG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX2ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKTtcbiAgICAgIHNlbGYuX2ludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbiAgXG4gIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWwpO1xuICAgIH1cbiAgICBzZWxmLl9jYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICBzZWxmLl9pbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICBzZWxmLl9hcmdzID0gdW5kZWZpbmVkO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZUludGVydmFsICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBuZWVkZWQnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFcnJvcignaW50ZXJ2YWwgbmVlZGVkJyk7XG5cbiAgdmFyIGFyZ3M7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVJbnRlcnZhbChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVJbnRlcnZhbDtcblxufSx7fV0sMTEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG5cbn0se1wiYnVmZmVyXCI6MTJ9XSwxMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBzaGlmdFxuXG5mdW5jdGlvbiBzaGlmdCAoc3RyZWFtKSB7XG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBpZiAoIXJzKSByZXR1cm4gbnVsbFxuICByZXR1cm4gcnMub2JqZWN0TW9kZSA/IHN0cmVhbS5yZWFkKCkgOiBzdHJlYW0ucmVhZChnZXRTdGF0ZUxlbmd0aChycykpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlTGVuZ3RoIChzdGF0ZSkge1xuICBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgIC8vIFNpbmNlIG5vZGUgNi4zLjAgc3RhdGUuYnVmZmVyIGlzIGEgQnVmZmVyTGlzdCBub3QgYW4gYXJyYXlcbiAgICBpZiAoc3RhdGUuYnVmZmVyLmhlYWQpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoXG59XG5cbn0se31dLDExMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHNldEltbWVkaWF0ZSxjbGVhckltbWVkaWF0ZSl7XG52YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwidGltZXJzXCIpLnNldEltbWVkaWF0ZSxyZXF1aXJlKFwidGltZXJzXCIpLmNsZWFySW1tZWRpYXRlKVxufSx7XCJwcm9jZXNzL2Jyb3dzZXIuanNcIjo5MixcInRpbWVyc1wiOjExMn1dLDExMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxufSx7XCIuL3V0aWxcIjoxMTQsXCJwdW55Y29kZVwiOjkzLFwicXVlcnlzdHJpbmdcIjo5Nn1dLDExNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG5cbn0se31dLDExNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sMTE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cbn0se31dLDExNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9zdXBwb3J0L2lzQnVmZmVyXCI6MTE2LFwiX3Byb2Nlc3NcIjo5MixcImluaGVyaXRzXCI6ODB9XSwxMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCdcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybVxudmFyIGR1cGxleGlmeSA9IHJlcXVpcmUoJ2R1cGxleGlmeScpXG52YXIgV1MgPSByZXF1aXJlKCd3cycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRTdHJlYW1cblxuZnVuY3Rpb24gYnVpbGRQcm94eSAob3B0aW9ucywgc29ja2V0V3JpdGUsIHNvY2tldEVuZCkge1xuICB2YXIgcHJveHkgPSBuZXcgVHJhbnNmb3JtKHtcbiAgICBvYmplY3RNb2RlOiBvcHRpb25zLm9iamVjdE1vZGVcbiAgfSlcblxuICBwcm94eS5fd3JpdGUgPSBzb2NrZXRXcml0ZVxuICBwcm94eS5fZmx1c2ggPSBzb2NrZXRFbmRcblxuICByZXR1cm4gcHJveHlcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0U3RyZWFtKHRhcmdldCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIHZhciBzdHJlYW0sIHNvY2tldFxuXG4gIHZhciBpc0Jyb3dzZXIgPSBwcm9jZXNzLnRpdGxlID09PSAnYnJvd3NlcidcbiAgdmFyIGlzTmF0aXZlID0gISFnbG9iYWwuV2ViU29ja2V0XG4gIHZhciBzb2NrZXRXcml0ZSA9IGlzQnJvd3NlciA/IHNvY2tldFdyaXRlQnJvd3NlciA6IHNvY2tldFdyaXRlTm9kZVxuXG4gIGlmIChwcm90b2NvbHMgJiYgIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHByb3RvY29scykge1xuICAgIC8vIGFjY2VwdCB0aGUgXCJvcHRpb25zXCIgT2JqZWN0IGFzIHRoZSAybmQgYXJndW1lbnRcbiAgICBvcHRpb25zID0gcHJvdG9jb2xzXG4gICAgcHJvdG9jb2xzID0gbnVsbFxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb3RvY29sID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMucHJvdG9jb2wpKSB7XG4gICAgICBwcm90b2NvbHMgPSBvcHRpb25zLnByb3RvY29sO1xuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKG9wdGlvbnMub2JqZWN0TW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5vYmplY3RNb2RlID0gIShvcHRpb25zLmJpbmFyeSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmJpbmFyeSA9PT0gdW5kZWZpbmVkKVxuICB9XG5cbiAgdmFyIHByb3h5ID0gYnVpbGRQcm94eShvcHRpb25zLCBzb2NrZXRXcml0ZSwgc29ja2V0RW5kKVxuXG4gIGlmICghb3B0aW9ucy5vYmplY3RNb2RlKSB7XG4gICAgcHJveHkuX3dyaXRldiA9IHdyaXRldlxuICB9XG5cbiAgLy8gYnJvd3NlciBvbmx5OiBzZXRzIHRoZSBtYXhpbXVtIHNvY2tldCBidWZmZXIgc2l6ZSBiZWZvcmUgdGhyb3R0bGluZ1xuICB2YXIgYnVmZmVyU2l6ZSA9IG9wdGlvbnMuYnJvd3NlckJ1ZmZlclNpemUgfHwgMTAyNCAqIDUxMlxuXG4gIC8vIGJyb3dzZXIgb25seTogaG93IGxvbmcgdG8gd2FpdCB3aGVuIHRocm90dGxpbmdcbiAgdmFyIGJ1ZmZlclRpbWVvdXQgPSBvcHRpb25zLmJyb3dzZXJCdWZmZXJUaW1lb3V0IHx8IDEwMDBcblxuICAvLyB1c2UgZXhpc3RpbmcgV2ViU29ja2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgc29ja2V0ID0gdGFyZ2V0XG4gIC8vIG90aGVyd2lzZSBtYWtlIGEgbmV3IG9uZVxuICB9IGVsc2Uge1xuICAgIC8vIHNwZWNpYWwgY29uc3RydWN0b3IgdHJlYXRtZW50IGZvciBuYXRpdmUgd2Vic29ja2V0cyBpbiBicm93c2Vycywgc2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21heG9nZGVuL3dlYnNvY2tldC1zdHJlYW0vaXNzdWVzLzgyXG4gICAgaWYgKGlzTmF0aXZlICYmIGlzQnJvd3Nlcikge1xuICAgICAgc29ja2V0ID0gbmV3IFdTKHRhcmdldCwgcHJvdG9jb2xzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQgPSBuZXcgV1ModGFyZ2V0LCBwcm90b2NvbHMsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgc29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gIH1cblxuICAvLyB3YXMgYWxyZWFkeSBvcGVuIHdoZW4gcGFzc2VkIGluXG4gIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gc29ja2V0Lk9QRU4pIHtcbiAgICBzdHJlYW0gPSBwcm94eVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IGR1cGxleGlmeS5vYmooKVxuICAgIHNvY2tldC5vbm9wZW4gPSBvbm9wZW5cbiAgfVxuXG4gIHN0cmVhbS5zb2NrZXQgPSBzb2NrZXRcblxuICBzb2NrZXQub25jbG9zZSA9IG9uY2xvc2VcbiAgc29ja2V0Lm9uZXJyb3IgPSBvbmVycm9yXG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBvbm1lc3NhZ2VcblxuICBwcm94eS5vbignY2xvc2UnLCBkZXN0cm95KVxuXG4gIHZhciBjb2VyY2VUb0J1ZmZlciA9ICFvcHRpb25zLm9iamVjdE1vZGVcblxuICBmdW5jdGlvbiBzb2NrZXRXcml0ZU5vZGUoY2h1bmssIGVuYywgbmV4dCkge1xuICAgIC8vIGF2b2lkIGVycm9ycywgdGhpcyBuZXZlciBoYXBwZW5zIHVubGVzc1xuICAgIC8vIGRlc3Ryb3koKSBpcyBjYWxsZWRcbiAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IHNvY2tldC5PUEVOKSB7XG4gICAgICBuZXh0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb2VyY2VUb0J1ZmZlciAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCAndXRmOCcpXG4gICAgfVxuICAgIHNvY2tldC5zZW5kKGNodW5rLCBuZXh0KVxuICB9XG5cbiAgZnVuY3Rpb24gc29ja2V0V3JpdGVCcm93c2VyKGNodW5rLCBlbmMsIG5leHQpIHtcbiAgICBpZiAoc29ja2V0LmJ1ZmZlcmVkQW1vdW50ID4gYnVmZmVyU2l6ZSkge1xuICAgICAgc2V0VGltZW91dChzb2NrZXRXcml0ZUJyb3dzZXIsIGJ1ZmZlclRpbWVvdXQsIGNodW5rLCBlbmMsIG5leHQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY29lcmNlVG9CdWZmZXIgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgJ3V0ZjgnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzb2NrZXQuc2VuZChjaHVuaylcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgcmV0dXJuIG5leHQoZXJyKVxuICAgIH1cblxuICAgIG5leHQoKVxuICB9XG5cbiAgZnVuY3Rpb24gc29ja2V0RW5kKGRvbmUpIHtcbiAgICBzb2NrZXQuY2xvc2UoKVxuICAgIGRvbmUoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25vcGVuKCkge1xuICAgIHN0cmVhbS5zZXRSZWFkYWJsZShwcm94eSlcbiAgICBzdHJlYW0uc2V0V3JpdGFibGUocHJveHkpXG4gICAgc3RyZWFtLmVtaXQoJ2Nvbm5lY3QnKVxuICB9XG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBzdHJlYW0uZW5kKClcbiAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubWVzc2FnZShldmVudCkge1xuICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgIGVsc2UgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICd1dGY4JylcbiAgICBwcm94eS5wdXNoKGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHNvY2tldC5jbG9zZSgpXG4gIH1cblxuICAvLyB0aGlzIGlzIHRvIGJlIGVuYWJsZWQgb25seSBpZiBvYmplY3RNb2RlIGlzIGZhbHNlXG4gIGZ1bmN0aW9uIHdyaXRldiAoY2h1bmtzLCBjYikge1xuICAgIHZhciBidWZmZXJzID0gbmV3IEFycmF5KGNodW5rcy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmtzW2ldLmNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWZmZXJzW2ldID0gQnVmZmVyLmZyb20oY2h1bmtzW2ldLCAndXRmOCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJzW2ldID0gY2h1bmtzW2ldLmNodW5rXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fd3JpdGUoQnVmZmVyLmNvbmNhdChidWZmZXJzKSwgJ2JpbmFyeScsIGNiKVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCJfcHJvY2Vzc1wiOjkyLFwiZHVwbGV4aWZ5XCI6MTcsXCJyZWFkYWJsZS1zdHJlYW1cIjoxMDgsXCJzYWZlLWJ1ZmZlclwiOjExMCxcIndzXCI6MTE5fV0sMTE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxudmFyIHdzID0gbnVsbFxuXG5pZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBNb3pXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSB3aW5kb3cuV2ViU29ja2V0IHx8IHdpbmRvdy5Nb3pXZWJTb2NrZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3c1xuXG59LHt9XSwxMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFja1xuLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYVxuLy8gcHJlc3VtYWJseSBkaWZmZXJlbnQgY2FsbGJhY2sgZnVuY3Rpb24uXG4vLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXRcbi8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5LlxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHlcbmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7XG4gIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpXG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKVxuXG4gIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgd3JhcHBlcltrXSA9IGZuW2tdXG4gIH0pXG5cbiAgcmV0dXJuIHdyYXBwZXJcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHZhciByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV1cbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7XG4gICAgICBPYmplY3Qua2V5cyhjYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXRba10gPSBjYltrXVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbn0se31dLDEyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuXG59LHt9XX0se30sWzldKSg5KVxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 10 */
/*!*********************************************************!*\
  !*** ./node_modules/@dcloudio/uni-mp-weixin/dist/mp.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(exports, "__esModule", { value: true });exports.Behavior = Behavior;exports.Component = Component;exports.Page = Page;exports.nextTick = exports.default = void 0;var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 11));var _PROP_DEFAULT_VALUES;function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function _iterableToArrayLimit(arr, i) {if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}

function parseData(data, vueComponentOptions) {
  if (!data) {
    return;
  }
  vueComponentOptions.mpOptions.data = data;
}

function parseComponents(vueComponentOptions) {
  vueComponentOptions.components = global.__wxVueOptions.components;
}

var _toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function isFn(fn) {
  return typeof fn === 'function';
}

function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

function noop() {}

/**
                    * Create a cached version of a pure function.
                    */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
   * Camelize a hyphen-delimited string.
   */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {return c ? c.toUpperCase() : '';});
});

var SOURCE_KEY = '__data__';

var COMPONENT_LIFECYCLE = {
  created: 'onServiceCreated',
  attached: 'onServiceAttached',
  ready: 'mounted',
  moved: 'moved',
  detached: 'destroyed' };


var COMPONENT_LIFECYCLE_KEYS = Object.keys(COMPONENT_LIFECYCLE);

var PAGE_LIFETIMES = {
  show: 'onPageShow',
  hide: 'onPageHide',
  resize: 'onPageResize' };


var PAGE_LIFETIMES_KEYS = Object.keys(PAGE_LIFETIMES);

var PAGE_LIFECYCLE = [
'onLoad',
'onShow',
'onReady',
'onHide',
'onUnload',
'onPullDownRefresh',
'onReachBottom',
'onShareAppMessage',
'onPageScroll',
'onResize',
'onTabItemTap'];


function parsePageMethods(mpComponentOptions, vueComponentOptions) {
  var methods = Object.create(null);
  Object.keys(mpComponentOptions).forEach(function (key) {
    var value = mpComponentOptions[key];
    if (isFn(value) && PAGE_LIFECYCLE.indexOf(key) === -1) {
      methods[key] = value;
    }
  });
  vueComponentOptions.methods = methods;
}

function parsePageLifecycle(mpComponentOptions, vueComponentOptions) {
  Object.keys(mpComponentOptions).forEach(function (key) {
    if (PAGE_LIFECYCLE.indexOf(key) !== -1) {
      vueComponentOptions[key] = mpComponentOptions[key];
    }
  });
}

function parsePage(mpComponentOptions) {
  var vueComponentOptions = {
    mixins: [],
    mpOptions: {} };


  parseComponents(vueComponentOptions);

  parseData(mpComponentOptions.data, vueComponentOptions);

  parsePageMethods(mpComponentOptions, vueComponentOptions);
  parsePageLifecycle(mpComponentOptions, vueComponentOptions);

  return vueComponentOptions;
}

function parseProperties(properties, vueComponentOptions) {
  if (!properties) {
    return;
  }
  vueComponentOptions.mpOptions.properties = properties;
}

function parseOptions(options, vueComponentOptions) {
  if (!options) {
    return;
  }
  vueComponentOptions.mpOptions.options = options;
}

function parseMethods(methods, vueComponentOptions) {
  if (!methods) {
    return;
  }
  if (methods.$emit) {
    console.warn('Method "$emit" conflicts with an existing Vue instance method');
    delete methods.$emit;
  }
  vueComponentOptions.methods = methods;
}

function parseLifecycle(mpComponentOptions, vueComponentOptions) {
  COMPONENT_LIFECYCLE_KEYS.forEach(function (name) {
    if (hasOwn(mpComponentOptions, name)) {
      (vueComponentOptions[COMPONENT_LIFECYCLE[name]] || (vueComponentOptions[COMPONENT_LIFECYCLE[name]] = [])).
      push(mpComponentOptions[name]);
    }
  });
}

var mpBehaviors = {
  'wx://form-field': {},
  'wx://component-export': {} };


function callDefinitionFilter(mpComponentOptions) {var

  behaviors =

  mpComponentOptions.behaviors,definitionFilter = mpComponentOptions.definitionFilter;

  var behaviorDefinitionFilters = [];

  if (Array.isArray(behaviors)) {
    behaviors.forEach(function (behavior) {
      behavior = typeof behavior === 'string' ? mpBehaviors[behavior] : behavior;
      if (behavior.definitionFilter) {
        behaviorDefinitionFilters.push(behavior.definitionFilter);
        behavior.definitionFilter.call(null, mpComponentOptions, []);
      }
    });
  }

  if (isFn(definitionFilter)) {
    return function (defFields) {
      definitionFilter(defFields, behaviorDefinitionFilters);
    };
  }
}

function parseDefinitionFilter(mpComponentOptions, vueComponentOptions) {
  callDefinitionFilter(mpComponentOptions);
}

function parseBehavior(behavior) {var

  data =



  behavior.data,methods = behavior.methods,behaviors = behavior.behaviors,properties = behavior.properties;

  var vueComponentOptions = {
    watch: {},
    mpOptions: {
      mpObservers: [] } };



  parseData(data, vueComponentOptions);
  parseMethods(methods, vueComponentOptions);
  parseBehaviors(behaviors, vueComponentOptions);
  parseProperties(properties, vueComponentOptions);

  parseLifecycle(behavior, vueComponentOptions);
  parseDefinitionFilter(behavior);

  return vueComponentOptions;
}

var BEHAVIORS = {
  'wx://form-field': {
    beforeCreate: function beforeCreate() {
      var mpOptions = this.$options.mpOptions;
      if (!mpOptions.properties) {
        mpOptions.properties = Object.create(null);
      }

      var props = mpOptions.properties;
      // TODO form submit,reset
      if (!hasOwn(props, 'name')) {
        props.name = {
          type: String };

      }
      if (!hasOwn(props, 'value')) {
        props.value = {
          type: String // 默认类型调整为 String,否则默认值为 null,导致一些自定义 input 显示不正确
        };
      }
    } } };



function parseBehaviors(behaviors, vueComponentOptions) {
  if (!behaviors) {
    return;
  }
  behaviors.forEach(function (behavior) {
    if (typeof behavior === 'string') {
      BEHAVIORS[behavior] && vueComponentOptions.mixins.push(BEHAVIORS[behavior]);
    } else {
      vueComponentOptions.mixins.push(parseBehavior(behavior));
    }
  });
}

function parseSinglePath(path) {
  return path.split('.');
}

function parseMultiPaths(paths) {
  return paths.split(',').map(function (path) {return parseSinglePath(path);});
}

function parseObservers(observers, vueComponentOptions) {
  if (!observers) {
    return;
  }var


  mpObservers =
  vueComponentOptions.mpOptions.mpObservers;

  Object.keys(observers).forEach(function (path) {
    mpObservers.push({
      paths: parseMultiPaths(path),
      observer: observers[path] });

  });
}

function relative(from, to) {
  if (to.indexOf('/') === 0) {
    from = '';
  }
  var fromArr = from.split('/');
  var toArr = to.split('/');
  fromArr.pop();
  while (toArr.length) {
    var part = toArr.shift();
    if (part !== '' && part !== '.') {
      if (part !== '..') {
        fromArr.push(part);
      } else {
        fromArr.pop();
      }
    }
  }
  return fromArr.join('/');
}

function parseRelations(relations, vueComponentOptions) {
  if (!relations) {
    return;
  }
  Object.keys(relations).forEach(function (name) {
    var relation = relations[name];
    relation.name = name;
    relation.target = relation.target ? String(relation.target) : relative(global.__wxRoute, name);
  });
  vueComponentOptions.mpOptions.relations = relations;
}

function parseExternalClasses(externalClasses, vueComponentOptions) {
  if (!externalClasses) {
    return;
  }
  if (!Array.isArray(externalClasses)) {
    externalClasses = [externalClasses];
  }
  vueComponentOptions.mpOptions.externalClasses = externalClasses;
  if (!vueComponentOptions.mpOptions.properties) {
    vueComponentOptions.mpOptions.properties = Object.create(null);
  }
  externalClasses.forEach(function (externalClass) {
    vueComponentOptions.mpOptions.properties[camelize(externalClass)] = {
      type: String,
      value: '' };

  });
}

function parseLifetimes(lifetimes, vueComponentOptions) {
  if (!lifetimes) {
    return;
  }
  parseLifecycle(lifetimes, vueComponentOptions);
}

function parsePageLifetimes(pageLifetimes, vueComponentOptions) {
  if (!pageLifetimes) {
    return;
  }
  PAGE_LIFETIMES_KEYS.forEach(function (key) {
    var lifetimeFn = pageLifetimes[key];
    isFn(lifetimeFn) && (vueComponentOptions[PAGE_LIFETIMES[key]] = lifetimeFn);
  });
}

function parseComponent(mpComponentOptions) {var

  data =









  mpComponentOptions.data,options = mpComponentOptions.options,methods = mpComponentOptions.methods,behaviors = mpComponentOptions.behaviors,lifetimes = mpComponentOptions.lifetimes,observers = mpComponentOptions.observers,relations = mpComponentOptions.relations,properties = mpComponentOptions.properties,pageLifetimes = mpComponentOptions.pageLifetimes,externalClasses = mpComponentOptions.externalClasses;

  var vueComponentOptions = {
    mixins: [],
    props: {},
    watch: {},
    mpOptions: {
      mpObservers: [] } };



  parseComponents(vueComponentOptions);

  parseData(data, vueComponentOptions);
  parseOptions(options, vueComponentOptions);
  parseMethods(methods, vueComponentOptions);
  parseBehaviors(behaviors, vueComponentOptions);
  parseLifetimes(lifetimes, vueComponentOptions);
  parseObservers(observers, vueComponentOptions);
  parseRelations(relations, vueComponentOptions);
  parseProperties(properties, vueComponentOptions);
  parsePageLifetimes(pageLifetimes, vueComponentOptions);
  parseExternalClasses(externalClasses, vueComponentOptions);

  parseLifecycle(mpComponentOptions, vueComponentOptions);
  parseDefinitionFilter(mpComponentOptions);

  return vueComponentOptions;
}

function initRelationHandlers(type, handler, target, ctx) {
  if (!handler) {
    return;
  }
  var name = "_$".concat(type, "Handlers");
  (ctx[name] || (ctx[name] = [])).push(function () {
    handler.call(ctx, target);
  });
}

function initLinkedHandlers(relation, target, ctx) {
  var type = 'linked';
  var name = relation.name;
  var relationNodes = ctx._$relationNodes || (ctx._$relationNodes = Object.create(null));
  (relationNodes[name] || (relationNodes[name] = [])).push(target);
  initRelationHandlers(type, relation[type], target, ctx);
}

function initUnlinkedHandlers(relation, target, ctx) {
  var type = 'unlinked';
  initRelationHandlers(type, relation[type], target, ctx);
}

function findParentRelation(parentVm, target, type) {
  var relations = parentVm &&
  parentVm.$options.mpOptions &&
  parentVm.$options.mpOptions.relations;

  if (!relations) {
    return [];
  }
  var name = Object.keys(relations).find(function (name) {
    var relation = relations[name];
    return relation.target === target && relation.type === type;
  });
  if (!name) {
    return [];
  }
  return [relations[name], parentVm];
}

function initParentRelation(vm, childRelation, match) {var _match =
  match(vm, vm.$options.mpOptions.path),_match2 = _slicedToArray(_match, 2),parentRelation = _match2[0],parentVm = _match2[1];
  if (!parentRelation) {
    return;
  }

  initLinkedHandlers(parentRelation, vm, parentVm);
  initLinkedHandlers(childRelation, parentVm, vm);

  initUnlinkedHandlers(parentRelation, vm, parentVm);
  initUnlinkedHandlers(childRelation, parentVm, vm);
}

function initRelation(relation, vm) {
  var type = relation.type;
  if (type === 'parent') {
    initParentRelation(vm, relation, function matchParent(vm, target) {
      return findParentRelation(vm.$parent, target, 'child');
    });
  } else if (type === 'ancestor') {
    initParentRelation(vm, relation, function matchAncestor(vm, target) {
      var $parent = vm.$parent;
      while ($parent) {
        var ret = findParentRelation($parent, target, 'descendant');
        if (ret.length) {
          return ret;
        }
        $parent = $parent.$parent;
      }
      return [];
    });
  }
}

function initRelations(vm) {var _ref =


  vm.$options.mpOptions || {},relations = _ref.relations;
  if (!relations) {
    return;
  }
  Object.keys(relations).forEach(function (name) {
    initRelation(relations[name], vm);
  });
}

function handleRelations(vm, type) {
  // TODO 需要移除 relationNodes
  var handlers = vm["_$".concat(type, "Handlers")];
  if (!handlers) {
    return;
  }
  handlers.forEach(function (handler) {return handler();});
}

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop };


function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function setDataByExprPath(exprPath, value, data) {
  var keys = exprPath.replace(/\[(\d+?)\]/g, '.$1').split('.');
  keys.reduce(function (obj, key, idx) {
    if (idx === keys.length - 1) {
      obj[key] = value;
    } else {
      if (typeof obj[key] === 'undefined') {
        obj[key] = {};
      }
      return obj[key];
    }
  }, data);
  return keys.length === 1;
}

function setData(data, callback) {var _this = this;
  if (!isPlainObject(data)) {
    return;
  }
  Object.keys(data).forEach(function (key) {
    if (setDataByExprPath(key, data[key], _this.data)) {
      !hasOwn(_this, key) && proxy(_this, SOURCE_KEY, key);
    }
  });
  this.$forceUpdate();
  isFn(callback) && this.$nextTick(callback);
}

/**
   * https://github.com/swan-team/swan-js/blob/61e2a63f7aa576b5daafbe77fdfa7c65b977060c/src/utils/index.js
   */

var _toString$1 = Object.prototype.toString;
/**
                                              * 深度assign的函数
                                              * @param {Object} targetObject 要被拷贝的目标对象
                                              * @param {Object} originObject 拷贝的源对象
                                              * @return {Object} merge后的对象
                                              */
var deepAssign = function deepAssign() {var targetObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};var originObject = arguments.length > 1 ? arguments[1] : undefined;
  var originType = _toString$1.call(originObject);
  if (originType === '[object Array]') {
    targetObject = originObject.slice(0);
    return targetObject;
  } else if (originType === '[object Object]') {
    for (var key in originObject) {
      targetObject[key] = deepAssign(targetObject[key], originObject[key]);
    }
    return targetObject;
  } else if (originType === '[object Date]') {
    return new Date(originObject.getTime());
  } else if (originType === '[object RegExp]') {
    var target = String(originObject);
    var lastIndex = target.lastIndexOf('/');
    return new RegExp(target.slice(1, lastIndex), target.slice(lastIndex + 1));
  }
  return originObject;
};

/**
    * 深度拷贝逻辑，不同于lodash等库，但是与微信一致
    * @param {*} [originObj] 原对象
    * @return {Object|Array} 拷贝结果
    */
var deepClone = function deepClone(originObj) {
  return deepAssign(_toString$1.call(originObj) === '[object Array]' ? [] : {}, originObj);
};

var PROP_DEFAULT_VALUES = (_PROP_DEFAULT_VALUES = {}, _defineProperty(_PROP_DEFAULT_VALUES,
String, ''), _defineProperty(_PROP_DEFAULT_VALUES,
Number, 0), _defineProperty(_PROP_DEFAULT_VALUES,
Boolean, false), _defineProperty(_PROP_DEFAULT_VALUES,
Object, null), _defineProperty(_PROP_DEFAULT_VALUES,
Array, []), _defineProperty(_PROP_DEFAULT_VALUES,
null, null), _PROP_DEFAULT_VALUES);


function getDefaultVal(propType) {
  return PROP_DEFAULT_VALUES[propType];
}

function getPropertyVal(options) {
  if (isPlainObject(options)) {
    if (hasOwn(options, 'value')) {
      return options.value;
    }
    return getDefaultVal(options.type);
  }
  return getDefaultVal(options);
}

function getType(propOptions) {
  return isPlainObject(propOptions) ? propOptions.type : propOptions;
}

function validateProp(key, propsOptions, propsData, vm) {
  var value = propsData[key];
  if (value !== undefined) {
    var propOptions = propsOptions[key];
    var type = getType(propOptions);
    value = formatVal(value, type);
    var observer = propOptions && propOptions.observer;
    if (observer) {
      // 初始化时,异步触发 observer,否则 observer 中无法访问 methods 或其他
      setTimeout(function () {
        observe(observer, vm, value);
      }, 4);
    }
    return value;
  }
  return getPropertyVal(propsOptions[key]);
}

function formatVal(val, type) {
  if (type === Boolean) {
    return !!val;
  } else if (type === String) {
    return String(val);
  }
  return val;
}

function observe(observer, vm, newVal, oldVal) {
  try {
    if (typeof observer === 'function') {
      observer.call(vm, newVal, oldVal);
    } else if (typeof observer === 'string' &&
    typeof vm[observer] === 'function')
    {
      vm[observer](newVal, oldVal);
    }
  } catch (err) {
    console.error("execute observer ".concat(observer, " callback fail! err: ").concat(err));
  }
}

function initProperties(vm, instanceData) {
  var properties = vm.$options.mpOptions.properties;
  if (!properties) {
    return;
  }

  var propsData = deepClone(vm.$options.propsData) || {};var _loop = function _loop(

  key) {
    var observer = isPlainObject(properties[key]) ? properties[key].observer : false;
    var value = validateProp(key, properties, propsData, vm);
    Object.defineProperty(instanceData, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return value;
      },
      set: function set(newVal) {
        var oldVal = value;
        /* eslint-disable no-self-compare */
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        // TODO 临时方案,clone array
        value = Array.isArray(newVal) ? newVal.slice(0) : newVal;
        if (observer) {
          observe(observer, vm, newVal, oldVal);
        }
        // 触发渲染
        vm.$forceUpdate();
      } });};for (var key in properties) {_loop(key);

  }
}

function updateProperties(vm) {
  var properties = vm.$options.mpOptions && vm.$options.mpOptions.properties;
  var propsData = vm.$options.propsData;
  if (propsData && properties) {
    Object.keys(properties).forEach(function (key) {
      if (hasOwn(propsData, key)) {
        vm[key] = formatVal(propsData[key], getType(properties[key]));
      }
    });
  }
}

function initState(vm) {
  var instanceData = JSON.parse(JSON.stringify(vm.$options.mpOptions.data || {}));

  vm[SOURCE_KEY] = instanceData;

  var propertyDefinition = {
    get: function get() {
      return vm[SOURCE_KEY];
    },
    set: function set(value) {
      vm[SOURCE_KEY] = value;
    } };


  Object.defineProperties(vm, {
    data: propertyDefinition,
    properties: propertyDefinition });


  vm.setData = setData;

  initProperties(vm, instanceData);

  Object.keys(instanceData).forEach(function (key) {
    proxy(vm, SOURCE_KEY, key);
  });
}

function initMethods(vm) {
  var oldEmit = vm.$emit;
  vm.triggerEvent = function (eventName, detail, options) {
    var target = {
      dataset: vm.$el.dataset };


    var event = {
      target: target,
      currentTarget: target,
      detail: detail,
      preventDefault: noop,
      stopPropagation: noop };


    oldEmit.call(vm, eventName, event);
  };
  // 主要是Vant 自己封装了 $emit,放到 methods 中会触发 Vue 的警告,索性,框架直接重写该方法
  vm.$emit = function () {
    vm.triggerEvent.apply(vm, arguments);
  };
  vm.getRelationNodes = function (relationKey) {
    // 需要过滤已被销毁的vm
    /* eslint-disable  no-mixed-operators */
    return (vm._$relationNodes && vm._$relationNodes[relationKey] || []).filter(function (vm) {return !vm._isDestroyed;});
  };

  vm._$updateProperties = updateProperties;
}

function handleObservers(vm) {
  var watch = vm.$options.watch;
  if (!watch) {
    return;
  }
  Object.keys(watch).forEach(function (name) {
    var observer = watch[name];
    if (observer.mounted) {
      var val = vm[name];
      var handler = observer.handler;
      if (typeof handler === 'string') {
        handler = vm[handler];
      }
      handler && handler.call(vm, val, val);
    }
  });
}

var polyfill = {
  beforeCreate: function beforeCreate() {
    // 取消 development 时的 Proxy,避免小程序组件模板中使用尚未定义的属性告警
    this._renderProxy = this;

    this._$self = this;
    this._$noop = noop;
  },
  created: function created() {// properties 中可能会访问 methods,故需要在 created 中初始化
    initState(this);
    initMethods(this);
    initRelations(this);
  },
  mounted: function mounted() {
    handleObservers(this);
  },
  destroyed: function destroyed() {
    handleRelations(this, 'unlinked');
  } };


global.__wxRoute = '';
global.__wxComponents = Object.create(null);
global.__wxVueOptions = Object.create(null);

function Page(options) {
  var pageOptions = parsePage(options);
  pageOptions.mixins.unshift(polyfill);
  pageOptions.mpOptions.path = global.__wxRoute;
  global.__wxComponents[global.__wxRoute] = pageOptions;
}

function initRelationsHandler(vueComponentOptions) {
  // linked 需要在当前组件 attached 之后再执行
  if (!vueComponentOptions.onServiceAttached) {
    vueComponentOptions.onServiceAttached = [];
  }
  vueComponentOptions.onServiceAttached.push(function onServiceAttached() {
    handleRelations(this, 'linked');
  });
}

function Component(options) {
  var componentOptions = parseComponent(options);
  componentOptions.mixins.unshift(polyfill);
  componentOptions.mpOptions.path = global.__wxRoute;
  initRelationsHandler(componentOptions);
  global.__wxComponents[global.__wxRoute] = componentOptions;
}

function Behavior(options) {
  return options;
}

var nextTick = _vue.default.nextTick;exports.nextTick = nextTick;

var index = uni.__$wx__;var _default =

index;exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ 9)))

/***/ }),
/* 11 */
/*!**********************!*\
  !*** external "Vue" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Vue;

/***/ }),
/* 12 */
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode, /* vue-cli only */
  components, // fixed by xxxxxx auto components
  renderjs // fixed by xxxxxx renderjs
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // fixed by xxxxxx auto components
  if (components) {
    if (!options.components) {
      options.components = {}
    }
    var hasOwn = Object.prototype.hasOwnProperty
    for (var name in components) {
      if (hasOwn.call(components, name) && !hasOwn.call(options.components, name)) {
        options.components[name] = components[name]
      }
    }
  }
  // fixed by xxxxxx renderjs
  if (renderjs) {
    (renderjs.beforeCreate || (renderjs.beforeCreate = [])).unshift(function() {
      this[renderjs.__module] = this
    });
    (options.mixins || (options.mixins = [])).push(renderjs)
  }

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 13 */
/*!*******************************************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/my/my.vue?mpType=page ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _my_vue_vue_type_template_id_1cc45dd4_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./my.vue?vue&type=template&id=1cc45dd4&mpType=page */ 14);\n/* harmony import */ var _my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./my.vue?vue&type=script&lang=js&mpType=page */ 16);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js */ 12);\n\nvar renderjs\n\n\n\n\n/* normalize component */\n\nvar component = Object(_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _my_vue_vue_type_template_id_1cc45dd4_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _my_vue_vue_type_template_id_1cc45dd4_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null,\n  false,\n  _my_vue_vue_type_template_id_1cc45dd4_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"components\"],\n  renderjs\n)\n\ncomponent.options.__file = \"pages/my/my.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEg7QUFDMUg7QUFDaUU7QUFDTDs7O0FBRzVEO0FBQzZMO0FBQzdMLGdCQUFnQiwyTEFBVTtBQUMxQixFQUFFLG1GQUFNO0FBQ1IsRUFBRSx3RkFBTTtBQUNSLEVBQUUsaUdBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNEZBQVU7QUFDWjtBQUNBOztBQUVBO0FBQ2UsZ0YiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucywgcmVjeWNsYWJsZVJlbmRlciwgY29tcG9uZW50cyB9IGZyb20gXCIuL215LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xY2M0NWRkNCZtcFR5cGU9cGFnZVwiXG52YXIgcmVuZGVyanNcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vbXkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJm1wVHlwZT1wYWdlXCJcbmV4cG9ydCAqIGZyb20gXCIuL215LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZtcFR5cGU9cGFnZVwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9Qcm9ncmFtIEZpbGVzL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL0BkY2xvdWRpby92dWUtY2xpLXBsdWdpbi11bmkvcGFja2FnZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgZmFsc2UsXG4gIGNvbXBvbmVudHMsXG4gIHJlbmRlcmpzXG4pXG5cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicGFnZXMvbXkvbXkudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!*************************************************************************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/my/my.vue?vue&type=template&id=1cc45dd4&mpType=page ***!
  \*************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_template_id_1cc45dd4_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--10-0!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./my.vue?vue&type=template&id=1cc45dd4&mpType=page */ 15);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_template_id_1cc45dd4_mpType_page__WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_template_id_1cc45dd4_mpType_page__WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_template_id_1cc45dd4_mpType_page__WEBPACK_IMPORTED_MODULE_0__["recyclableRender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "components", function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_10_0_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_template_id_1cc45dd4_mpType_page__WEBPACK_IMPORTED_MODULE_0__["components"]; });



/***/ }),
/* 15 */
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--10-0!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/my/my.vue?vue&type=template&id=1cc45dd4&mpType=page ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return recyclableRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "components", function() { return components; });
var components
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "view",
    { staticClass: _vm._$s(0, "sc", "content"), attrs: { _i: 0 } },
    [
      _c("image", { staticClass: _vm._$s(1, "sc", "logo"), attrs: { _i: 1 } }),
      _c(
        "view",
        { staticClass: _vm._$s(2, "sc", "text-area"), attrs: { _i: 2 } },
        [
          _c(
            "text",
            { staticClass: _vm._$s(3, "sc", "title"), attrs: { _i: 3 } },
            [_vm._v(_vm._$s(3, "t0-0", _vm._s(_vm.title)))]
          )
        ]
      )
    ]
  )
}
var recyclableRender = false
var staticRenderFns = []
render._withStripped = true



/***/ }),
/* 16 */
/*!*******************************************************************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/my/my.vue?vue&type=script&lang=js&mpType=page ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/babel-loader/lib!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!../../../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./my.vue?vue&type=script&lang=js&mpType=page */ 17);\n/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_my_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWlwQixDQUFnQiwybkJBQUcsRUFBQyIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXByZXByb2Nlc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtMSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9Qcm9ncmFtIEZpbGVzL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL0BkY2xvdWRpby92dWUtY2xpLXBsdWdpbi11bmkvcGFja2FnZXMvd2VicGFjay11bmktYXBwLWxvYWRlci91c2luZy1jb21wb25lbnRzLmpzIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbXkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJm1wVHlwZT1wYWdlXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXByZXByb2Nlc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtMSEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9Qcm9ncmFtIEZpbGVzL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL0BkY2xvdWRpby92dWUtY2xpLXBsdWdpbi11bmkvcGFja2FnZXMvd2VicGFjay11bmktYXBwLWxvYWRlci91c2luZy1jb21wb25lbnRzLmpzIS4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbXkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJm1wVHlwZT1wYWdlXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!C:/Users/Administrator/Projects/season1/4.App/smarthome/pages/my/my.vue?vue&type=script&lang=js&mpType=page ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = void 0; //\n//\n//\n//\n//\n//\n//\n//\n//\nvar _default =\n{\n  data: function data() {\n    return {\n      title: '你好, uni-app' };\n\n  },\n  onLoad: function onLoad() {\n\n  },\n  methods: {} };exports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vcGFnZXMvbXkvbXkudnVlIl0sIm5hbWVzIjpbImRhdGEiLCJ0aXRsZSIsIm9uTG9hZCIsIm1ldGhvZHMiXSwibWFwcGluZ3MiOiJ3RkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZEEsTUFEYyxrQkFDUDtBQUNOLFdBQU87QUFDTkMsV0FBSyxFQUFFLGFBREQsRUFBUDs7QUFHQSxHQUxhO0FBTWRDLFFBTmMsb0JBTUw7O0FBRVIsR0FSYTtBQVNkQyxTQUFPLEVBQUUsRUFUSyxFIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGRhdGEoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRpdGxlOiAn5L2g5aW9LCB1bmktYXBwJ1xuXHRcdH1cblx0fSxcblx0b25Mb2FkKCkge1xuXG5cdH0sXG5cdG1ldGhvZHM6IHtcblxuXHR9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/*!***********************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/App.vue ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=js& */ 19);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js */ 12);\nvar render, staticRenderFns, recyclableRender, components\nvar renderjs\n\n\n\n\n/* normalize component */\n\nvar component = Object(_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n  _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null,\n  false,\n  components,\n  renderjs\n)\n\ncomponent.options.__file = \"App.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUN1RDtBQUNMOzs7QUFHbEQ7QUFDdUw7QUFDdkwsZ0JBQWdCLDJMQUFVO0FBQzFCLEVBQUUseUVBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNlLGdGIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciwgc3RhdGljUmVuZGVyRm5zLCByZWN5Y2xhYmxlUmVuZGVyLCBjb21wb25lbnRzXG52YXIgcmVuZGVyanNcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGwsXG4gIGZhbHNlLFxuICBjb21wb25lbnRzLFxuICByZW5kZXJqc1xuKVxuXG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIkFwcC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/*!************************************************************************************************!*\
  !*** C:/Users/Administrator/Projects/season1/4.App/smarthome/App.vue?vue&type=script&lang=js& ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/babel-loader/lib!../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!../../../../../../Program Files/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./App.vue?vue&type=script&lang=js& */ 20);\n/* harmony import */ var _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_6_1_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_Program_Files_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQSttQixDQUFnQixpbkJBQUcsRUFBQyIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXByZXByb2Nlc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtMSEuLi8uLi8uLi8uLi8uLi8uLi9Qcm9ncmFtIEZpbGVzL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL0BkY2xvdWRpby92dWUtY2xpLXBsdWdpbi11bmkvcGFja2FnZXMvd2VicGFjay11bmktYXBwLWxvYWRlci91c2luZy1jb21wb25lbnRzLmpzIS4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi9Qcm9ncmFtIEZpbGVzL0hCdWlsZGVyWC9wbHVnaW5zL3VuaWFwcC1jbGkvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3dlYnBhY2stcHJlcHJvY2Vzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uLy4uLy4uL1Byb2dyYW0gRmlsZXMvSEJ1aWxkZXJYL3BsdWdpbnMvdW5pYXBwLWNsaS9ub2RlX21vZHVsZXMvQGRjbG91ZGlvL3Z1ZS1jbGktcGx1Z2luLXVuaS9wYWNrYWdlcy93ZWJwYWNrLXVuaS1hcHAtbG9hZGVyL3VzaW5nLWNvbXBvbmVudHMuanMhLi4vLi4vLi4vLi4vLi4vLi4vUHJvZ3JhbSBGaWxlcy9IQnVpbGRlclgvcGx1Z2lucy91bmlhcHAtY2xpL25vZGVfbW9kdWxlcy9AZGNsb3VkaW8vdnVlLWNsaS1wbHVnaW4tdW5pL3BhY2thZ2VzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--6-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!C:/Users/Administrator/Projects/season1/4.App/smarthome/App.vue?vue&type=script&lang=js& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__f__) {Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = void 0;var _default =\n{\n  onLaunch: function onLaunch() {\n    __f__(\"log\", 'App Launch', \" at App.vue:4\");\n  },\n  onShow: function onShow() {\n    __f__(\"log\", 'App Show', \" at App.vue:7\");\n  },\n  onHide: function onHide() {\n    __f__(\"log\", 'App Hide', \" at App.vue:10\");\n  } };exports.default = _default;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js */ 7)[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vQXBwLnZ1ZSJdLCJuYW1lcyI6WyJvbkxhdW5jaCIsIm9uU2hvdyIsIm9uSGlkZSJdLCJtYXBwaW5ncyI6IjtBQUNlO0FBQ2RBLFVBQVEsRUFBRSxvQkFBVztBQUNwQixpQkFBWSxZQUFaO0FBQ0EsR0FIYTtBQUlkQyxRQUFNLEVBQUUsa0JBQVc7QUFDbEIsaUJBQVksVUFBWjtBQUNBLEdBTmE7QUFPZEMsUUFBTSxFQUFFLGtCQUFXO0FBQ2xCLGlCQUFZLFVBQVo7QUFDQSxHQVRhLEUiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBkZWZhdWx0IHtcblx0b25MYXVuY2g6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUubG9nKCdBcHAgTGF1bmNoJylcblx0fSxcblx0b25TaG93OiBmdW5jdGlvbigpIHtcblx0XHRjb25zb2xlLmxvZygnQXBwIFNob3cnKVxuXHR9LFxuXHRvbkhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUubG9nKCdBcHAgSGlkZScpXG5cdH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n");

/***/ })
],[[0,"app-config"]]]);